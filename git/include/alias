# https://gist.github.com/codexico/2a34c0d599f3af93b46f

[alias]  
	move-and-rename = "!f() { target=$(ls -S $@ | head -n 1); for file in $@; do if [ $file != $target ]; then oldName=$(basename $file); mv -f $file $target; git add .; git commit -m \"Moved and renamed $oldName to $target\"; fi; done; }; f"	

	lazy = "!f() { git add -A && git commit -m '[chore] lazy $@' && git push; }; f"
	lazyNoPush = "!f() { git add -A && git commit -m '[chore] lazy $@'; }; f"
	pushAllorig = git push --all --progress "origin"
	lazypullpush = "!f() { git lazy $@ && git pull && git pushallorig ; }; f"
	lazyPush = "!f() { git alias.lazy $@ && git push; }; f"
	lazyUpdate =  "!f() { git alias.lazy $@ && git pull && git push; }; f"

	rmmergedBranches = 		"!f() { git branch --merged ${1-master} | grep -v " ${1-master}$" | xargs -r git branch -d; }; f"
	forgetignored =			"todo:, "
	forgetLazy = 			"!f() { git alia.forget $@ && git commit -m '[chore] forgot $@' ; }; f"
	revertLast =  			"todo:, reset index"
	inCommit =  			"todo:, ammend then commit"
	origin =				"!f() { git remote -orignin ; }; f"

	join =					"todo:, merge two files and remeber line history"
	divide =				"todo:, split file into two files and remeber line history"


	subSplit = "!f() { git subtree split -P $@ -b $@ && git lazy '[chore] subtree$@'; }; f"
	forgetPath = "!f() { git rm -fr --cached $@ && git commit -am '[chore] forgot $@' ; }; f"
	pathToBranchpushOrig = "!f() { git subtree split --prefix $@ --branch=$@ && git push --progress origin Modules:$@ ; }; f"
	delmergedBranches = "!f() { git branch --merged ${1-master} | grep -v " ${1-master}$" | xargs -r git branch -d; }; f"
	commendhead = commit -a --amend -C HEAD

	jq = "!f() { ! ./jq.exe << $@   ; }; f"

    # List all aliases, only the names
    alias = !git config --list | grep 'alias\\.' | sed 's/alias\\.\\([^=]*\\)=\\(.*\\)/\\1/' | sort;

    # List all aliases, names and commands
    aliases = !git config --list | grep 'alias\\.' | sed 's/alias\\.\\([^=]*\\)=\\(.*\\)/\\1\\\t\\2/' | sort;

    forgremotebranches = !git branch -rd $( git branch -a | grep 'origin' | grep -wv '>' | cut -d'/' -f2-10)

	
    # Clone a repository including all submodules
    cloneall = clone --recursive

    # Where it is?
    url = remote -v;

    hashes = git rev-list --all	


    ##########
    # Logs and infos
    ##########

    # Who contributed and how much
    who = shortlog -sne;

    # Show last commit
    last = log -1 HEAD;

    # Last tag
    lasttag = describe --tags --abbrev=0;

    # View abbreviated SHA, description, and history graph of the latest 20 commits
    l = log --graph --abbrev-commit --pretty=oneline -n 20;

    # View the SHA, description, date, author and history graph
    # Example:
    # * 66a2a64 - comment (20 hours ago) <USER1>
    # *   6a7206f - Merge branch 'develop' into very-cool-feature (21 hours ago) <USER2>
    # |\
    # | * 1748c5f - comment (21 hours ago) <USER2>
    # | * e3a42a1 - comment (21 hours ago) <USER2>
    # * 2667f01 - comment (2 days ago) <USER3>
    # * 7f5722d - comment (2 days ago) <USER1>
    #
    history = log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset';

    # View the SHA, description, date, and history graph of my commits
    # Example:
    # * 66a2a64 - comment (20 hours ago) <USER1>
    # *   6a7206f - Merge branch 'develop' into very-cool-feature (21 hours ago) <USER2>
    # |\
    # | * 1748c5f - comment (21 hours ago) <USER2>
    # | * e3a42a1 - comment (21 hours ago) <USER2>
    # * 2667f01 - comment (2 days ago) <USER3>
    # * 7f5722d - comment (2 days ago) <USER1>
    #
    mylog = log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --author="$(git config USER.name)";

    # List contributors with number of commits
    contributors = shortlog --summary --numbered;

    # Show verbose output about tags
    tags = tag -l




    ##########
    # Status
    ##########

    # View the current working tree status using the short format
    s = status -s;

    # Diff
    d = diff --patch-with-stat;

    # Show the diff between the latest commit and the current state
    d = !"git diff-index --quiet HEAD -- || clear; git --no-pager diff --patch-with-stat"

    # `git di $number` shows the diff between the state `$number` revisions ago and the current state
    di = !"d() { git diff --patch-with-stat HEAD~$1; }; git diff-index --quiet HEAD -- || clear; d"




    ##########
    # Commits
    ##########

    # lazy alias
    c = commit;

    # Commit all changes
    ac = !git add . && git add -u && git commit -a;

    # add and commit with message, dont need quotation marks
    # Example:
    # git acm message without quotes
    acm = "!f() { git add . && git commit -m \"$(echo $@)\"; }; f";

    # Amend the currently staged files to the latest commit
    amend = commit --amend --reuse-message=HEAD

    # mark file as unchanged to prevent commits
    assume = git update-index --assume-unchanged;
    assumeall = "!git st -s | awk {'print $2'} | xargs git assume"

    # remove mark file as unchanged
    unassume = git update-index --no-assume-unchanged;
    unassumeall = "!git assumed | xargs git update-index --no-assume-unchanged"

    # Interactive rebase with the given number of latest commits
    reb = "!r() { git rebase -i HEAD~$1; }; r"



    ##########
    # Pull, Push
    ##########

    # pull this branch
    get = !git pull origin $(git rev-parse --abbrev-ref HEAD);

    # Pull in remote changes for the current repository and all its submodules
    pullall = !"git pull origin $(git rev-parse --abbrev-ref HEAD); git submodule foreach git pull origin master"

    # push this branch
    post = !git push origin $(git rev-parse --abbrev-ref HEAD);

    # pull and push this branch
    update = "!f() { BRANCH=$(git rev-parse --abbrev-ref HEAD); git s && git pull origin ${BRANCH} && git push origin ${BRANCH}; }; f";




    ##########
    # Deploys
    ##########

    # update develop
    dev-deploy = !git pull origin develop && git push origin develop;

    # update this branch and send to another branch, and return to this branch
    mergeto = "!f() { BRANCH=$(git rev-parse --abbrev-ref HEAD); git pull origin ${BRANCH} && git push origin ${BRANCH} && git checkout $1 && git pull origin $1 && git merge ${BRANCH} && git push origin $1 && git checkout ${BRANCH}; }; f";

    # update this branch and send to develop and another branch (release), and return to this branch
    #
    #                 another
    # branch develop  branch
    #      |
    #       \
    #           |
    #            \
    #                  |
    branch-deploy = "!f() { BRANCH=$(git rev-parse --abbrev-ref HEAD); git pull origin ${BRANCH} && git push origin ${BRANCH} && git checkout develop && git pull origin develop && git merge ${BRANCH} && git push origin develop && git checkout $1 && git pull origin $1 && git merge develop && git push origin $1 && git checkout ${BRANCH}; }; f";




    ##########
    # Branchs
    ##########

    # lazy alias
    b = branch;
    co = checkout;

    # create branch local and remote
    create = "!f() { git checkout -B $1 && git push origin $1; }; f";

    # Switch to a branch, creating it if necessary
    go = "!f() { git checkout -b \"$1\" 2> /dev/null || git checkout \"$1\"; }; f"

    # update branchs
    branchs = !git fetch --all && git fetch -p && git branch -a;

    # change to another branch and update
    go = "!f() { git checkout $1 && git pull origin $1; }; f";

    # remove branchs that dont exist on remote
    # (you should be on one existing branch)
    # TODO: 'git remote prune origin' does the same?
    delete-not-on-remote-branches = !git branch -a | egrep -v 'origin|master|develop' | xargs -n1 git branch -d;

    # force remove branchs that dont exist on remote
    # (you should be on one existing branch)
    force-delete-not-on-remote-branches = !git branch -a | egrep -v 'origin|master|develop' | xargs -n1 git branch -D;

    # remove branchs merged on master
    # TODO: dont remove develop if it is sync with master
    delete-merged-branches = !git branch --merged master | grep -v 'master' | xargs -n 1 git branch -d;

    # force remove branchs merged on master
    force-delete-merged-branches = !git branch --merged master | grep -v 'master' | xargs -n 1 git branch -D;




    ##########
    # Undo
    ##########

    # Undo a `git push`
    undopush = push -f origin HEAD^:master;

    # Undo merge
    undomerge = reset --hard HEAD@{1};

    # Undo changes not commited
    undo = reset --hard;

    # Undo last commit and remove from stage
    # Example
    # git unstage file1 file2 ...
    unstage = reset HEAD -- #file;




    ##########
    # Merge
    ##########

    # merge and use mine
    ours = "!f() { git checkout --ours $@ && git add $@; }; f";

    # merge and use theirs
    theirs = "!f() { git checkout --theirs $@ && git add $@; }; f";




    ##########
    # Find
    ##########
    find = "!f() { git rev-list --all | xargs git grep $1; }; f";

    # Find branches containing commit
    fb = "!f() { git branch -a --contains $1; }; f"

    # Find tags containing commit
    ft = "!f() { git describe --always --contains $1; }; f"

    # Find commits by source code
    fc = "!f() { git log --pretty=format:'%C(yellow)%h  %Cblue%ad  %Creset%s%Cgreen  [%cn] %Cred%d' --decorate --date=short -S$1; }; f"

    # Find commits by commit message
    fm = "!f() { git log --pretty=format:'%C(yellow)%h  %Cblue%ad  %Creset%s%Cgreen  [%cn] %Cred%d' --decorate --date=short --grep=$1; }; f"

	#############
	subadd = !sh -c 'git submodule add git://github.com/$1 $2/$(basename $1)' -
	subrm = !sh -c 'git submodule deinit -f -- $1 && rm -rf .git/modules/$1 && git rm -f $1' -
	subup = submodule update --init --recursive
	subpull = !git submodule foreach git pull --tags -f origin master
	#############
	assume = update-index --assume-unchanged
	unassume = update-index --no-assume-unchanged
	assumed = !git ls -v | grep ^h | cut -c 3-
	unassumeall = !git assumed | xargs git unassume
	assumeall = !git status -s | awk {'print $2'} | xargs git assume
	#############
	bump = !sh -c 'git commit -am \"Version bump v$1\" && git psuoc && git release $1' -
	release = !sh -c 'git tag v$1 && git pst' -
	unrelease = !sh -c 'git tag -d v$1 && git pso :v$1' -
	merged = !sh -c 'git o master && git plom && git bd $1 && git rpo' -
	aliases = !git config -l | grep alias | cut -c 7-
	snap = !git stash save 'snapshot: $(date)' && git stash apply 'stash@{0}'
	bare = !sh -c 'git symbolic-ref HEAD refs/heads/$1 && git rm --cached -r . && git clean -xfd' -
	whois = !sh -c 'git log -i -1 --author=\"$1\" --pretty=\"format:%an <%ae>\"' -
	serve = daemon --reuseaddr --verbose --base-path=. --export-all ./.git
	#############
	behind = !git rev-list --left-only --count $(git bu)...HEAD
	ahead = !git rev-list --right-only --count $(git bu)...HEAD
	#############
	ours = "!f() { git checkout --ours $@ && git add $@; }; f"
	theirs = "!f() { git checkout --theirs $@ && git add $@; }; f"
	subrepo = !sh -c 'git filter-branch --prune-empty --subdirectory-filter $1 master' -
	human = name-rev --name-only --refs=refs/heads/*
    #===========================================
    # I really dont recommend powerful commands with  one letter only
    #===========================================
    #  a = add .;
# https://github.com/tokuhirom/git-xlsx-textconv
# https://github.com/t-yuki/gooxml
## Show all changed files between two Git commits ##
ChangesBetween = "!f() {  git diff --name-status ${1} ${2} ; }; f"
## Find largest files in repo ##

#Saves results to text file bigtosmall.txt (From http://naleid.com/blog/2012/01/17/finding-and-purging-big-files-from-git-history)
LargestFileInRepo = "!f() {\ngit rev-list --objects --all | sort -k 2 > allfileshas.txt\n\ngit gc && git verify-pack -v .git/objects/pack/pack-*.idx | egrep \"^\\w+ blob\\W+[0-9]+ [0-9]+ [0-9]+$\" | sort -k 3 -n -r > bigobjects.txt\n\nfor SHA in `cut -f 1 -d\\  < bigobjects.txt`; do\necho $(grep $SHA bigobjects.txt) $(grep $SHA allfileshas.txt) | awk \"{print $1,$3,$7}\" >> bigtosmall.txt\n\ndone;}; f"
grep-blame = "! : git grep ; perl -e ' my $truncate = 500; my ($git_maj, $git_min) = `git --version` =~ /version (\\d+)\\.(\\d+)/; my $git_grep_supports_column = $git_maj == 2 && $git_min >= 19 || $git_maj > 2; my $full_name = (`git config --get --bool grep.fullName` eq \"true\\n\" && $? == 0); my (@args, @invalid_args); my $last_arg_was_e = 0; my $index = -1; foreach my $arg (@ARGV) { $index++; if ($last_arg_was_e) { push @args, \"-e\", $arg; $last_arg_was_e = 0; next; } if ($arg eq \"-e\") { push @args, $arg if $index == $#ARGV; $last_arg_was_e = 1; next; } if ($arg eq \"--\") { push @args, @ARGV[$index .. $#ARGV]; last; } if ($arg =~ /^-O|^--open-files-in-pager(?:=|$)/ || $arg =~ /^(?:--no-null|--no-line-number|-h|--column|-c|--count|--heading| -l|--files-with-matches|--name-only|-L|--files-without-match)$/x) { push @invalid_args, $arg; next; } $full_name = 1 if ($arg eq \"--full-name\"); $full_name = 0 if ($arg eq \"--no-full-name\"); push @args, $arg; } print STDERR \"Warning: Ignored invalid grep-blame flags: @invalid_args\\n\" if (@invalid_args);  my $color_flag = -t STDOUT ? \"--color\" : \"--no-color\"; unshift @args, \"--no-column\" if $git_grep_supports_column;  chdir $ENV{\"GIT_PREFIX\"} if $ENV{\"GIT_PREFIX\"}; open grep_fh, \"-|\", \"git\", \"grep\", \"--line-number\", \"--null\", $color_flag, @args; chdir $ENV{\"PWD\"} if $full_name;  my $last_file; my @lines = (); my @texts = (); while (<grep_fh>) { if (/^Binary file .* matches$/) { print; next; } my ($file, $line, $text, $context_separator) = /^(.*?)\\0(.*?)\\0(.*)$|^((?:\\e\\[[^m]*m)?--(?:\\e\\[[^m]*m)?)$/; if (defined($context_separator)) { do_blame() if (@lines); @lines = (); @texts = (); print $context_separator, \"\\n\"; next; } if ($file eq \"\") { print; next; } if (defined($last_file) && $file ne $last_file) { do_blame() if (@lines); @lines = (); @texts = (); } $last_file = $file; push @lines, $line; push @texts, $text; } do_blame() if (@lines); close grep_fh; exit $? >> 8; sub do_blame { open blame_fh, \"-|\", \"git\", \"--no-pager\", \"blame\", (map {\"-L$_,$_\"} @lines), \"--\", $last_file; while (<blame_fh>) { /^([^\\)]*\\))/; shift @lines; my $text = shift @texts; my $out = \"$1 $last_file $text\"; (my $blank_out = $out) =~ s/\\e\\[[^m]*m//g; if (length $blank_out > $truncate) { $out =~ s/^((?:(?:\\e\\[[^m]*m)+(?:.|$)|.(?:\\e\\[[^m]*m)*|$(*SKIP)(*FAIL)){$truncate})(?=(?:(?:\\e\\[[^m]*m)+(?:.|$)|.(?:\\e\\[[^m]*m)*|$(*SKIP)(*FAIL)){15}).*/$1\\e\\[m...(truncated)/ } print \"$out\\n\"; } close blame_fh; } ' -- "