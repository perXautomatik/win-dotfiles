#!/usr/bin/env -S pwsh -NoProfile.
# Get the previous and new HEAD refs and the checkout type
$prevHEAD = $args[0]
$newHEAD = $args[1]
$checkoutType = $args[2]

# Check if this is a branch checkout
if ($checkoutType -eq "1") {
  # Get the name of the current branch
  $branchName = git symbolic-ref --short -q HEAD

  # Insert the branch name into the .gitsubmodule file
  Add-Content -Path .gitsubmodule -Value "branch = $branchName"
}

# Get the current branch name
$branch = git rev-parse --abbrev-ref HEAD
# Get the current repository path
$repo = git rev-parse --show-toplevel
# Check if there is a parent repository above the current one
$parent = git rev-parse --show-superproject-working-tree
# If there is a parent repository, update its .gitmodules file with the current branch name
if ($parent) {
  # Get the relative path of the submodule from the parent repository
  $subpath = $repo.Replace("$parent/", "")
  # Get the name of the submodule from the .gitmodules file
  $subname = (git config --file "$parent/.gitmodules" --get-regexp "^submodule\..*\.path$" | Select-String -Pattern $subpath).Line.Split()[0].Replace("submodule.", "").Replace(".path", "")
  # Update the branch entry for the submodule in the .gitmodules file
  git config --file "$parent/.gitmodules" "submodule.$subname.branch" "$branch"
  # Stage the .gitmodules file for commit in the parent repository
  git -C "$parent" add .gitmodules
}
