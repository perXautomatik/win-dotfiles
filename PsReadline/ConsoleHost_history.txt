
reboot
shutdown /r
E:
ls

putty
Start-Process putty -ArgumentList 'Saved Session Name', 'Tower'
Start-Process putty -ArgumentList 'Saved Session Name', '-name' 'Tower'
Start-Process putty -ArgumentList 'Saved Session Name', '-name', 'Tower'
Start-Process putty -ArgumentList '-name', 'Tower'
Start-Process putty -ArgumentList 'Tower'
[string]$scpPath = Find-PathToPuttyScpExecutable;
[string]$scpPath = Find-PathToPuttyExecutable;
[string]$scpPath = Find-PathTo;
Start-Process plink -ArgumentList 'Tower'
Start-Process plink -pw "p@ssword123" root@192.168.92.128 "df -h"
Start-Process plink -ArgumentList '-pw "p@ssword123" root@192.168.92.128 "df -h"'
Start-Process plink -ArgumentList '-pw "4832" root@tower "df -h"'
ls


ls E:
cd E:
ls
cd \
ls
cd .\LinksToNas\


set-alias bcompare 'E:\LinksToNas\BCompare.exe'
set-alias nas \\192.168.0.30\
bcompare nas
set-alias nas '\\192.168.0.30\'
bcompare nas
set-alias nas '\\192.168.0.30\WindoowsShare'
bcompare nas
bcompare '\\192.168.0.30\WindoowsShare'
everything
E:
ls
cd .\LinksToNas\
ls

version
get-version
get-vers
$PSVersionTable

git branch -r
git fetch remote master
git branch
git fetch origin

Git
git help -a

ls

cd ..
cd c:\user\crbk01\desktop\
cd 'c:\user\crbk01\desktop\'
cd ..
cd desktop

Start-Process powershell -Verb runAs
mklink /D H:\Users\crbk01\.DataGrip2019.1 C:\Users\crbk01\.DataGrip2019.1
Start-Process powershell -Verb runAs
c:\Users\crbk01\Desktop\WhenOffline\AventyrLivsmedel\uml pseudocode.plantexuml
"C:\\Users\\crbk01\\Desktop\\WhenOffline\\BeondCompare4\\BComp.exe\" \"$REMOTE\" \"$LOCAL\" \"$BASE\" \"$MERGED\"
end sub
"C:\\Users\\crbk01\\Desktop\\WhenOffline\\BeondCompare4\\BComp.exe\" \"$REMOTE\" \"$LOCAL\" \"$BASE\" \"$MERGED\"
"C:\\Users\\crbk01\\Desktop\\WhenOffline\\BeondCompare4\\BComp.exe\" \"$LOCAL\" \"$REMOTE\" \"$BASE\" \"$MERGED\"
vivaldi "vivaldi://flags"
ls -la


ls C:\Users\crbk01\Desktop\Ny mapp (3)
C:
ls C:\Users\crbk01\Desktop\Ny mapp (3)
ls 'C:\Users\crbk01\Desktop\Ny mapp (3)'| name

cd c
c:

get-services
get-service
echo 'START`
' > vsclog.txt
echo 'Exporting...`
' >> vsclog.txt
code --list-extensions > vsc-extensions.txt
echo 'Successfully exported' >> vsclog.txt
echo '`
END' >> vsclog.txt
git rev-parse
git push
git remote add PDF-Bookmark-Split https://github.com/perXautomatik/PDF-Bookmark-Split.git
git push PDF-Bookmark-Split
git push --set-upstream PDF-Bookmark-Split master
git branch --set-upstream-to=default
git branch --set-upstream-to=main
git branch --set-upstream-to=new
git push PDF-Bookmark-Split
git push --set-upstream PDF-Bookmark-Split master
git pull PDF-Bookmark-Split master new
git help
git status
git restore --staged scripts

                                                                                                                                    

New-Item -Path "C:\Users\crbk01\OneDrive - Region Gotland\WindowsPowerShell\PSReadline" -ItemType SymbolicLink -Value "C:\Users\crbk01\AppData\Roaming\Mic...
New-Item -Path "C:\Users\crbk01\OneDrive - Region Gotland\WindowsPowerShell\PSReadline" -ItemType Hardlink -Value "C:\Users\crbk01\AppData\Roaming\Microso...
New-Item -Path "C:\Users\crbk01\OneDrive - Region Gotland\WindowsPowerShell\PSReadline" -ItemType Junction -Value "C:\Users\crbk01\AppData\Roaming\Microso...



cd "C:\Program Files\TortoiseGit\bin"                                                                                                                        
ls                                                                                                                                                           
.\TortoiseGitProc.exe                                                                                                                                        
cd "C:\Users\crbk01\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadLine\"                                                                                                                                                                              
&"TortoiseGitProc"                                                                                                      
&"TortoiseGitProc" /command:repostatus                                                                                  
&"TortoiseGitProc" /command:repostatus /path:"C:\Users\crbk01\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadLine"  
&"TortoiseGitProc" /command:repostatus /path:"C:\Users\crbk01\OneDrive - Region Gotland\WindowsPowerShell"              
cd "C:\Users\crbk01\OneDrive - Region Gotland\WindowsPowerShell"                                                                                             
&"TortoiseGitProc"                                                                                                      
&"TortoiseGitProc" /path            

git restore --staged Scripts
git status
git remote add "D:\Documents\WindowsPowerShell"
git remote add PowerShellCmdHist "D:\Documents\WindowsPowerShell"
git fetch PowerShellCmdHist beforePurge:beforePurge
git diff beforePurge
git fetch PowerShellCmdHist refs/heads/bucketsNpiechart

get-content .\gitConfigsToAddAsSubmodules.txt | %{ $_.parent } | console-out
get-content .\gitConfigsToAddAsSubmodules.txt | %{ $_.parent } | $_
get-content .\gitConfigsToAddAsSubmodules.txt | %{ $_ | Split-Path -Path $MyInvocation.MyCommand.Definition -Parent}
get-content .\gitConfigsToAddAsSubmodules.txt | %{ Split-Path -Path $_ -Parent} | %{ Split-Path -Path $_ -Parent} | unique | git submodule add
get-content .\gitConfigsToAddAsSubmodules.txt | %{ Split-Path -Path $_ -Parent} | %{ Split-Path -Path $_ -Parent} | unique | %{ git submodule add $_ }
get-content .\gitConfigsToAddAsSubmodules.txt | %{ Split-Path -Path $_ -Parent} | %{ Split-Path -Path $_ -Parent} | unique | %{ git submodule add $_ -f }

& "C:\Users\crbk01\Desktop\OnGithub\addSubmodules.ps1"

git --bare
git init
ls | %{ $_ | git init }
ls | %{ cd $_ | git init }
ls | %{ git $_ init }
ls | %{ git init $_ }
ls | filter -name 'PortableApps.com' | %{ git init $_ }
ls | Where-Object { $_.Name -notin 'PortableApps.com' }  | %{ git init $_ }
git

Remove-Item -Path .\Code\ -Force -Recurse ; kill vscode; Stop-Process -Name vscode
Remove-Item -Path .\Code\ -Force -Recurse ; Stop-Process -Name code
Remove-Item -Path .\Code\ -Force -Recurse ; Stop-Process -Name code
Remove-Item -Path .\Code\ -Force -Recurse ; takeown /F "C:\windows.old" /A /R /D Y

toutch newfile
touch newfile
'touch' > newfile

git init
remot add origin https://gist.github.com/2a77d2bb2d57576de925d1d3ac8de62a
remote add origin https://gist.github.com/2a77d2bb2d57576de925d1d3ac8de62a
git remote add origin https://gist.github.com/2a77d2bb2d57576de925d1d3ac8de62a
git fetch
git branch master origin/master
git checkout master
git add -A
git commit -m 'first commit'
git push
ls


Import-Module pscx                                                                                                                                           
Import-Module -name pscx                                                                                                                                     

Set-ExecutionPolicy -ExecutionPolicy RemoteSigned


git
Git add
Git help -g
Git help -a
Git add "Local/ChemTable Software/Autorun Organizer/AdditionalStartupItemsData.xml" -f ;Git add "Local/ChemTable Software/Shared/StartupItems/AgesEx.bin" -f ;Git add "Local/ChemTable Software/Shared/StartupItems/LastProductModifiedStartup.txt" -f ;Git add "Local/ChemTable Software/Shared/StartupItems/TDriversFactory.xml" -f ;Git add "Local/ChemTable Software/Shared/StartupItems/TRegistryRunFactory.xml" -f ;Git add "Local/ChemTable Software/Shared/StartupTimes.xml" -f ;Git add "Local/Copy Handler/Tasks/engine.log" -f ;Git add "Local/Copy Handler/Tasks/tasks.sqlite" -f ;Git add "Local/Copy Handler/ch.log" -f ;Git add "Local/Copy Handler/ch.xml" -f ;Git add "Local/Fallout3/Plugins.fo3viewsettings" -f ;Git add "Local/Fallout3/loadorder.txt" -f ;Git add "Local/Fallout3/plugins.txt" -f ;Git add "Local/Fallout4/DLCList.txt" -f ;Git add "Local/Fallout4/Plugins.fo4viewsettings" -f ;Git add "Local/Fallout4/loadorder.txt" -f ;Git add "Local/Fallout4/plugins.txt" -f ;Git add "Local/Fallout4/plugins.txt.bak" -f ;Git add "Local/FalloutNV/NVDLCList.txt" -f ;Git add "Local/FalloutNV/loadorder.txt" -f ;Git add "Local/FalloutNV/plugins.txt" -f ;Git add "Local/Microsoft_Corporation/PowerShell_ISE.exe_StrongName_lw2v2vm3wmtzzpebq33gybmeoxukb04w/3.0.0.0/user.config" -f ;Git remote add EverythingOnline "https://github.com/perXautomatik/EverythingSettings.git"
Git remote add bat-files "https://github.com/perXautomatik/bat-files.git"



Gsubtree --prefix=PSReadline -b CmdHist ; git push D:\AppData\Roaming\Microsoft\Windows\PowerShell CmdHist ; $git = Git; .$Gsubtree --prefix=PSReadline -b CmdHist ; .$git push D:\AppData\Roaming\Microsoft\Windows\PowerShell CmdHist
$git = Git; .$Gsubtree --prefix=PSReadline -b CmdHist2
$git = Git; .$git "subtree split --prefix=PSReadline -b CmdHist"
$git = Git; .$git -arguments "subtree split --prefix=PSReadline -b CmdHist"
$git = Git; .$git -subtree split --prefix=PSReadline -b CmdHist
Set-Alias -Name git -Value Git
Gsubtree --prefix=PSReadline -b CmdHist ; git push D:\AppData\Roaming\Microsoft\Windows\PowerShell CmdHist ; Set-Alias -Name git -Value powershell -ExecutionPolicy Unrestricted -Command "& 'D:\PortableApplauncher\Apps\.free\GitHubDesktopPortable\App\GitHubDesktop\app-2.9.5\resources\app\git\cmd\git.exe'"
Set-Alias -Name git -Value "& 'D:\PortableApplauncher\Apps\.free\GitHubDesktopPortable\App\GitHubDesktop\app-2.9.5\resources\app\git\cmd\git.exe'"
Gsubtree --prefix=PSReadline -b CmdHist ; git push D:\AppData\Roaming\Microsoft\Windows\PowerShell CmdHist ; Set-Alias -Name git -Value ".'D:\PortableApplauncher\Apps\.free\GitHubDesktopPortable\App\GitHubDesktop\app-2.9.5\resources\app\git\cmd\git.exe'"
Gsubtree --prefix=PSReadline -b CmdHist ; git push D:\AppData\Roaming\Microsoft\Windows\PowerShell CmdHist ; Set-Alias -Name git -Value ".\'D:\PortableApplauncher\Apps\.free\GitHubDesktopPortable\App\GitHubDesktop\app-2.9.5\resources\app\git\cmd\git.exe'"
Gsubtree --prefix=PSReadline -b CmdHist ; git push D:\AppData\Roaming\Microsoft\Windows\PowerShell CmdHist ; Set-Alias -Name git -Value Git
Gsubtree --prefix=PSReadline -b CmdHist ; git push D:\AppData\Roaming\Microsoft\Windows\PowerShell CmdHist ; cd D:\ToGit\Forks\ScoopBucket
.\install.ps1
Gsubtree --prefix=PSReadline -b CmdHist ; git push D:\AppData\Roaming\Microsoft\Windows\PowerShell CmdHist ; Gsubtree --prefix=PSReadline
Gsubtree --prefix=TextTransformation -b TextTransformation ; git push C:\Users\dator\AppData\Roaming\Microsoft\Windows\PowerShell\TextTransformation TextTransformation 
Gsubtree --prefix=PSReadline -b CmdHist ; git push D:\AppData\Roaming\Microsoft\Windows\PowerShell CmdHist ; cd C:\Users\dator\AppData\Roaming\Microsoft\Windows\PowerShell
Gsubtree --prefix=PSReadline -b CmdHist ; git push D:\AppData\Roaming\Microsoft\Windows\PowerShell CmdHist ; git push D:\ToGit\Forks\New folder
git push "D:\ToGit\Forks\New folder"
Gsubtree --prefix=PSReadline -b CmdHist ; git push D:\AppData\Roaming\Microsoft\Windows\PowerShell CmdHist ; git push "D:\ToGit\Forks\New folder"
Gsubtree --prefix=PSReadline -b CmdHist ; git push D:\AppData\Roaming\Microsoft\Windows\PowerShell CmdHist ; git clone --sparse livewindows


git remote add pipe-objects-into-arrays 'C:\Users\crbk01\Desktop\Ny mapp'
gh repo clone perXautomatik/AutoHotkeyPortable-1
git gh repo clone perXautomatik/AutoHotkeyPortable-1
git clone perXautomatik/AutoHotkeyPortable-1
git clone https://github.com/perXautomatik/AutoHotkeyPortable-1.git
git remote add https://github.com/perXautomatik/AutoHotkeyPortable.git
git remote add Profile https://github.com/perXautomatik/AutoHotkeyPortable.git
git remote add TempScripts https://github.com/perXautomatik/AHKtempScripts.git
git pull tempScript master
git remotes
git remote
git pull TempScripts master -f
git pull -f TempScripts master
git commit

.\InitializeUserProfile.ps1
executeCommand
workbench.action.terminal.clear
$path
echo $path
code --version
echo 'I am ${env.USERNAME}.'
echo  ${env.USERNAME}.
echo  ${env.USERNAME}
echo  workbench.action.gotoSymbol
workbench.action.gotoSymbol
workbench.action.showWelcomePage
${command:markdownlint.fixAll}
code ${command:markdownlint.fixAll}
echo ${workspaceFolder}

git remotes
git remote add Gist2013 https://gist.github.com/0839153e8ee632b2b4463192038207f5
ls | select-object -property name
git add remote https://gist.github.com/perXautomatik/fbb1d3288dee53acb758d4f608f93873.js goal
git remote add https://gist.github.com/perXautomatik/fbb1d3288dee53acb758d4f608f93873.js goal
git remote add goal https://gist.github.com/perXautomatik/fbb1d3288dee53acb758d4f608f93873.js
Get-Content .\Todo.xml


'D:\PortableApps\4, windows enhance\PortableApps\AutoHotkeyPortable\Data\AutoHotkey.ahk'

ls 'G:\sbf\Livsmiljö\Miljö- och hälsoskydd\Vatten\Avlopp\Klart Vatten\Information och utskick\Utskick till fastighetsägare\Uppföljning\2021\'
ls 'G:\sbf\Livsmiljö\Miljö- och hälsoskydd\Vatten\Avlopp\Klart Vatten\Information och utskick\Utskick till fastighetsägare\Uppföljning\2021\PdferAttArkivera\' | select -property name, LastWriteTime | ConvertTo-Csv > uppfoljning2021.csv
ls 'G:\sbf\Livsmiljö\Miljö- och hälsoskydd\Vatten\Avlopp\Klart Vatten\Information och utskick\Utskick till fastighetsägare\Uppföljning\2021\PdferAttArkivera\' | select -property name, LastWriteTime | ConvertTo-Csv > C:\Users\crbk01\Desktop\Todo-filer\uppfoljning2021.csv
ls 'G:\sbf\Livsmiljö\Miljö- och hälsoskydd\Vatten\Avlopp\Klart Vatten\E-meddelande\Påminnelse-36-mån-2021' 
ls 'G:\sbf\Livsmiljö\Miljö- och hälsoskydd\Vatten\Avlopp\Klart Vatten\E-meddelande\Påminnelse-36-mån-2021\filer' | select -property name, LastWriteTime | ConvertTo-Csv > C:\Users\crbk01\Desktop\Todo-filer\EmeddelandePåminnelse36mån2021.csv
ls 'G:\sbf\Livsmiljö\Miljö- och hälsoskydd\Vatten\Avlopp\Klart Vatten\E-meddelande\Påminnelse-12-mån-2020\Utskick'  | select -property name, LastWriteTime | ConvertTo-Csv > C:\Users\crbk01\Desktop\Todo-filer\paminnelse12man2020.csv
/. 'G:\sbf\Livsmiljö\Miljö- och hälsoskydd\Vatten\Avlopp\Klart Vatten\E-meddelande\Påminnelse-12-mån-2020\Utskick'  
 'G:\sbf\Livsmiljö\Miljö- och hälsoskydd\Vatten\Avlopp\Klart Vatten\E-meddelande\Påminnelse-12-mån-2020\Utskick'  
explorer 'G:\sbf\Livsmiljö\Miljö- och hälsoskydd\Vatten\Avlopp\Klart Vatten\E-meddelande\Påminnelse-12-mån-2020\Utskick'  
explorer 'G:\sbf\Livsmiljö\Miljö- och hälsoskydd\Vatten\Avlopp\Klart Vatten\E-meddelande\Påminnelse-36-mån-2021\filer'
explorer 'G:\sbf\Livsmiljö\Miljö- och hälsoskydd\Vatten\Avlopp\Klart Vatten\Information och utskick\Utskick till fastighetsägare\Uppföljning\2021\'

datagrip.bat
./"D:\Program Files\JetBrains\DataGrip 2021.1\bin\datagrip64.exe" ;D:
./"D:\Program Files\JetBrains\DataGrip 2021.1\bin\datagrip64.exe"
cd "D:\Program Files\JetBrains\DataGrip 2021.1\bin"
.\datagrip64.exe
notepad datagrip.bat
datagrip.bat

C:
cd c:\user\crbk01\appdata
cd C:
cd ..
cd .\users\crbk01\AppData\
git add remote home "https://github.com/perXautomatik/AppData.git"
git remote add home "https://github.com/perXautomatik/AppData.git"
git add .gitignore
git commit "initial"
git commit 
cd ..
d:
cd .. appdata
cd .\Users\crbk01\AppData\
git repack -a -d -f --depth=250 --window=250
git --assume-unchanged
git update-index --assume-unchanged
notepad .\.git\config
 man git-config
git update-index --ignore-missing
git repack -a -d -f --depth=250 --window=250
rm .\.git\ -force
D: ; "D:\Project Shelf\PowerShellProjectFolder\Scripts"
D: ; cd "D:\Project Shelf\PowerShellProjectFolder\Scripts"
cd .\Excel\
notepad convert-xlsx-to-csv.ps1
. .\convert-xlsx-to-csv.ps1
ls D:\unsorted\Dump\
cd D:\unsorted\

ExcelToCsv -File .\fannyUtskick.xlsx
ls
ExcelToCsv -File "fannyUtskick.xlsx"
ExcelToCsv -File "D:\unsorted\fannyUtskick.xlsx"
ls

git rm --cached -r ...
git rm --cached -r app
git rm --cached -r \app\.*
git rm --cached -r /app/.*
git rm --help
git rm --cached -r "D:\PortableApps\PortableApps.com\Assets"
git rm --cached -r "D:\PortableApps\PortableApps.com\App"
git submodule list
git submodule foreach



Gsubtree --prefix=Data -b split
git push C:\Users\crbk01\Desktop\lib-repo split:master
remote add AhkTempScripts https://github.com/perXautomatik/AHKtempScripts.git
git remote add AhkTempScripts https://github.com/perXautomatik/AHKtempScripts.git
git remote
git rm -r Data
git remote add AhkTempScripts https://github.com/perXautomatik/AHKtempScripts.git
git rm -r Data/Fork/CheckifProgIsRunning
git rm -r -force
git rm -r --force
git rm -r -f
git rm -rf data ; git add -A ; git commit -am "removing data folder" ; git subtree add --prefix=data split master
git rm -rf data ; git add -A ; git commit -am "removing data folder" ; git subtree add --prefix=data split master
git remote
git subtree add --prefix=data TempScripts master
git rm -rf data ; git subtree add --prefix=data TempScripts split
git add -A ; git commit -am "removing data folder" ; git subtree add --prefix=data TempScripts split
Gsubtree --prefix=consoles -b BestStructure
git remote add https://github.com/perXautomatik/VisionH-ndelserToEasyRead ProjectsNConsoles
git remote add ProjectsNConsoles https://github.com/perXautomatik/VisionH-ndelserToEasyRead
Gsubtree --prefix=scratches -b WorkScratch
git remote add Scratches https://github.com/perXautomatik/sql-getIndexes.git
git push C:\Users\crbk01\Desktop\lib-repo WorkScratch:master
git push C:\Users\crbk01\Desktop\lib-repo WorkScratch
git push C:\Users\crbk01\Desktop\lib-repo BestStructure
git pull C:\Users\crbk01\Desktop\lib-repo BestStructure
git remote add C:\Users\crbk01\Desktop\lib-repo DatagripUserSettings
git remote add DatagripUserSettings C:\Users\crbk01\Desktop\lib-repo 
get-content .\fillistToadd | %{ git add $_} ; git commit -am "further"
get-content .\fillistToadd | %{ git add $_} ; git commit -am "further"
get-content .\fillistToadd | %{ git add $_} ; git commit -am "further"
git remote add DatagripUserSettings C:\Users\crbk01\Desktop\lib-repo 
 git add .idea/workspace.xml -f ; git commit -am "further"
git remote add DatagripProjects https://github.com/perXautomatik/sql-Blad1ObjektVsRegisterObjekt.git
Gsubtree --prefix=projects -b WorkProjekts
git push C:\Users\crbk01\Desktop\lib-repo WorkProjekts
git remote add DatagripUserSettings C:\Users\crbk01\Desktop\lib-repo 
get-content .\fillistToadd | %{ git add $_}; git commit -am "bout to merge with usersettings"
get-content .\fillistToadd | %{ git add $_ -f}; git commit -am "bout to merge with usersettings"
Gsubtree --prefix=ListAggregation\BookmarkFile.sqlite -b ToLargeToPush2
Gsubtree --prefix=ListAggregation -b ToLargeToPush3
git rm --cached --ignore-unmatch `git ls-files -i --exclude-standard`
git rm --cached --ignore-unmatch ;git ls-files -i --exclude-standard`
git rm --cached --ignore-unmatch ;git ls-files -i --exclude-standard
git remote add All https://github.com/perXautomatik/BeondCompare4.git
git remote 
git fetch All
git add .\Helpers\ -r
git add .\Helpers\ -n
git add .\Helpers\ -fn
git add .\Helpers\ -f
git add .\packers\ -f
Gsubtree --prefix=ListAggregation\sqlite -b SqliteUrlNWord
Gsubtree --prefix=ListAggregation/sqlite -b SqliteUrlNWords
git push D:\Users\crbk01\AppData\Roaming\JetBrains\DataGrip2021.1\scratches SqliteUrlNWords
Gsubtree --prefix=ListAggregation/sqlite -b SqliteUrlNWordsz
git push D:\Users\crbk01\AppData\Roaming\JetBrains\DataGrip2021.1\scratches SqliteUrlNWordsz
git push D:\Users\crbk01\AppData\Roaming\JetBrains\DataGrip2021.1\projects\ modularAttempt
get-content .\filelist | %{git rm --cached $_}
Gsubtree --prefix=consoles -b SqliteUrlNWord ; git push D:\Users\crbk01\AppData\Roaming\JetBrains\DataGrip2021.1\projects 2019.3con
Gsubtree --prefix=consoles -b 2019_3con ; git push D:\Users\crbk01\AppData\Roaming\JetBrains\DataGrip2021.1\projects 2019_3con
git push D:\Users\crbk01\AppData\Roaming\JetBrains\DataGrip2021.1\projects 2019_3con-f
git push D:\Users\crbk01\AppData\Roaming\JetBrains\DataGrip2021.1\projects 2019_3con -f
Gsubtree --prefix=consoles -b 2019_3con ; git push D:\Users\crbk01\AppData\Roaming\JetBrains\DataGrip2021.1\consoles 2019_3con
Gsubtree --prefix=projects -b 2019_3proj ; git push D:\Users\crbk01\AppData\Roaming\JetBrains\DataGrip2021.1\projects 2019_3proj
git add .\Helpers\ -fn
Gsubtree --prefix='Beyond Compare 4' -b oldFolder
.\jq64.exe
get-content 'C:\Users\dator\AppData\Local\Microsoft\Edge\User Data\Profile 2\Bookmarks' | .\jq.exe '.'
cls
Gsubtree --prefix=data -b homeData ; git push 'C:\Users\dator\Desktop\New folder (3)' homeData
Gsubtree --prefix=data -b homeData ; git push 'C:\Users\dator\Desktop\New folder (3)\.git' homeData
Gsubtree --prefix=data -b homeData 
Gsubtree --prefix=data -b ModularData 
Gsubtree --prefix=data -b homeData ; git push 'C:\Users\dator\Desktop\New folder (3)\.git' homeData
git push 'C:\Users\dator\Desktop\New folder (3)\.git' split
git rm -rf data
git remote add split 'https://github.com/perXautomatik/AHKtempScripts.git'
Gsubtree --prefix=AutoHotkey.ahk -b StandardScript
Gsubtree AutoHotkey.ahk -b StandardScript
Gsubtree -P AutoHotkey.ahk -b StandardScript
Gsubtree -P \AutoHotkey.ahk -b StandardScript
Gsubtree -Prefix=\AutoHotkey.ahk -b StandardScript
Gsubtree -Prefix='AutoHotkey.ahk' -b StandardScript
Gsubtree -Prefix='\AutoHotkey.ahk' -b StandardScript
Gsubtree -Prefix='/AutoHotkey.ahk' -b StandardScript
Gsubtree -Prefix=AutoHotkey -b StandardScript
Gsubtree -P AutoHotkey -b StandardScript
git remote add 'https://github.com/perXautomatik/PowerShellCmdHist.git' cmdHistX
git remote add cmdHistX 'https://github.com/perXautomatik/PowerShellCmdHist.git'
Gsubtree --prefix=consoles -b home_2021con
Gsubtree --prefix=scratches -b home_2021scr;Gsubtree --prefix=projects -b home_2021proj
Gsubtree --prefix=consoles -b home_2021con;Gsubtree --prefix=scratches -b home_2021scr;Gsubtree --prefix=projects -b home_2021proj
Gsubtree --prefix=consoles -b -f home_2021con;Gsubtree --prefix=scratches -b -f home_2021scr;Gsubtree --prefix=projects -b -f home_2021proj
Gsubtree --prefix=consoles -bf home_2021con;Gsubtree --prefix=scratches -bf home_2021scr;Gsubtree --prefix=projects -bf home_2021proj
Gsubtree --prefix=consoles -b home_2021con2;Gsubtree --prefix=scratches -b home_2021scr2;Gsubtree --prefix=projects -b home_2021proj2
git push home_2021con 'D:\2\New folder (2)\consoles';git push home_2021scr 'D:\2\New folder (2)\scratches';git push home_2021proj 'D:\2\New folder (2)\projects'
git push home_2021con 'D:\2\New folder (2)\consoles\.git';git push home_2021scr 'D:\2\New folder (2)\scratches';git push home_2021proj 'D:\2\New folder (2)\projects'
git push 'D:\2\New folder (2)\consoles\' home_2021con ;git push 'D:\2\New folder (2)\scratches' home_2021scr ;git push 'D:\2\New folder (2)\projects' home_2021proj 
git push 'D:\2\New folder (2)\consoles' home_2021con ;git push 'D:\2\New folder (2)\scratches' home_2021scr ;git push 'D:\2\New folder (2)\projects' home_2021proj 
git remote add 'https://github.com/perXautomatik/sql-getIndexes.git' WorkScratch
git remote add WorkScratch 'https://github.com/perXautomatik/sql-getIndexes.git'
git remote add HomeScratch 'D:\2\New folder (2)\scratches'
git remote add WorkConsoles 'https://github.com/perXautomatik/VisionH-ndelserToEasyRead.git'
Gsubtree --prefix=Everything -b EverythingSettings

Resolve-Path -Relative (GitRoot)
split-path (GitRoot) -noqualifer | Resolve-Path -Relative 
split-path -path (GitRoot) -noqualifer | Resolve-Path -Relative 
split-path -path (GitRoot) -noQualifer | Resolve-Path -Relative 
split-path -path (GitRoot) -noQualifier | Resolve-Path -Relative 
split-path -path (GitRoot) -noQualifier | Resolve-Path ~ -Relative 
split-path -path (GitRoot) -noQualifier 

get-location
split-path -path get-location -noQualifier
RootNoDrive
Resolve-Path -path (split-path -path (GitRoot) -noQualifier)  -Relative (RootNoDrive)
Resolve-Path -path [io.path]::Combine((split-path -path (GitRoot) -noQualifier),(RootNoDrive))
[io.path]::Combine((split-path -path (GitRoot) -noQualifier),(RootNoDrive))
RootNoDrive

join-path -leaf (RootNoDrive) -parent 'C:'
join-path -child (RootNoDrive) -parent 'C:'
join-path -childpath (RootNoDrive) -path 'C:'
Resolve-Path -path (join-path -childpath (split-path -path (GitRoot) -noQualifier) -path 'C:'),(join-path -childpath (RootNoDrive) -path 'C:'))
Resolve-Path -path (join-path -childpath ((split-path -path (GitRoot) -noQualifier) -path 'C:'),(join-path -childpath (RootNoDrive) -path 'C:'))

cd ..
Gsubtree --prefix=db\8b7c273a-baa2-4933-a5d5-4862e23c0af2 -b AgarUpgifter
Gsubtree --prefix=db\8b7c273a-baa2-4933-a5d5-4862e23c0af2 -b AgarUpgifter
Gsubtree --prefix=db -b db
git push origin db

get-children
get-childitem -fullname
get-childitem | select fullname
filesInFol | %{Gsubtree --prefix=$_ -b $_}
filesInFol | %{Gsubtree --prefix=$_.toString() -b $_.toString()}
filesInFol | %{Gsubtree --prefix=($_.toString()) -b ($_.toString())}
filesInFol | tostring | %{Gsubtree --prefix=$_ -b $_}
filesInFol | out-string | %{Gsubtree --prefix=$_ -b $_}
filesInFol | %{$_ out-string} | %{Gsubtree --prefix=$_ -b $_}
filesInFol | %{$_ | out-string} | %{Gsubtree --prefix=$_ -b $_}
filesInFol | %{$_ | out-string}
filesInFol | out-string | %{Gsubtree --prefix=$_ -b $_}
filesInFol | %{ out-string | Gsubtree --prefix=$_ -b $_}
filesInFol | %{ $_ out-string | Gsubtree --prefix=$_ -b $_}
filesInFol | %{ $_ | out-string | Gsubtree --prefix=$_ -b $_}
get-childitem | select-object name * out-string | %{ Gsubtree --prefix=$_ -b $_}
get-childitem | select-object name out-string | %{ Gsubtree --prefix=$_ -b $_}
get-childitem | select-object -property name out-string | %{ Gsubtree --prefix=$_ -b $_}
get-childitem | select-object -property name * out-string | %{ Gsubtree --prefix=$_ -b $_}
filesInFolAsStream | %{ Gsubtree --prefix=$_ -b $_}
filesInFolAsStream | %{ git push origion $_ }
filesInFolAsStream | %{ git push origon $_ }
git remote
filesInFolAsStream | %{ git push origin $_ }
filesInFolAsStream | %{ git rm --cached $_ }
filesInFolAsStream | %{ git rm --cached $_ -r }
git commit 'toSubmodule'
git commit "toSubmodule"
git commit -m "toSubmodule"
filesInFolAsStream | %{ rm $_ ; git submodule add -b $_ -- "https://github.com/perXautomatik/VisionH-ndelserToEasyRead.git" "$_" }
filesInFolAsStream | %{ rm $_ ; git submodule add -b -f -r $_ -- "https://github.com/perXautomatik/VisionH-ndelserToEasyRead.git" "$_" }
filesInFolAsStream | %{ rm $_ -r ; git submodule add -b $_ -- "https://github.com/perXautomatik/VisionH-ndelserToEasyRead.git" "$_" }

BranchToStream | %{ git submodule add -b $_ -- "https://github.com/perXautomatik/VisionH-ndelserToEasyRead.git" "$_" }
BranchToStream | %{ git submodule add -b $_.trim() -- "https://github.com/perXautomatik/VisionH-ndelserToEasyRead.git" "$_.trim()" }
BranchToStream | %{ $x = $_.trim(); git submodule add -b ($x) -- "https://github.com/perXautomatik/VisionH-ndelserToEasyRead.git" "$x" }
filesInFolAsStream | %{ git push origin $_ }
get-childitem | out-string -stream | %{ $x = $_.trim(); git submodule add -b ($x) -- "https://github.com/perXautomatik/VisionH-ndelserToEasyRead.git" "$x" }
get-childitem | out-string -stream | %{ $x = $_.trim(); Gsubtree --prefix=$x -b $x}
filesInFolAsStream | %{ $x = $_.trim(); Gsubtree --prefix=$x -b $x}
(UDPE).localPort
(Get-NetUDPEndpoint -LocalAddress local ).localPort | %{[int]$_} | %{Get-Process -Id (Get-NetTCPConnection -LocalPort $_).OwningProcess}
(Get-NetUDPEndpoint -LocalAddress.).localPort | %{[int]$_} | %{Get-Process -Id (Get-NetTCPConnection -LocalPort $_).OwningProcess}
sc
sudo choco install 7zip
git filter-repo --analyze --force
git fetch 'C:\programdata\scoop\persist\' --all
git fetch 'C:\programdata\scoop\persist\' 
git fetch deployed 'C:\programdata\scoop\persist\' 
git fetch 'C:\programdata\scoop\persist\' deployed 
git remote add 'C:\programdata\scoop\persist\' deployed 
git remote add deployed 'C:\programdata\scoop\persist\' 
git fetch deployed 
git fetch -h
git fetch -k --auto-gc -a --recurse-submodules on-demand deployed
git fetch -k --auto-gc -a --recurse-submodules=on-demand deployed
git fetch --recurse-submodules=on-demand deployed
git merge -h
git merge ala -X theirs
git merge ala -X theirs --allow-unrelated-histories
Get-Clipboard | % { resolve-path $_ }
Get-Clipboard | % { resolve-path $_.trim() }
Get-Clipboard | % { resolve-path $_.trim() | rm }
git merge ala -X theirs --allow-unrelated-histories
Get-Clipboard | % { resolve-path $_.trim() | rm }
git merge ala -X theirs --allow-unrelated-histories
Get-Clipboard | % { resolve-path $_.trim() | rm }
git merge ala -X theirs --allow-unrelated-histories
$qz = 'B:\PF\PowershellProjectFolder\Modules\Personal' ; Get-Clipboard | % { $_.trim() } | % { (join-path -path $qz -child $_)} | % { cd (Convert-Path $_ | Split-Path -Parent) ; git status $_ }
get-history
# Declare output parameters
[string]$input = ""
[int]$cursor = 0
# Call GetBufferState with output parameters
[Microsoft.PowerShell.PSConsoleReadLine]::GetBufferState([ref]$input, [ref]$cursor)
# Display the buffer content and cursor position
Write-Host "The buffer content is: $input"
[Microsoft.PowerShell.PSConsoleReadLine]::GetBufferState([ref]$input, [ref]$cursor)
Write-Host "The buffer content is: $input"
PSConsoleReadLine.GetBufferStateAsText
[Microsoft.PowerShell.PSConsoleReadLine]::PSConsoleReadLine.GetBufferStateAsText
[Microsoft.PowerShell.PSConsoleReadLine]::PSConsoleReadLine.GetBufferStateAsText()
[Microsoft.PowerShell.PSConsoleReadLine]::PSConsoleReadLine.GetBufferStateAsText("")
[Microsoft.PowerShell.PSConsoleReadLine]::PSConsoleReadLine.GetBufferStateAsText([ref]$input, [ref]$cursor)
$input = [Microsoft.PowerShell.PSConsoleReadLine]::GetBufferStateAsText()
PreviousHistory
Get-PSReadLineOption
Save-PSReadLineHistory -Force
Install-Module PSReadLine -AllowPrerelease -Force
#Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Hyper-V -All
(get-historyPath | Split-Path -Parent) | explorer.exe
(get-historyPath | Split-Path -Parent) 
Set-PSReadLineOption -AddToHistoryHandler {`
  param($line)`
  # Get the current date, path, and computer name`
  $date = Get-Date -Format "yyyy-MM-dd HH:mm:ss"`
  $path = Get-Location`
  $computer = $env:COMPUTERNAME`
  # Write the output to the history file`
  Write-Output "#$date, $path, $computer" | Out-File -FilePath (Get-PSReadLineOption).HistorySavePath -Append`
  # Get the history file directory`
  $HistoryDir = Split-Path -Path (Get-PSReadLineOption).HistorySavePath`
  # Save the current location and change to the history file directory`
  Push-Location -Path $HistoryDir`
  # Invoke git commands to add and commit the history file`
  Invoke-Expression "git add ."`
  Invoke-Expression "git commit -m '#$date, $path, $computer'"`
  # Return to the original location`
  Pop-Location`
  # Return the original line`
  $line`
}
#2023-08-31 11:43:25, B:\PF\PowershellProjectFolder\Modules\Personal\xml\xml2Csv, DESKTOP-OPGKPPF
#2023-08-31 11:43:25, B:\PF\PowershellProjectFolder\Modules\Personal\xml\xml2Csv, DESKTOP-OPGKPPF
<<<<<<< HEAD
=======
Set-PSReadLineKeyHandler -Key Alt+E -Function EndOfHistory
#2023-08-31 11:43:47, B:\PF\PowershellProjectFolder\Modules\Personal\xml\xml2Csv, DESKTOP-OPGKPPF
#2023-08-31 11:43:47, B:\PF\PowershellProjectFolder\Modules\Personal\xml\xml2Csv, DESKTOP-OPGKPPF
Set-PSReadLineKeyHandler -Key Ctrl+Alt+E -Function EndOfHistory
#2023-08-31 11:45:36, B:\PF\PowershellProjectFolder\Modules\Personal\xml\xml2Csv, DESKTOP-OPGKPPF
#2023-08-31 11:45:36, B:\PF\PowershellProjectFolder\Modules\Personal\xml\xml2Csv, DESKTOP-OPGKPPF
Set-PSReadLineKeyHandler -Key Ctrl+ArrowKeyUp -Function EndOfHistory
#2023-08-31 11:46:08, B:\PF\PowershellProjectFolder\Modules\Personal\xml\xml2Csv, DESKTOP-OPGKPPF
#2023-08-31 11:46:08, B:\PF\PowershellProjectFolder\Modules\Personal\xml\xml2Csv, DESKTOP-OPGKPPF
system.consolekey
#2023-08-31 11:46:19, B:\PF\PowershellProjectFolder\Modules\Personal\xml\xml2Csv, DESKTOP-OPGKPPF
#2023-08-31 11:46:19, B:\PF\PowershellProjectFolder\Modules\Personal\xml\xml2Csv, DESKTOP-OPGKPPF
get-consolekey
#2023-08-31 11:47:29, B:\PF\PowershellProjectFolder\Modules\Personal\xml\xml2Csv, DESKTOP-OPGKPPF
#2023-08-31 11:47:30, B:\PF\PowershellProjectFolder\Modules\Personal\xml\xml2Csv, DESKTOP-OPGKPPF
Set-PSReadLineKeyHandler -Key Ctrl+UpArrow -Function EndOfHistory
#2023-08-31 11:47:46, B:\PF\PowershellProjectFolder\Modules\Personal\xml\xml2Csv, DESKTOP-OPGKPPF
#2023-08-31 11:47:46, B:\PF\PowershellProjectFolder\Modules\Personal\xml\xml2Csv, DESKTOP-OPGKPPF
Set-PSReadLineKeyHandler -Key Ctrl+UpArrow -Function StartOfHistory
#2023-08-31 11:51:48, B:\PF\PowershellProjectFolder\Modules\Personal\xml\xml2Csv, DESKTOP-OPGKPPF
#2023-08-31 11:51:48, B:\PF\PowershellProjectFolder\Modules\Personal\xml\xml2Csv, DESKTOP-OPGKPPF
Set-PSReadLineKeyHandler -Key Ctrl+UpArrow -Function ShowKeyBindings
#2023-08-31 11:52:06, B:\PF\PowershellProjectFolder\Modules\Personal\xml\xml2Csv, DESKTOP-OPGKPPF
#2023-08-31 11:52:06, B:\PF\PowershellProjectFolder\Modules\Personal\xml\xml2Csv, DESKTOP-OPGKPPF
Set-PSReadLineKeyHandler -Key Ctrl+UpArrow -Function ShowKeyBindings
#2023-08-31 12:01:20, B:\PF\PowershellProjectFolder\Modules\Personal\xml\xml2Csv, DESKTOP-OPGKPPF
#2023-08-31 12:01:20, B:\PF\PowershellProjectFolder\Modules\Personal\xml\xml2Csv, DESKTOP-OPGKPPF
Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Hyper-V -All
sudo scoop bucket perXautomatik update
sudo scoop bucket list
scoop bucket list
$name = 'PerXautomatik' ; scoop bucket list | ? { $_.Source -eq $name }
$name = 'PerXautomatik' ; scoop bucket list | ? { $_.Source -like $name }
$name = 'PerXautomatik' ; scoop bucket list | ? { $_.Name -like $name }
$name = 'PerXautomatik' ; (scoop bucket list | ? { $_.Name -like $name }).source
$name = 'PerXautomatik' ; $source = (scoop bucket list | ? { $_.Name -eq $name }).source ; scoop bucket rm $name ; scoop bucket add $name $source ; $source ; $name
sudo $name = 'PerXautomatik' ; $source = (scoop bucket list | ? { $_.Name -eq $name }).source ; scoop bucket rm $name ; scoop bucket add $name $source ; $source ; $name
scoop bucket list
sudo { $name = 'PerXautomatik' ; $source = (scoop bucket list | ? { $_.Name -eq $name }).source ; scoop bucket rm $name }
sudo scoop bucket rm PerXautomatik
scoop bucket list
sudo scoop bucket add PerXautomatik 'https://github.com/perXautomatik/scoopbucket-1'
sudo scoop bucket add 'https://github.com/perXautomatik/scoopbucket-1' PerXautomatik 
sudo scoop bucket add PerXautomatik 'https://github.com/perXautomatik/scoopbucket-1'
git filter-repo --path 'bucket' --invert-path --refs 'sb'
git filter-repo --force --path 'bucket' --invert-path --refs 'sb'
sudo scoop bucket add PerXautomatik 'https://github.com/perXautomatik/ScoopBucket-Presistent.git'
sudo scoop uninstall scoop ; iwr -useb get.scoop.sh
Set-Service -Name WSearch -StartupType Disabled ; Stop-Service -Name WSearch
sudo Set-Service -Name WSearch -StartupType Disabled ; sudo Stop-Service -Name WSearch
Get-ChildItem -Path B:\PF\Archive\ToGit\scoopbucket-presist\
'' >  B:\PF\Archive\ToGit\scoopbucket-presist\.git
'' >  B:\PF\Archive\ToGit\scoopbucket-presist\git
$home
$PROFILE
Get-ChildItem env:
Get-Item env:Path
Get-ItemProperty -Path 'Registry::HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileList\*' | Select-Object -Property PSChildName, ProfileImagePath
Get-ItemProperty -Path 'Registry::HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileList\*' | ForEach-Object {`
    $profilePath = $_.ProfileImagePath`
    $profileName = Split-Path -Leaf $profilePath`
    Write-Output "$profileName: $profilePath"`
}
Get-ItemProperty -Path 'Registry::HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileList\*' | ForEach-Object {`
    $profilePath = $_.ProfileImagePath`
    $profileName = Split-Path -Leaf $profilePath`
    Write-Output "$profileName : $profilePath"`
}
cd c:\Windows
takeown /f csc /r /a /d y > NUL
takeown /f csc /r /a /d y > $null
icacls csc /grant Administrators:(F) /t /l /q
icacls csc /grant:r Administrators:(F) /t /l /q
icacls csc /grant:r Administrators:(D) /t /l /q
icacls /t /l /q csc /grant:r Administrators:(D)
icacls /t /l /q csc /grant:r Administrators
icacls csc /grant:r Administrators:(F,GA) /t /l /q 
icacls csc /grant Administrators:(F,GA) /t /l /q 
icacls csc /grant Administrators:(GA) /t /l /q 
icacls csc /grant:r /t /l /q 
icacls csc /t /l /q 
icacls csc /grant:r Administrators:(F,GA) /t /l /q 
icacls csc /grant:r Administrators:(FGA) /t /l /q 
icacls /t /l /q csc /grant:r Administrators
del csc
Get-ChildItem -Recurse -Path csc | % { del $_ }
(get-historyPath | Split-Path -Parent) 
$PROFILE
(Get-ItemProperty -Path 'HKCU:\Software\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders' -Name Personal).Personal
Set-ItemProperty -Path 'HKCU:\Software\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders' -Name Personal -Value 'B:\PF\Archive\ToGit\scoopbucket-presist\Documents'
Get-VM -ComputerName Server1
Get-VM -ComputerName virtual1
Get-VM -ComputerName DESKTOP-OPGKPPF
(Get-VM -ComputerName DESKTOP-OPGKPPF) | %{$_.state}
(Get-VM -ComputerName DESKTOP-OPGKPPF) | %{$_ -h }
Get-VM -ComputerName DESKTOP-OPGKPPF
Get-VMIntegrationService -VMName TestVM -Name Shutdown
Get-VMIntegrationService -VMName virtual1 -Name Shutdown
$vm=virtual1 ; Get-VMSnapshot -VMName $vm | Where-Object {($_.ShutdownIntegrationService.PrimaryStatusDescription -ne (Get-VMIntegrationService -VMName $vm -Name Shutdown).PrimaryStatusDescription) -or ($_.ShutdownIntegrationService.SecondaryStatusDescription -ne (Get-VMIntegrationService -VMName $vm -Name Shutdown).SecondaryStatusDescription)}
$vm='virtual1' ; Get-VMSnapshot -VMName $vm | Where-Object {($_.ShutdownIntegrationService.PrimaryStatusDescription -ne (Get-VMIntegrationService -VMName $vm -Name Shutdown).PrimaryStatusDescription) -or ($_.ShutdownIntegrationService.SecondaryStatusDescription -ne (Get-VMIntegrationService -VMName $vm -Name Shutdown).SecondaryStatusDescription)}
Set-VMHost -EnableEnhancedSessionMode $true
Get-WinEvent -ProviderName Microsoft-Windows-Hyper-V-Hypervisor -MaxEvents 100
Get-WinEvent -ProviderName Microsoft-Windows-Hyper-V-Hypervisor -FilterHashtable @{Level=2} | Out-File C:\HypervisorErrors.txt
Get-WinEvent -ProviderName Microsoft-Windows-Hyper-V-Hypervisor -FilterHashtable @{Level=2}
Get-WinEvent -ProviderName Microsoft-Windows-Hyper-V-Hypervisor 
pwsh  "Get-WinEvent -ProviderName Microsoft-Windows-Hyper-V-Hypervisor -FilterHashtable @{Level=2}"
pwsh  -command "Get-WinEvent -ProviderName Microsoft-Windows-Hyper-V-Hypervisor -FilterHashtable @{Level=2}"
Get-WinEvent -ProviderName Microsoft-Windows-Hyper-V-Hypervisor -FilterHashtable @{Level=2}
Get-WinEvent -ProviderName Microsoft-Windows-Hyper-V-Hypervisor -FilterHashtable @{LogName='Application';ID=1001}`

Get-WinEvent -ProviderName Microsoft-Windows-Hyper-V-Hypervisor -FilterHashtable @{LogName='LevelDisplayName'}
Get-WinEvent -ProviderName Microsoft-Windows-Hyper-V-Hypervisor | ? { $_.LevelDisplayName ='error' } 
Get-WinEvent -ProviderName Microsoft-Windows-Hyper-V-Hypervisor | ? { $_.LevelDisplayName -eq 'error' } 
git remote
git remote add deployed 'C:\ProgramData\scoop\persist'
git remote fetch --all
git remote --all
git fetch --all
git filter-repo --force --path 'bucket' --invert-path
git filter-repo --analyze --forse
git filter-repo --analyze --force
scoop install 'B:\PF\scoopbucket-1\Todo\git-imerge.json'
git imerge
git-imerge
scoop list --shims
scoop list --shins
scoop list
scoop list -h
Get-ChildItem -Path 'C:\Users\User\scoop\\shims' | ForEach-Object ; $shim = $_.Name ; $program = (Get-Content -Path $_.FullName | Select-String -Pattern 'path=').Line -replace 'path=' ;  Write-Output "$shim -> $program"}
Get-ChildItem -Path %userfolder%\scoop\shims | ForEach-Object ; $shim = $_.Name ; $program = (Get-Content -Path $_.FullName | Select-String -Pattern 'path=').Line -replace 'path=' ;  Write-Output "$shim -> $program"}
Get-ChildItem -Path ($home + '\scoop\shims') | ForEach-Object ; $shim = $_.Name ; $program = (Get-Content -Path $_.FullName | Select-String -Pattern 'path=').Line -replace 'path=' ;  Write-Output "$shim -> $program"}
$home
scoop -h
scoop shim
scoop checkup
scoop config
(scoop config).root_path
(scoop config).root_path | Join-Path -ChildPath 'scoop\shims'
((scoop config).root_path | Join-Path -ChildPath 'scoop\shims') | ForEach-Object ; $shim = $_.Name ; $program = (Get-Content -Path $_.FullName | Select-String -Pattern 'path=').Line -replace 'path=' ;  Write-Output "$shim -> $program"}
Get-ChildItem ((scoop config).root_path | Join-Path -ChildPath 'scoop\shims') | ForEach-Object ; $shim = $_.Name ; $program = (Get-Content -Path $_.FullName | Select-String -Pattern 'path=').Line -replace 'path=' ;  Write-Output "$shim -> $program"}
Get-ChildItem -Path ((scoop config).root_path | Join-Path -ChildPath 'scoop\shims') | ForEach-Object ; $shim = $_.Name ; $program = (Get-Content -Path $_.FullName | Select-String -Pattern 'path=').Line -replace 'path=' ;  Write-Output "$shim -> $program"}
Get-ChildItem -Path ((scoop config).root_path | Join-Path -ChildPath 'scoop\shims') | ForEach-Object { $shim = $_.Name ; $program = (Get-Content -Path $_.FullName | Select-String -Pattern 'path=').Line -replace 'path=' ;  Write-Output "$shim -> $program"}
Get-ChildItem -Path ((scoop config).root_path | Join-Path -ChildPath 'scoop\shims') | ForEach-Object { $shim = $_.Name ; (Get-Content -Path $_.FullName | Select-String -Pattern 'path=')}
Get-ChildItem -Path ((scoop config).root_path | Join-Path -ChildPath '\shims') | ForEach-Object { $shim = $_.Name ; (Get-Content -Path $_.FullName | Select-String -Pattern 'path=')}
Get-ChildItem -Path ((scoop config).root_path | Join-Path -ChildPath '\shims') | ForEach-Object { $shim = $_.Name ; (Get-Content -Path $_.FullName)}
Get-ChildItem -Path ((scoop config).root_path | Join-Path -ChildPath '\shims')
Get-ChildItem -Path ((scoop config).root_path | Join-Path -ChildPath '\shims') -Filter .shim | ForEach-Object { $shim = $_.Name ; $program = (Get-Content -Path $_.FullName | Select-String -Pattern 'path=').Line -replace 'path=' ;  Write-Output "$shim -> $program"}
Get-ChildItem -Path ((scoop config).root_path | Join-Path -ChildPath '\shims') -Filter '.shim' | ForEach-Object { $shim = $_.Name ; $program = (Get-Content -Path $_.FullName | Select-String -Pattern 'path=').Line -replace 'path=' ;  Write-Output "$shim -> $program"}
Get-ChildItem -Path ((scoop config).root_path | Join-Path -ChildPath '\shims') -Filter '.shim'
Get-ChildItem -Path ((scoop config).root_path | Join-Path -ChildPath '\shims') -Filter '*.shim'
Get-ChildItem -Path ((scoop config).root_path | Join-Path -ChildPath '\shims') -Filter '*.shim' | ForEach-Object { $shim = $_.Name ; $program = (Get-Content -Path $_.FullName | Select-String -Pattern 'path=').Line -replace 'path=' ;  Write-Output "$shim -> $program"}
Get-ChildItem -Path ((scoop config).root_path | Join-Path -ChildPath '\shims') -Filter '*.shim' | ForEach-Object { $shim = $_.Name ; $q = Get-Content -Path $_.FullName ; $program = ($q | Select-String -Pattern 'path=').Line -replace 'path=' ;  Write-Output "$shim -> $program" ; $q }
Get-ChildItem -Path ((scoop config).root_path | Join-Path -ChildPath '\shims') -Filter '*.shim' | ForEach-Object { $shim = $_.Name ; $q = Get-Content -Path $_.FullName ; $program = ($q | Select-String -like 'path=').Line -replace 'path=' ;  Write-Output "$shim -> $program" ; $q }
Get-ChildItem -Path ((scoop config).root_path | Join-Path -ChildPath '\shims') -Filter '*.shim' | ForEach-Object { $shim = $_.Name ; $q = Get-Content -Path $_.FullName ; $program = ($q | ?{ $_ -like 'path='}).Line -replace 'path=' ;  Write-Output "$shim -> $program" ; $q }
Get-ChildItem -Path ((scoop config).root_path | Join-Path -ChildPath '\shims') -Filter '*.shim' | ForEach-Object { $shim = $_.Name ; $q = Get-Content -Path $_.FullName ; $program = ($q | ?{ $_ -like 'path ='}).Line -replace 'path=' ;  Write-Output "$shim -> $program" ; $q }
Get-ChildItem -Path ((scoop config).root_path | Join-Path -ChildPath '\shims') -Filter '*.shim' | ForEach-Object { $shim = $_.Name ; $q = Get-Content -Path $_.FullName ; $program = ($q | ?{ $_ -like 'path ='}).Line;  Write-Output "$shim -> $program" ; $q }
Get-ChildItem -Path ((scoop config).root_path | Join-Path -ChildPath '\shims') -Filter '*.shim' | ForEach-Object { $shim = $_.Name ; $q = Get-Content -Path $_.FullName ; $program = ($q | ?{ $_ -like 'path ='});  Write-Output "$shim -> $program" ; $q }
Get-ChildItem -Path ((scoop config).root_path | Join-Path -ChildPath '\shims') -Filter '*.shim' | ForEach-Object { $shim = $_.Name ; $q = Get-Content -Path $_.FullName ; $program = $q ;  Write-Output "$shim -> $program" }
Get-ChildItem -Path ((scoop config).root_path | Join-Path -ChildPath '\shims') -Filter '*.shim' | ForEach-Object { $shim = $_.Name ; $q = Get-Content -Path $_.FullName ; $program = ($q -split ' = ')[1] ;  Write-Output "$shim -> $program" }
Get-ChildItem -Path ((scoop config).root_path | Join-Path -ChildPath '\shims') -Filter '*.shim' | ForEach-Object { $shim = $_.Name ; $q = Get-Content -Path $_.FullName ; $program = ($q -split ' = ')[1] ;  Write-Output "$shim -> $program" } | select -Unique
Get-ChildItem -Path ((scoop config).root_path | Join-Path -ChildPath '\shims') -Filter '*.shim' | ForEach-Object { $shim = $_.Name ; $q = Get-Content -Path $_.FullName ; $program = ($q -split ' = ')[1] ;  [System.Management.Automation.PSCustomObject]{ shim = $shim ; program = $program} }
Get-ChildItem -Path ((scoop config).root_path | Join-Path -ChildPath '\shims') -Filter '*.shim' | ForEach-Object { $shim = $_.Name ; $q = Get-Content -Path $_.FullName ; $program = ($q -split ' = ')[1] ;  [System.Management.Automation.PSCustomObject]( shim = $shim ; program = $program) }
Get-ChildItem -Path ((scoop config).root_path | Join-Path -ChildPath '\shims') -Filter '*.shim' | ForEach-Object { $shim = $_.Name ; $q = Get-Content -Path $_.FullName ; $program = ($q -split ' = ')[1] ;  [PSCustomObject]$d = @{ shim = $shim ; program = $program} ; $d }
Get-ChildItem -Path ((scoop config).root_path | Join-Path -ChildPath '\shims') -Filter '*.shim' | ForEach-Object { $shim = $_.Name ; $q = Get-Content -Path $_.FullName ; $program = ($q -split ' = ')[1] ; [PSCustomObject]@{ shim = $shim ; program = $program } } | Group-Object -Property 
Get-ChildItem -Path ((scoop config).root_path | Join-Path -ChildPath '\shims') -Filter '*.shim' | ForEach-Object { $shim = $_.Name ; $q = Get-Content -Path $_.FullName ; $program = ($q -split ' = ')[1] ; [PSCustomObject]@{ shim = $shim ; program = $program } } | Group-Object -Property shim
Get-ChildItem -Path ((scoop config).root_path | Join-Path -ChildPath '\shims') -Filter '*.shim' | ForEach-Object { $shim = $_.Name ; $q = Get-Content -Path $_.FullName ; $program = ($q -split ' = ')[1] ; [PSCustomObject]@{ shim = $shim ; program = $program } } | Group-Object -Property progra
Get-ChildItem -Path ((scoop config).root_path | Join-Path -ChildPath '\shims') -Filter '*.shim' | ForEach-Object { $shim = $_.Name ; $q = Get-Content -Path $_.FullName ; $program = ($q -split ' = ')[1] ; [PSCustomObject]@{ shim = $shim ; program = $program } } | Group-Object -Property program
Get-ChildItem -Path ((scoop config).root_path | Join-Path -ChildPath '\shims') -Filter '*.shim' | ForEach-Object { $shim = $_.Name ; $q = Get-Content -Path $_.FullName ; $program = ($q -split ' = ')[1] ; [PSCustomObject]@{ shim = $shim ; program = $program } } 
Get-ChildItem -Path ((scoop config).root_path | Join-Path -ChildPath '\shims') -Filter '*.shim' | ForEach-Object { $shim = $_.Name ; $q = Get-Content -Path $_.FullName ; $program = ($q -split ' = ')[1] ; [PSCustomObject]@{ shim = $shim ; program = $program.trim() } }  | Group-Object -Property program
Get-ChildItem -Path ((scoop config).root_path | Join-Path -ChildPath '\shims') -Filter '*.shim' | ForEach-Object { $shim = $_.Name ; $q = Get-Content -Path $_.FullName ; $program = ($q -split ' = ')[1] ; [PSCustomObject]@{ shim = $shim ; program = $program.trim() } }  | Group-Object -Property program | Sort-Object -Descending Count -Descending
Get-ChildItem -Path ((scoop config).root_path | Join-Path -ChildPath '\shims') -Filter '*.shim' | ForEach-Object { $shim = $_.Name ; $q = Get-Content -Path $_.FullName ; $program = ($q -split ' = ')[1] ; [PSCustomObject]@{ shim = $shim ; program = $program.trim() } }  | Group-Object -Property program | Sort-Object -Descending Count
scoop uninstall git-imerge ; scoop install 'B:\PF\scoopbucket-1\Todo\git-imerge.json'
 chkdsk 
fsutil1
fsutil
fsutil reparsepoint
fsutil repair
fsutil repair state
Get-ChildItem -Recurse -Force | Where-Object { $_.LinkType -eq 'HardLink' } | Measure-Object | Select-Object -ExpandProperty Count
$Total = Get-ChildItem -Recurse -Force | Measure-Object | Select-Object -ExpandProperty Count
$Count = 0
Get-ChildItem -Recurse -Force | Where-Object { $_.LinkType -eq 'HardLink' } | ForEach-Object {`
    $Count++`
    $Percent = ($Count / $Total) * 100`
    Write-Progress -Activity "Counting hardlinks" -Status "Current count: $Count" -PercentComplete $Percent -CurrentOperation "Scanning $_"`
} | Measure-Object | Select-Object -ExpandProperty Count
$Total = Get-ChildItem -Recurse -Force | Measure-Object | Select-Object -ExpandProperty Count
$Count = 0
Get-ChildItem -Recurse -Force | Where-Object { $_.LinkType -eq 'HardLink' } | ForEach-Object {`
    $Count++`
    $Percent = ($Count / $Total) * 100`
    Write-Progress -Activity "Counting hardlinks" -Status "Current count: $Count" -PercentComplete $Percent -CurrentOperation "Scanning $_"`
    try {`
        Remove-Item $_ -Force`
    } catch [UnauthorizedAccessException] {`
        Write-Warning "Access denied: $_"`
    }`
} | Measure-Object | Select-Object -ExpandProperty Count
$Total = Get-ChildItem -Recurse -Force | Measure-Object | Select-Object -ExpandProperty Count
$Count = 0
Get-ChildItem -Recurse -Force | Where-Object { $_.LinkType -eq 'HardLink' } | ForEach-Object {`
    $Count++`
    $Percent = ($Count / $Total) * 100`
    Write-Progress -Activity "Counting hardlinks" -Status "Current count: $Count" -PercentComplete $Percent -CurrentOperation "Scanning $_"`
    try {`
        Remove-Item $_ -whatif`
    } catch [UnauthorizedAccessException] {`
        Write-Warning "Access denied: $_"`
    }`
} | Measure-Object | Select-Object -ExpandProperty Count
cd C:\ ; Get-ChildItem -Recurse -Force | Where-Object { $_.LinkType -eq 'HardLink' } | ForEach-Object {`
    $Count++`
    $Percent = ($Count / $Total) * 100`
    Write-Progress -Activity "Counting hardlinks" -Status "Current count: $Count" -PercentComplete $Percent -CurrentOperation "Scanning $_"`
    try {`
        Remove-Item $_ -whatif -ErrorAction SilentlyContinue`
    } catch [UnauthorizedAccessException] {`
        Write-Warning "Access denied: $_"`
    }`
} | Measure-Object | Select-Object -ExpandProperty Count
cd C:\ ; Get-ChildItem -Recurse -Force | Where-Object { $_.LinkType -eq 'HardLink' } | ForEach-Object {`
    $Count++; if($count -qt $total) { $Count = $Total } ; `
    $Percent = ($Count / $Total) * 100`
    Write-Progress -Activity "Counting hardlinks" -Status "Current count: $Count" -PercentComplete $Percent -CurrentOperation "Scanning $_"`
    try {`
        Remove-Item $_ -whatif -ErrorAction SilentlyContinue`
    } catch [UnauthorizedAccessException] {`
        Write-Warning "Access denied: $_"`
    }`
} | Measure-Object | Select-Object -ExpandProperty Count
cd C:\ ; Get-ChildItem -Recurse -Force | Where-Object { $_.LinkType -eq 'HardLink' } | ForEach-Object {`
    $Count++; if($count -gt $total) { $Count = $Total } ; `
    $Percent = ($Count / $Total) * 100`
    Write-Progress -Activity "Counting hardlinks" -Status "Current count: $Count" -PercentComplete $Percent -CurrentOperation "Scanning $_"`
    try {`
        Remove-Item $_ -whatif -ErrorAction SilentlyContinue`
    } catch [UnauthorizedAccessException] {`
        Write-Warning "Access denied: $_"`
    }`
} | Measure-Object | Select-Object -ExpandProperty Count
Resolve-Path -Path '../../../../../../.git/modules/PowerShellProjectFolder/modules/windowsAdmin/modules/my-windows/modules/Debloat_Windows_10/modules/WindowsDebloat/reclaimWindows' -RelativeTo $gitFile.DirectoryName
Resolve-Path -Path '../../../../../../.git/modules/PowerShellProjectFolder/modules/windowsAdmin/modules/my-windows/modules/Debloat_Windows_10/modules/WindowsDebloat/reclaimWindows' -RelativeTo 'B:\PF\PowerShellProjectFolder\doneNDeserted\WindowsAdmin\my-windows\Debloat_Windows_10\WindowsDebloat\reclaimWindows\'
# Define a function to translate a relative path to an absolute path
function Translate-Path {`
  [CmdletBinding()]`
  param (`
    # The path to the .git file`
    [Parameter(Mandatory = $true, ValueFromPipeline = $true)]`
    [ValidateScript({Test-Path $_ -PathType Leaf})]`
    [string]`
    $GitFile`
  )`
`
  # Read the content of the .git file`
  $content = Get-Content $GitFile`
`
  # Extract the "gitdir" path using a regular expression`
  $pattern = "gitdir: (.*)"`
  if ($content -match $pattern) {`
    $gitDir = $Matches[1]`
  }`
  else {`
    # Throw an error if the file does not contain a "gitdir" reference`
    throw "$GitFile does not contain a gitdir reference"`
  }`
`
  # Resolve the "gitdir" path to an absolute path using the custom function Resolve-RelativePath and the base directory of the .git file as the reference point`
  $absolutePath = Resolve-RelativePath -Path $gitDir -RelativeTo $gitFile.DirectoryName`
`
  # Return the absolute path as a string`
  return "$absolutePath"`
}
# Define a custom function to resolve a path relative to another path
# Source: [GitHub comment]
function Resolve-RelativePath {`
    param(`
        [Parameter(Mandatory=$true)]`
        [string]$Path,`
        [Parameter(Mandatory=$true)]`
        [string]$RelativeTo`
    )`
    if (Test-Path -IsValid -Path $Path) {`
        return (Resolve-Path -LiteralPath $Path).ProviderPath`
    }`
    else {`
        return (Resolve-Path -LiteralPath (Join-Path -Path $RelativeTo -ChildPath $Path)).ProviderPath`
    }`
}
cd 'B:\PF\PowerShellProjectFolder\doneNDeserted\WindowsAdmin\my-windows\Debloat_Windows_10\WindowsDebloat\reclaimWindows\'
Translate-Path -GitFile ".\.git"
Resolve-RelativePath -Path $gitDir -RelativeTo 'B:\PF\PowerShellProjectFolder\doneNDeserted\WindowsAdmin\my-windows\Debloat_Windows_10\WindowsDebloat\reclaimWindows'
Resolve-RelativePath -Path '../../../../../../.git/modules/PowerShellProjectFolder/modules/windowsAdmin/modules/my-windows/modules/Debloat_Windows_10/modules/WindowsDebloat/reclaimWindows' -RelativeTo 'B:\PF\PowerShellProjectFolder\doneNDeserted\WindowsAdmin\my-windows\Debloat_Windows_10\WindowsDebloat\reclaimWindows'
# Define a function to translate a relative path to an absolute path
function Translate-Path {`
  [CmdletBinding()]`
  param (`
    # The relative path`
    [Parameter(Mandatory = $true, ValueFromPipeline = $true)]`
    [string]`
    $RelativePath,`
`
    # The base directory`
    [Parameter(Mandatory = $true)]`
    [ValidateScript({Test-Path $_ -PathType Container})]`
    [string]`
    $BaseDirectory`
  )`
`
  # Split the relative path by the "/" character`
  $PathSegments = $RelativePath.Split("/")`
`
  # Set the current directory to the base directory`
  $CurrentDirectory = $BaseDirectory`
`
  # Loop through each path segment`
  foreach ($Segment in $PathSegments) {`
    # If the segment is "..", go up one level in the directory hierarchy`
    if ($Segment -eq "..") {`
      $CurrentDirectory = Split-Path -Path $CurrentDirectory -Parent`
    }`
    # If the segment is ".git", stop the loop and append the rest of the path`
    elseif ($Segment -eq ".git") {`
      break`
    }`
    # Otherwise, ignore the segment`
    else {`
      continue`
    }`
  }`
`
  # Get the index of the ".git" segment in the path segments`
  $GitIndex = [array]::IndexOf($PathSegments, ".git")`
`
  # Get the rest of the path segments after the ".git" segment`
  $RestOfPath = $PathSegments[$GitIndex + 1..$PathSegments.Length]`
`
  # Join the rest of the path segments by the "/" character`
  $RestOfPath = $RestOfPath -join "/"`
`
  # Append the rest of the path to the current directory`
  $AbsolutePath = Join-Path -Path $CurrentDirectory -ChildPath $RestOfPath`
`
  # Return the absolute path as a string`
  return "$AbsolutePath"`
}
translate-path -Path '../../../../../../.git/modules/PowerShellProjectFolder/modules/windowsAdmin/modules/my-windows/modules/Debloat_Windows_10/modules/WindowsDebloat/reclaimWindows' -BaseDirectory 'B:\PF\PowerShellProjectFolder\doneNDeserted\WindowsAdmin\my-windows\Debloat_Windows_10\WindowsDebloat\reclaimWindows'
translate-path -RelativePath '../../../../../../.git/modules/PowerShellProjectFolder/modules/windowsAdmin/modules/my-windows/modules/Debloat_Windows_10/modules/WindowsDebloat/reclaimWindows' -BaseDirectory 'B:\PF\PowerShellProjectFolder\doneNDeserted\WindowsAdmin\my-windows\Debloat_Windows_10\WindowsDebloat\reclaimWindows'
function Translate-Path {`
  [CmdletBinding()]`
  param (`
    # The relative path`
    [Parameter(Mandatory = $true, ValueFromPipeline = $true)]`
    [string]`
    $RelativePath,`
`
    # The base directory`
    [Parameter(Mandatory = $true)]`
    [ValidateScript({Test-Path $_ -PathType Container})]`
    [string]`
    $BaseDirectory`
  )`
`
  # Split the relative path by the "/" character`
  $PathSegments = $RelativePath.Split("/")`
`
  # Set the current directory to the base directory`
  $CurrentDirectory = $BaseDirectory`
`
  # Loop through each path segment`
  foreach ($Segment in $PathSegments) {`
    # If the segment is "..", go up one level in the directory hierarchy`
    if ($Segment -eq "..") {`
      $CurrentDirectory = Split-Path -Path $CurrentDirectory -Parent`
    }`
    # If the segment is ".git", stop the loop and append the rest of the path`
    elseif ($Segment -eq ".git") {`
      break`
    }`
    # Otherwise, ignore the segment`
    else {`
      continue`
    }`
  }`
`
  # Get the index of the ".git" segment in the path segments`
  $GitIndex = [array]::IndexOf($PathSegments, ".git")`
`
  # Get the rest of the path segments after the ".git" segment`
  $RestOfPath = $PathSegments[($GitIndex + 1)..$PathSegments.Length]`
`
  # Join the rest of the path segments by the "/" character`
  $RestOfPath = $RestOfPath -join "/"`
`
  # Append the rest of the path to the current directory`
  $AbsolutePath = Join-Path -Path $CurrentDirectory -ChildPath $RestOfPath`
`
  # Return the absolute path as a string`
  return "$AbsolutePath"`
}
translate-path -RelativePath '../../../../../../.git/modules/PowerShellProjectFolder/modules/windowsAdmin/modules/my-windows/modules/Debloat_Windows_10/modules/WindowsDebloat/reclaimWindows' -BaseDirectory 'B:\PF\PowerShellProjectFolder\doneNDeserted\WindowsAdmin\my-windows\Debloat_Windows_10\WindowsDebloat\reclaimWindows'
function Translate-Path {`
  [CmdletBinding()]`
  param (`
    # The relative path`
    [Parameter(Mandatory = $true, ValueFromPipeline = $true)]`
    [string]`
    $RelativePath,`
`
    # The base directory`
    [Parameter(Mandatory = $true)]`
    [ValidateScript({Test-Path $_ -PathType Container})]`
    [string]`
    $BaseDirectory`
  )`
`
  # Split the relative path by the "/" character`
  $PathSegments = $RelativePath.Split("/")`
`
  # Set the current directory to the base directory`
  $CurrentDirectory = $BaseDirectory`
`
  # Loop through each path segment`
  foreach ($Segment in $PathSegments) {`
    # If the segment is "..", go up one level in the directory hierarchy`
    if ($Segment -eq "..") {`
      $CurrentDirectory = Split-Path -Path $CurrentDirectory -Parent`
    }`
    # If the segment is ".git", stop the loop and append the rest of the path`
    elseif ($Segment -eq ".git") {`
      break`
    }`
    # Otherwise, ignore the segment`
    else {`
      continue`
    }`
  }`
`
  # Get the index of the ".git" segment in the path segments`
  $GitIndex = [array]::IndexOf($PathSegments, ".git")`
`
  # Get the rest of the path segments after the ".git" segment`
  $RestOfPath = $PathSegments[($GitIndex)..$PathSegments.Length]`
`
  # Join the rest of the path segments by the "/" character`
  $RestOfPath = $RestOfPath -join "/"`
`
  # Append the rest of the path to the current directory`
  $AbsolutePath = Join-Path -Path $CurrentDirectory -ChildPath $RestOfPath`
`
  # Return the absolute path as a string`
  return "$AbsolutePath"`
}
translate-path -RelativePath '../../../../../../.git/modules/PowerShellProjectFolder/modules/windowsAdmin/modules/my-windows/modules/Debloat_Windows_10/modules/WindowsDebloat/reclaimWindows' -BaseDirectory 'B:\PF\PowerShellProjectFolder\doneNDeserted\WindowsAdmin\my-windows\Debloat_Windows_10\WindowsDebloat\reclaimWindows'
scoop install anderlli0053_DEV-tools/cargo-binstall
scoop install okibcn_ScoopMaster/cargo-binstall_(1)
sudo choco install rust
$PROFILE
$profileFolder
explorer $profileFolder
explorer $profileFolder
$profileFolder
explorer $profileFolder
git fsck
git fetch --prune --tags
git gc
git fsck
git repack
git fetch --prune --tags
git fsck
git fetch --prune --tags --all
git fsck
git index-pack -v --stdout pack-....pack | git unpack-objects
B:\PF\Archive\dotFiles\.git\objects\pack\pack-d93c7673dc37a1308b48eeb8e9883b0b40ae3f37.pack | git unpack-objects
'B:\PF\Archive\dotFiles\.git\objects\pack\pack-d93c7673dc37a1308b48eeb8e9883b0b40ae3f37.pack' | git unpack-objects
git unpack-object -h
git unpack-objects -h
git unpack-objects 
git push 'B:\Users\New folder (3)'
cd 'B:\Users\New folder' ; git push 'B:\Users\New folder (3)'
cd 'B:\Users\New folder (2)' ; git push 'B:\Users\New folder (3)'
git filter-repo --anlayze
git filter-repo --anlyze
git filter-repo --analyze
git filter-repo --path 'bucket' --invert-path
git filter-repo --path 'bucket' --invert-path --force
git filter-repo --analyze --force
git filter-repo -h
git filter-repo --to-subdirectory-filter 'Documents' --refs 'Documents'
git filter-repo --to-subdirectory-filter 'Documents' --refs 'Default/Documents'
git filter-repo --analyze --force
git filter-repo --to-subdirectory-filter 'Vortex' --refs 'Default/vortex-detachedHead'
git filter-repo --to-subdirectory-filter 'Vortex' --refs 'Default/Vortex'
git filter-repo --analyze --force
git filter-repo --h
git filter-repo --rename-path 'Documents/My Documents/Apps/.config' : '.config' -dry-run
Invoke-Expression "git filter-repo --rename-path 'Documents/My Documents/Apps/.config' : '.config' -dry-run"
Invoke-Expression "git filter-repo --rename-path 'Documents/My Documents/Apps/.config' : '.config' --dry-run"
Invoke-Expression "git filter-repo --rename-path 'Documents/My Documents/Apps/.config':'.config' --dry-run"
Invoke-Expression "git filter-repo --rename-path ''Documents/My Documents/Apps/.config'':''.config'' --dry-run"
Invoke-Expression "git filter-repo --rename-path ´Documents/My Documents/Apps/.config´:'.config´ --dry-run"
Invoke-Expression "git filter-repo --rename-path `Documents/My Documents/Apps/.config`:`.config` --dry-run"
git filter-repo --rename-path `Documents/My Documents/Apps/.config`:`.config` --dry-run
git filter-repo --rename-path `Documents/My Documents/Apps/.config` : `.config` --dry-run
function Open-ISEFunction {`
     <#`
     .SYNOPSIS`
         Open a function in ISE`
     .DESCRIPTION`
         Open a function in ISE.  Any function that can be obtained by (get-command <command>).definition.  Pretty much anything that isn't compiled in a DLL or obfuscated in some other manner.`
     .FUNCTIONALITY`
         General Command`
    #>`
    [cmdletbinding()]`
    param(`
    `
    #In the validation block, check if input is a function and get the definition`
    [ValidateScript({ Get-Command -commandtype function -name $_ })]`
        [string[]]$function`
    )`
`
    foreach($fn in $function){`
        `
        #Get the definition`
        $definition = (Get-Command -commandtype function -name $fn).definition`
        `
        #If the definition exists, add a new tab with the contents.`
        if($definition){`
            `
            #Definition won't include function keyword.  Add it.`
            $definition = "function $fn { $definition }"`
            `
            #Add the file and definition content`
            $tab = $psise.CurrentPowerShellTab.files.Add()`
            $tab.editor.text = $definition`
`
            #set the caret to column 1 line 1`
            $tab.editor.SetCaretPosition(1,1)`
`
            #Sleep a few milliseconds.  Not sure why but omitting this has caused issues for me.`
            start-sleep -Milliseconds 200`
        }`
    }`
}
open-isefunction 'translate-path'
git filter-repo --to-subdirectory-filter 'scoop' --refs 'Branch_5ab9cea0'
git filter-repo --rename-path scoop/AppData:AppData --refs 'Branch_5ab9cea0'
git filter-repo -h
git filter-repo --path-rename scoop/AppData:AppData --refs 'Branch_5ab9cea0'
git filter-repo --path-rename scoop/AHK:autohotkey --refs 'Branch_5ab9cea0'
git filter-repo --path-rename scoop/BashHistory:Documents --refs 'Branch_5ab9cea0'
git filter-repo --path-rename scoop/BeondCompare4:Beyond Compare 4 --refs 'Branch_5ab9cea0'
git filter-repo --path-rename scoop/BeondCompare4:'Beyond Compare 4' --refs 'Branch_5ab9cea0'
git filter-repo --path-rename scoop/Datagrip:'Datagrip' --refs 'Branch_5ab9cea0'
git filter-repo --path-rename scoop/steamapps:'steamapps' --refs 'Branch_5ab9cea0'
git filter-repo --path-rename scoop/Git:'.config/git' --refs 'Branch_5ab9cea0'
git filter-repo --path-rename scoop/Git:'Git' --refs 'Branch_5ab9cea0'
git filter-repo --path-rename scoop/Cherrytree:'Cherrytree' --refs 'Branch_5ab9cea0'
git filter-repo --path-rename scoop/Ditto:'Ditto' --refs 'Branch_5ab9cea0'
git filter-repo --path-rename scoop/Everything:'Everything' --refs 'Branch_5ab9cea0'
git filter-repo --path-rename scoop/UserFolder:'Everything' --refs 'Branch_5ab9cea0'
git filter-repo --path-rename scoop/UserFolder:'scoop/persist' --refs 'Branch_5ab9cea0'
git filter-repo --path-rename scoop/UserFolder:'scoop/persist' --refs 'Branch_5ab9cea0' --what-if
git filter-repo --path-rename scoop/xEditScripts:'scoop/persist' --refs 'Branch_5ab9cea0' --what-if
git filter-repo --path-rename scoop/xEditScripts:'scoop/xEditScripts' --refs 'Branch_5ab9cea0' --what-if
git filter-repo --path-rename scoop/xEditScripts:'xEditScripts' --refs 'Branch_5ab9cea0'
git filter-repo --path-rename scoop/Vortex:'Vortex' --refs 'Branch_5ab9cea0'
git filter-repo --path-rename autohotkey:'AHK' --refs 'Branch_5ab9cea0'
git filter-repo --path-rename scoop/portableAppsPlatform:'scoop/xEditScripts' --refs 'Branch_5ab9cea0' --what-if
git filter-repo --path-rename scoop/portableAppsPlatform:'portableAppsPlatform' --refs 'Branch_5ab9cea0'
git filter-repo --path-rename Documents:'bashHistory' --refs 'Branch_5ab9cea0'
git filter-repo --path-rename scoop/Powershell:'Documents/PowerShell' --refs 'Branch_5ab9cea0'
git filter-repo --path-rename 'scoop/.gitmodules':'.gitmodules' --refs 'Branch_5ab9cea0'
git filter-repo --path-rename 'scoop/.gitmodules' : '.gitmodules' --refs 'Branch_5ab9cea0'
invoke-expression "git filter-repo --path-rename 'scoop/.gitmodules':'.gitmodules' --refs 'Branch_5ab9cea0'"
git filter-repo --to-subdirectory-filter 'scoop' --refs 'gt'
git filter-repo --to-subdirectory-filter 'scoop' --refs 'tg'
git filter-repo --path-rename bcompare:'Beyond Compare 4' --refs 'master2'
git filter-repo --path-rename 'AHK' : 'autohotkey' --refs 'Branch_projectfolder'
git filter-repo --path-rename 'AHK':'autohotkey' --refs 'Branch_projectfolder'
git filter-repo --path-rename AHK:autohotkey --refs 'Branch_projectfolder'
git filter-repo --path-rename UserFolder:AppData --refs 'Branch_projectfolder'
git filter-repo --path-rename ForksDownloadedCode:Forks --refs 'Branch_projectfolder'
Arrogant Bastard Typhoon Gaming mouse
git filter-repo --path-rename 'Arrogant Bastard Typhoon Gaming mouse':'Documents/Arrogant Bastard Typhoon Gaming mouse' --refs 'Branch_projectfolder'
git filter-repo --path-rename 'Pascal/xEdit':'xEditScripts' --refs 'Branch_projectfolder'
git filter-repo --path-rename Pascal/xEdit:'xEditScripts' --refs 'Branch_projectfolder'
git filter-repo --path-rename UserSettings:'.config' --refs 'Branch_projectfolder'
git filter-repo --path-rename bcompare:'BeondCompare4' --refs 'Branch_projectfolder'
git filter-repo --path-rename 'Documents/xMy Games':My-Games --refs 'Branch_projectfolder'
git filter-repo --path-rename 'Documents/xMy Games':MyGames --refs 'Branch_projectfolder'
git filter-repo --path-rename 'scoopbucket-presist': --refs 'Branch_projectfolder'
git filter-repo --path-rename scoopbucket-presist: --refs 'Branch_projectfolder'
git filter-repo --path-rename scoopbucket-presist:'' --refs 'Branch_projectfolder'
git filter-repo --path-rename vscode:vscodium --refs 'Branch_projectfolder'
git filter-repo --path-rename WebProgrammingProjects:workspace/WebProgrammingProjects --refs 'Branch_projectfolder'
git filter-repo --path-rename vba:workspace/vba --refs 'Branch_projectfolder'
git filter-repo --path-rename reg:workspace/reg --refs 'Branch_projectfolder'
git filter-repo --path-rename FFxpl:workspace/FFxpl --refs 'Branch_projectfolder'
git filter-repo --path-rename Forks:workspace/Forks --refs 'Branch_projectfolder'
git filter-repo --path-rename ImageEditing:workspace/ImageEditing --refs 'Branch_projectfolder'
git filter-repo --path-rename Ini:workspace/Ini --refs 'Branch_projectfolder'
git filter-repo --path-rename Java:workspace/Java --refs 'Branch_projectfolder'
git filter-repo --path-rename JsonWorkSpace:workspace/JsonWorkSpace --refs 'Branch_projectfolder'
git filter-repo --path-rename Sql_Db:workspace/Sql_Db --refs 'Branch_projectfolder'
git filter-repo --path-rename CSharpVisualStudio:'VisualStudio' --refs 'Branch_projectfolder'
git filter-repo --path-rename 'Unix Bat Scripts':uNix --refs 'Branch_projectfolder'
git filter-repo --path-rename "Unix Bat Scripts":uNix --refs 'Branch_projectfolder'
git filter-repo --path-rename <Unix Bat Scripts:uNix> --refs 'Branch_projectfolder'
git filter-repo --path-rename uNix:'Unix Bat Scripts' --refs 'Branch_projectfolder'
git filter-repo --path-rename Pascal:workspace/Pascal --refs 'Branch_projectfolder'
git filter-repo --path-rename ImageEditing:workspace/ImageEditing --refs 'Branch_projectfolder'
git filter-repo --path-rename FFxpl:workspace/FFxpl --refs 'Branch_projectfolder'
git filter-repo --path-rename FFxpI:workspace/FFxpI --refs 'Branch_projectfolder'
git filter-repo --path-rename ImageEdititng:workspace/ImageEdititng --refs 'Branch_projectfolder' --what-if
git filter-repo --path-rename ImageEdititng:workspace/ImageEdititng --refs 'Branch_projectfolder'
git filter-repo --path-rename officeAlternative:workspace/ImageEdititng --refs 'Branch_projectfolder' --what-if
git filter-repo --path-rename officeAlternative:workspace/officeAlternative --refs 'Branch_projectfolder' --what-if
git filter-repo --path-rename officeAlternative:workspace/officeAlternative --refs 'Branch_projectfolder'
git filter-repo --path-rename PowershellProjectFolder:workspace/officeAlternative --refs 'Branch_projectfolder'
git filter-repo --path-rename workspace/officeAlternative:workspace/PowershellProjectFolder --refs 'Branch_projectfolder'
git filter-repo --path-rename Git:workspace/officeAlternative --refs 'Branch_projectfolder' --what-if
git filter-repo --path-rename scoopbucket-presist/Git:'.config/Git' --refs 'Branch_projectfolder' --what-if
git filter-repo --path-rename scoopbucket-presist/Git:.config/Git --refs 'Branch_projectfolder' --what-if
git filter-repo --path-rename scoopbucket-presist/Git:Git --refs 'Branch_projectfolder' --what-if
git filter-repo --path-rename scoopbucket-presist/Git:Git --refs 'Branch_projectfolder'
git filter-repo --path-rename Git:.config/Git --refs 'Branch_projectfolder' --what-if
git filter-repo --path-rename Git:.config/Git --refs 'Branch_projectfolder'
git filter-repo --path-rename scoop:Documents/scoop --refs 'Branch_projectfolder'
git filter-repo --path-rename Powershell:Documents/Powershell --refs 'Branch_projectfolder'
git splitish
splitsh-lite
winget install -e --id GitHub.GitLFS
choco install git-fs
pip install gitfs
pip install gitfs
pip install gitfs==0.5.1
pip install gitfs==0.3.1
pip install fusepy==2.0.4
pip install gitfs==0.3.1
git config --global core.fsmonitor .git/hooks/fsmonitor-watchman
function Open-ISEFunction {`
     <#`
     .SYNOPSIS`
         Open a function in ISE`
     .DESCRIPTION`
         Open a function in ISE.  Any function that can be obtained by (get-command <command>).definition.  Pretty much anything that isn't compiled in a DLL or obfuscated in some other manner.`
     .FUNCTIONALITY`
         General Command`
    #>`
    [cmdletbinding()]`
    param(`
    `
    #In the validation block, check if input is a function and get the definition`
    [ValidateScript({ Get-Command -commandtype function -name $_ })]`
        [string[]]$function`
    )`
`
    foreach($fn in $function){`
        `
        #Get the definition`
        $definition = (Get-Command -commandtype function -name $fn).definition`
        `
        #If the definition exists, add a new tab with the contents.`
        if($definition){`
            `
            #Definition won't include function keyword.  Add it.`
            $definition = "function $fn { $definition }"`
            `
            #Add the file and definition content`
            $tab = $psise.CurrentPowerShellTab.files.Add()`
            $tab.editor.text = $definition`
`
            #set the caret to column 1 line 1`
            $tab.editor.SetCaretPosition(1,1)`
`
            #Sleep a few milliseconds.  Not sure why but omitting this has caused issues for me.`
            start-sleep -Milliseconds 200`
        }`
    }`
}
Get-Command -Name Open-ISEFunction
(Get-Command -Name Open-ISEFunction).source
(Get-Command -Name Open-ISEFunction).scriptblock
Add-Content -Path $PROFILE -Value "function Get-Hello { Write-Output 'Hello, world!' }" 
(Get-Command -Name Open-ISEFunction).Definition
(Get-Command -Name Open-ISEFunction).ToString()
function Copy-Function {`
  param(`
    [string]$Name # The name of the function to copy`
  )`
`
  # Get the CommandInfo object for the function to copy`
  $original = Get-Command -Name $Name`
`
  # Check if the command is a function`
  if ($original.CommandType -eq 'Function') {`
`
    # Get the name, parameters, and code of the original function`
    $name = $original.Name`
    $parameters = $original.Parameters`
    $code = $original.ScriptBlock`
`
    # Create a string that contains the function name and the parameters`
    $declaration = "function $name {"`
    foreach ($parameter in $parameters.Values) {`
      $declaration += "param($" + $parameter.Name + ")"`
    }`
    $declaration += "}"`
`
    # Append the function declaration and the code to the profile script`
    Add-Content -Path $PROFILE -Value "$declaration`n$code"`
`
    # Write a message to indicate success`
    Write-Output "The function $name has been copied to your profile."`
  }`
  else {`
    # Write an error message if the command is not a function`
    Write-Error "The command $Name is not a function."`
  }`
}
Copy-Function -Name Copy-Function
$profileFolder
explorer $profileFolder
explorer $env:USERPROFILE\.config\powershell\
function get-helpPLease($help) { echo $help}
get-command -name get-helpPLase
get-command -name get-helpPLaese
get-command -name get-helpPLaese($help)
get-command -name get-helpPLease
(get-command -name get-helpPLease).ScriptBlock
(get-command -name copy-command).ScriptBlock
(get-command -name copy-function).ScriptBlock
function get-helpPLease($help) { echo $help}
copy-function get-helpPLease
function get-helpPLease($help) { echo $help}
copy-function get-helpPLease
function get-helpPLease($help) { echo $help}
copy-function get-helpPLease
function get-helpPLease($help) { echo $help}
copy-function get-helpPLease
function get-helpPLease($help) { echo $help}
copy-function get-helpPLease
(Get-command all).ScriptBlock
explorer get-historyPath 
Get-PSReadlineOption
<<<<<<< HEAD
>>>>>>> cfce7ff (state)
=======
(Get-command all).ScriptBlock
(Get-command all).ScriptBlock.trim()
(Get-command all).ScriptBlock.toString().trim()
$regex ='\s{2,}'; (Get-command all).ScriptBlock.replace($regex,'`t')
$regex ='\s{2,}'; (Get-command all).ScriptBlock.toString().replace($regex,'`t')
$regex ='\s{2,}'; (Get-command all).ScriptBlock.toString() -replace($regex,'`t')
$regex ='\s{2,}'; (Get-command all).ScriptBlock.toString() -replace($regex,'\t')
$regex ='\s{2,}'; (Get-command all).ScriptBlock.toString() -replace($regex,'\\t')
$regex ='\s{2,}'; (Get-command all).ScriptBlock.toString() -replace($regex,"`t")
Add-Content -Path $PROFILE -Value (Get-Clipboard)
Write-GitBranchName
Write-GitStatus
Convert-Path get-clipboard
Convert-Path (get-clipboard)
(Convert-Path (get-clipboard)).name
(Convert-Path (get-clipboard)) | select -Property name
(resolve-Path (get-clipboard)) | select -Property name
resolve-Path (get-clipboard)
Get-Item (get-clipboard)
(Get-Item (get-clipboard)).BaseName
Get-ChildItem -Path $PSScriptRoot\*.ps1 
Get-ChildItem -Path $PSScriptRoot
Get-ChildItem -Path $PSScriptRoot -Filter '\*.ps1'
Get-ChildItem -Path $PSScriptRoot + '\*.ps1'
Get-ChildItem -Path $PSScriptRoot\*.ps1 
Get-ChildItem -Path $PSScriptRoot\*.log
Get-ChildItem -Path "$PSScriptRoot\*.log"
Get-ChildItem -Path "$PSScriptRoot\*" -Filter *.log
Get-ChildItem -Path "$PSScriptRoot\*" -Filter "*.log"
Get-ChildItem -Path "$PSScriptRoot/*" -Filter "*.log"
Get-ChildItem -Path $PSScriptRoot -Filter "*.log"
Get-Help Set-PSReadLineOption -Full
get-historyPath
Get-Help get-PSReadLineOption -Full
get-PSReadLineOption
#2023-09-06 22:17:25, C:\Users\CrRoot, DESKTOP-OPGKPPF
<<<<<<< HEAD
>>>>>>> b1807ce (#2023-09-06 22:17:25, C:\Users\CrRoot, DESKTOP-OPGKPPF)
=======
#2023-09-06 22:17:25, C:\Users\CrRoot, DESKTOP-OPGKPPF
>>>>>>> c96a208 (#2023-09-06 22:17:25, C:\Users\CrRoot, DESKTOP-OPGKPPF)
get-historyPath
Get-Help get-PSReadLineOption -Full
# Define the path of the PS1 file
$PS1File = "C:\Users\user\Documents\MyScript.ps1"
# Load the PS1 file as an AST
$AST = [System.Management.Automation.Language.Parser]::ParseFile($PS1File, [ref]$null, [ref]$null)
# Get all the function definitions in the AST
$Functions = $AST.FindAll({$args[0] -is [System.Management.Automation.Language.FunctionDefinitionAst]}, $true)
# Loop through each function definition
foreach ($Function in $Functions) {`
    # Get the function name`
    $FunctionName = $Function.Name`
`
    # Get the function body as a string`
    $FunctionBody = $Function.Body.Extent.Text`
`
    # Define the path of the new file with the function name`
    $NewFile = Join-Path (Split-Path $PS1File) ($FunctionName + ".ps1")`
`
    # Write the function body to the new file`
    Set-Content -Path $NewFile -Value $FunctionBody`
}
# Define the path of the PS1 file
 function SplitOutFunctions ($PS1File)`
{`
    # Load the PS1 file as an AST`
    $AST = [System.Management.Automation.Language.Parser]::ParseFile($PS1File, [ref]$null, [ref]$null)`
`
    # Get all the function definitions in the AST`
    $Functions = $AST.FindAll({$args[0] -is [System.Management.Automation.Language.FunctionDefinitionAst]}, $true)`
`
    # Loop through each function definition`
    foreach ($Function in $Functions) {`
        # Get the function name`
        $FunctionName = $Function.Name`
`
        # Get the function body as a string`
        $FunctionBody = $Function.Extent.Text`
`
        # Define the path of the new file with the function name`
        $NewFile = Join-Path (Split-Path $PS1File) ($FunctionName + ".ps1")`
`
        # Write the function body to the new file`
        Set-Content -Path $NewFile -Value $FunctionBody`
    }`
}
SplitOutFunctions 'B:\PF\Archive\ps1\git\plumming-commit.ps1'
 function SplitOutFunctions ($PS1File)`
{`
    # Load the PS1 file as an AST`
    $AST = [System.Management.Automation.Language.Parser]::ParseFile($PS1File, [ref]$null, [ref]$null)`
`
    # Get all the function definitions in the AST`
    $Functions = $AST.FindAll({$args[0] -is [System.Management.Automation.Language.FunctionMemberAst]}, $true)`
`
    # Loop through each function definition`
    foreach ($Function in $Functions) {`
        # Get the function name`
        $FunctionName = $Function.Name`
`
        # Get the function body as a string`
        $FunctionBody = $Function.Extent.Text`
`
        # Define the path of the new file with the function name`
        $NewFile = Join-Path (Split-Path $PS1File) ($FunctionName + ".ps1")`
`
        # Write the function body to the new file`
        Set-Content -Path $NewFile -Value $FunctionBody`
    }`
}
SplitOutFunctions 'B:\PF\Archive\ps1\git\plumming-commit.ps1'
$ast
$AST.FindAll({$args[0] -is [System.Management.Automation.Language.FunctionMemberAst]}, $true)
[System.Management.Automation.Language.Parser]::ParseFile('B:\PF\Archive\ps1\git\plumming-commit.ps1', [ref]$null, [ref]$null)
[System.Management.Automation.Language.Parser]::ParseFile('B:\PF\Archive\ps1\git\plumming-commit.ps1', [ref]$null, [ref]$null) | %{ $_ }
[System.Management.Automation.Language.Parser]::ParseFile('B:\PF\Archive\ps1\git\plumming-commit.ps1', [ref]$null, [ref]$null) | %{ $_ | get-parameters }
[System.Management.Automation.Language.Parser]::ParseFile('B:\PF\Archive\ps1\git\plumming-commit.ps1', [ref]$null, [ref]$null) | %{ $_ | Get-Member }
[System.Management.Automation.Language.Parser]::ParseFile('B:\PF\Archive\ps1\git\plumming-commit.ps1', [ref]$null, [ref]$null) | %{ $_.getType() }
[System.Management.Automation.Language.Parser]::ParseFile('B:\PF\Archive\ps1\git\plumming-commit.ps1', [ref]$null, [ref]$null) | %{ $_ | get-parameters }
[System.Management.Automation.Language.Parser]::ParseFile('B:\PF\Archive\ps1\git\plumming-commit.ps1', [ref]$null, [ref]$null) | %{ $_ | Get-Member }
[System.Management.Automation.Language.Parser]::ParseFile('B:\PF\Archive\ps1\git\plumming-commit.ps1', [ref]$null, [ref]$null).FindAll({$args[0] -is [System.Management.Automation.Language.FunctionDefinitionAst]}, $true)
[System.Management.Automation.Language.Parser]::ParseFile('B:\PF\Archive\ps1\git\plumming-commit.ps1', [ref]$null, [ref]$null).FindAll({$args[0] -is [System.Management.Automation.Language.FunctionDefinitionAst]}, $true) | % { [System.Management.Automation.Language.HelpCommentsParser]::GetHelpContent($_) }
[System.Management.Automation.Language.Parser]::ParseFile('B:\PF\Archive\ps1\git\plumming-commit.ps1', [ref]$null, [ref]$null).FindAll({$args[0] -is [System.Management.Automation.Language.FunctionDefinitionAst]}, $true) | % { [System.Management.Automation.Language.HelpCommentsParser]::GetHelpContent($_).Extent.Text }
SplitOutFunctions 'B:\PF\Archive\ps1\git\argsToBranch.ps1'
 function SplitOutFunctions ($PS1File)`
{`
    # Load the PS1 file as an AST`
    $AST = [System.Management.Automation.Language.Parser]::ParseFile($PS1File, [ref]$null, [ref]$null)`
`
    # Get all the function definitions in the AST`
    $Functions = $AST.FindAll({$args[0] -is [System.Management.Automation.Language.FunctionDefinitionAst]}, $true)`
`
    # Loop through each function definition`
    foreach ($Function in $Functions) {`
        # Get the function name`
        $FunctionName = $Function.Name`
`
        # Get the function body as a string`
        $FunctionBody = $Function.Extent.Text`
`
        # Define the path of the new file with the function name`
        $NewFile = Join-Path (Split-Path $PS1File) ($FunctionName + ".ps1")`
`
        # Write the function body to the new file`
        Set-Content -Path $NewFile -Value $FunctionBody`
    }`
}
SplitOutFunctions 'B:\PF\Archive\ps1\git\argsToBranch.ps1'
SplitOutFunctions 'B:\PF\Archive\ps1\git\Roots.ps1'
SplitOutFunctions 'B:\PF\Archive\ps1\git\submoduleUpdate.ps1'
SplitOutFunctions 'B:\PF\Archive\ps1\git\repair\submoduleUpdate.ps1'
SplitOutFunctions 'B:\PF\Archive\ps1\git\project\project-merge-File-With-History.ps1'
SplitOutFunctions 'B:\PF\Archive\ps1\git\repair\subfolderSearch\CorruptedModulesCombinedWithQue.ps1'
SplitOutFunctions 'B:\PF\Archive\ps1\git\chain-renameForced.ps1'
SplitOutFunctions 'B:\PF\Archive\ps1\git\submodule\usingSubmodule\CompareTwos.ps1'
SplitOutFunctions 'B:\PF\Archive\ps1\git\project\MapTowardsOther\CompareTwoRepos.ps1'
SplitOutFunctions 'B:\PF\Archive\ps1\git\repair\CorruptedModulesCombinedWithQue.ps1'
SplitOutFunctions 'B:\PF\Archive\ps1\git\repair\submodule\ModulesCombinedWithQue.ps1'
SplitOutFunctions 'B:\PF\Archive\ps1\git\gitFilterMoveIfNeeded.ps1'
SplitOutFunctions 'B:\PF\Archive\ps1\git\repair\lib\FilterMoveIfNeeded.ps1'
SplitOutFunctions 'B:\PF\Archive\ps1\git\module\etc.ps1'
SplitOutFunctions 'B:\PF\Archive\ps1\git\repair\submodule\New folder\after repair\afterReparations.ps1'
SplitOutFunctions 'B:\PF\Archive\ps1\git\repair\JoinedScripts.ps1'
SplitOutFunctions 'B:\PF\Archive\ps1\git\repair\Gitmodules\New folder\lib\JoinedScripts.ps1'
SplitOutFunctions 'B:\PF\Archive\ps1\git\repair\subfolderSearch\TestIfFilesPointToexsisting.ps1'
SplitOutFunctions 'B:\PF\Archive\ps1\git\search\SearchAllBranches.ps1'
SplitOutFunctions 'B:\PF\Archive\ps1\git\repair\status\status-nontracked.ps1'
SplitOutFunctions 'B:\PF\Archive\ps1\git\FolderToRepo.ps1'
SplitOutFunctions 'B:\PF\Archive\ps1\git\repair\submodule\UnAbsorbeDirs.ps1'
SplitOutFunctions 'B:\PF\Archive\ps1\Git-Module\git-lookupGitdirs.ps1'
SplitOutFunctions 'B:\PF\Archive\ps1\git\repair\submodule\fix-CorruptedGitModules.ps1'
SplitOutFunctions 'B:\PF\Archive\ps1\git\repair\subfolderSearch\CorruptedModules.ps1'
Copy-Function -Name 'SplitOutFunctions'
Copy-Function -Name SplitOutFunctions
Copy-Function 'SplitOutFunctions'
SplitOutFunctions 'B:\PF\Archive\ps1\git\submodule\SubmoduleFromGitmodules\git_add_submodule.ps1'
SplitOutFunctions 'B:\PF\Archive\ps1\git\project\MapTowardsOther\CompareTwoRepos.ps1'
git config --global core.fsmonitor 
git config rm --global core.fsmonitor
git config -h
git config  --global --unset core.fsmonitor
function Add-ToProfile($content) { Add-Content -Path $PROFILE -Value $content }
Copy-Function 'Add-ToProfile'
git filter-repo --analyze --force
git config --local diff.renameLimit 5285
git filter-repo --analyze --force
git submodule add https://github.com/anishathalye/dotbot
git config -f .gitmodules submodule.dotbot.ignore dirty # ignore dirty commits in the submodule
cp dotbot/tools/git-submodule/install .
touch install.conf.yaml
'' > install.conf.yaml
git filter-repo --path-rename vscode:editors/vscode --refs 'remotes/IrishBruse/main'
git filter-repo --path-rename files:tools/git --refs 'remotes/IrishBruse/main'
git filter-repo --path-rename WindowsPowerShell:terminal/pwsh --refs 'remotes/IrishBruse/main'
git filter-repo --path-rename shell:windows/nilesoft-shell --refs 'irishBrusemain'
explorer $profileFolder
cd 'B:\PF\Archive\ps1\git'
function Translate-Path {``
  [CmdletBinding()]``
  param (``
    # The relative path``
    [Parameter(Mandatory = $true, ValueFromPipeline = $true)]``
    [string]``
    $RelativePath,``
``
    # The base directory``
    [Parameter(Mandatory = $true)]``
    [ValidateScript({Test-Path $_ -PathType Container})]``
    [string]``
    $BaseDirectory``
  )``
``
  # Split the relative path by the "/" character``
  $PathSegments = $RelativePath.Split("/")``
``
  # Set the current directory to the base directory``
  $CurrentDirectory = $BaseDirectory``
``
  # Loop through each path segment``
  foreach ($Segment in $PathSegments) {``
    # If the segment is "..", go up one level in the directory hierarchy``
    if ($Segment -eq "..") {``
      $CurrentDirectory = Split-Path -Path $CurrentDirectory -Parent``
    }``
    # If the segment is ".git", stop the loop and append the rest of the path``
    elseif ($Segment -eq ".git") {``
      break``
    }``
    # Otherwise, ignore the segment``
    else {``
      continue``
    }``
  }``
``
  # Get the index of the ".git" segment in the path segments``
  $GitIndex = [array]::IndexOf($PathSegments, ".git")``
``
  # Get the rest of the path segments after the ".git" segment``
  $RestOfPath = $PathSegments[($GitIndex)..$PathSegments.Length]``
``
  # Join the rest of the path segments by the "/" character``
  $RestOfPath = $RestOfPath -join "/"``
``
  # Append the rest of the path to the current directory``
  $AbsolutePath = Join-Path -Path $CurrentDirectory -ChildPath $RestOfPath``
``
  # Return the absolute path as a string``
  return "$AbsolutePath"``
}
translate-path -RelativePath '../../../../../../.git/modules/PowerShellProjectFolder/modules/windowsAdmin/modules/my-windows/modules/Debloat_Windows_10/modules/WindowsDebloat/reclaimWindows' -BaseDirectory 'B:\PF\PowerShellProjectFolder\doneNDeserted\WindowsAdmin\my-windows\Debloat_Windows_10\WindowsDebloat\reclaimWindows'
function Translate-Path {`
  [CmdletBinding()]`
  param (`
    # The relative path`
    [Parameter(Mandatory = $true, ValueFromPipeline = $true)]`
    [string]`
    $RelativePath,`
`
    # The base directory``
    [Parameter(Mandatory = $true)]`
    [ValidateScript({Test-Path $_ -PathType Container})]`
    [string]`
    $BaseDirectory`
  )`
`
  # Split the relative path by the "/" character``
  $PathSegments = $RelativePath.Split("/")`
`
  # Set the current directory to the base directory``
  $CurrentDirectory = $BaseDirectory`
`
  # Loop through each path segment``
  foreach ($Segment in $PathSegments) {`
    # If the segment is "..", go up one level in the directory hierarchy``
    if ($Segment -eq "..") {`
      $CurrentDirectory = Split-Path -Path $CurrentDirectory -Parent`
    }`
    # If the segment is ".git", stop the loop and append the rest of the path``
    elseif ($Segment -eq ".git") {`
      break`
    }`
    # Otherwise, ignore the segment``
    else {`
      continue`
    }`
  }`
`
  # Get the index of the ".git" segment in the path segments``
  $GitIndex = [array]::IndexOf($PathSegments, ".git")`
`
  # Get the rest of the path segments after the ".git" segment``
  $RestOfPath = $PathSegments[($GitIndex)..$PathSegments.Length]`
`
  # Join the rest of the path segments by the "/" character``
  $RestOfPath = $RestOfPath -join "/"`
`
  # Append the rest of the path to the current directory``
  $AbsolutePath = Join-Path -Path $CurrentDirectory -ChildPath $RestOfPath`
`
  # Return the absolute path as a string``
  return "$AbsolutePath"`
}
translate-path -RelativePath '../../../../../../.git/modules/PowerShellProjectFolder/modules/windowsAdmin/modules/my-windows/modules/Debloat_Windows_10/modules/WindowsDebloat/reclaimWindows' -BaseDirectory 'B:\PF\PowerShellProjectFolder\doneNDeserted\WindowsAdmin\my-windows\Debloat_Windows_10\WindowsDebloat\reclaimWindows'
copy-function translate-path
copy-function 'translate-path'
function Translate-Path {`
  [CmdletBinding()]`
  param (`
    # The relative path`
    [Parameter(Mandatory = $true, ValueFromPipeline = $true)]`
    [string]`
    $RelativePath,`
`
    # The base directory``
    [Parameter(Mandatory = $true)]`
    [ValidateScript({Test-Path $_ -PathType Container})]`
    [string]`
    $BaseDirectory`
  )`
`
  # Split the relative path by the "/" character``
  $PathSegments = $RelativePath.Split("/")`
`
  # Set the current directory to the base directory``
  $CurrentDirectory = $BaseDirectory`
`
  # Loop through each path segment``
  foreach ($Segment in $PathSegments) {`
    # If the segment is "..", go up one level in the directory hierarchy``
    if ($Segment -eq "..") {`
      $CurrentDirectory = Split-Path -Path $CurrentDirectory -Parent`
    }`
    # If the segment is ".git", stop the loop and append the rest of the path``
    elseif ($Segment -eq ".git") {`
      break`
    }`
    # Otherwise, ignore the segment``
    else {`
      continue`
    }`
  }`
`
  # Get the index of the ".git" segment in the path segments``
  $GitIndex = [array]::IndexOf($PathSegments, ".git")`
`
  # Get the rest of the path segments after the ".git" segment``
  $RestOfPath = $PathSegments[($GitIndex)..$PathSegments.Length]`
`
  # Join the rest of the path segments by the "/" character``
  $RestOfPath = $RestOfPath -join "/"`
`
  # Append the rest of the path to the current directory``
  $AbsolutePath = Join-Path -Path $CurrentDirectory -ChildPath $RestOfPath`
`
  # Return the absolute path as a string``
  return "$AbsolutePath"`
}
copy-function 'translate-path'
function Translate-Path {`
  [CmdletBinding()]`
  param (`
    # The relative path`
    [Parameter(Mandatory = $true, ValueFromPipeline = $true)]`
    [string]`
    $RelativePath,`
`
    # The base directory``
    [Parameter(Mandatory = $true)]`
    [ValidateScript({Test-Path $_ -PathType Container})]`
    [string]`
    $BaseDirectory`
  )`
`
  # Split the relative path by the "/" character``
  $PathSegments = $RelativePath.Split("/")`
`
  # Set the current directory to the base directory``
  $CurrentDirectory = $BaseDirectory`
`
  # Loop through each path segment``
  foreach ($Segment in $PathSegments) {`
    # If the segment is "..", go up one level in the directory hierarchy``
    if ($Segment -eq "..") {`
      $CurrentDirectory = Split-Path -Path $CurrentDirectory -Parent`
    }`
    # If the segment is ".git", stop the loop and append the rest of the path``
    elseif ($Segment -eq ".git") {`
      break`
    }`
    # Otherwise, ignore the segment``
    else {`
      continue`
    }`
  }`
`
  # Get the index of the ".git" segment in the path segments``
  $GitIndex = [array]::IndexOf($PathSegments, ".git")`
`
  # Get the rest of the path segments after the ".git" segment``
  $RestOfPath = $PathSegments[($GitIndex)..$PathSegments.Length]`
`
  # Join the rest of the path segments by the "/" character``
  $RestOfPath = $RestOfPath -join "/"`
`
  # Append the rest of the path to the current directory``
  $AbsolutePath = Join-Path -Path $CurrentDirectory -ChildPath $RestOfPath`
`
  # Return the absolute path as a string``
  return "$AbsolutePath"`
}
copy-function 'translate-path'
copy-function translate-path
get-Function translate-path
get-Function Copy-Function
$PROFILE
addTo-Profile translate-path
(Get-ChildItem Function:$args).ScriptBlock.Ast.Extent
(Get-ChildItem Function:translate-path).ScriptBlock.Ast.Extent
(Get-ChildItem Function:translate-path).ScriptBlock.Ast.Extent.StartLineNumber
$extent = (Get-ChildItem Function:translate-path).ScriptBlock.Ast.Extent ; $extent.StartLineNumber
$extent = (Get-ChildItem Function:translate-path).ScriptBlock.Ast.Extent ; $extent.StartLineNumber;$extent.EndLineNumber
. 'B:\PF\Archive\ps1\git\Tokenization.ps1'
(Get-ChildItem Function:Tokenization).ScriptBlock.Ast
(Get-ChildItem Function:TokenizeCode).ScriptBlock.Ast
(Get-ChildItem Function:TokenizeCode).ScriptBlock.Ast.Extent
get-Function "*"
function get-AstExtent { (Get-ChildItem Function:$args).ScriptBlock.Ast.Extent }
get-AstExtent "*"
get-AstExtent "*" | ?{ $_.File ="B:\PF\Archive\ps1\git\Tokenization.ps1" }
get-AstExtent "*" | ?{ $_.File -eq "B:\PF\Archive\ps1\git\Tokenization.ps1" }
. 'B:\PF\Archive\ps1\git\Tokenization.ps1'
get-Functions 'B:\PF\Archive\ps1\git\Tokenization.ps1'
explorer $PROFILE
explorer $profileFolder
# Define a function that takes a path, startline, and endline as parameters
function Remove-Lines {`
    param (`
        [string]$Path,`
        [int]$StartLine,`
        [int]$EndLine`
    )`
`
    # Check if the path is valid and the file exists`
    if (-not (Test-Path -Path $Path -PathType Leaf)) {`
        Write-Error "Invalid path or file not found: $Path"`
        return`
    }`
`
    # Check if the startline and endline are positive integers`
    if ($StartLine -le 0 -or $EndLine -le 0) {`
        Write-Error "StartLine and EndLine must be positive integers"`
        return`
    }`
`
    # Check if the startline is less than or equal to the endline`
    if ($StartLine -gt $EndLine) {`
        Write-Error "StartLine must be less than or equal to EndLine"`
        return`
    }`
`
    # Read the file content as an array of lines`
    $Content = Get-Content -Path $Path`
`
    # Get the number of lines in the file`
    $LineCount = $Content.Count`
`
    # Check if the startline and endline are within the range of the file`
    if ($StartLine -gt $LineCount -or $EndLine -gt $LineCount) {`
        Write-Error "StartLine and EndLine must be within the range of the file"`
        return`
    }`
`
    # Remove the lines that are between the startline and endline (inclusive)`
    $Content = $Content[0..($StartLine - 2)] + $Content[($EndLine)..($LineCount - 1)]`
`
    # Write the modified content back to the file`
    Set-Content -Path $Path -Value $Content`
`
    # Write a message indicating success`
    Write-Output "Removed lines from $StartLine to $EndLine in file: $Path"`
}
Remove-Lines -Path 'B:\PF\Archive\ps1\git\Tokenization.ps1' -StartLine 2 -EndLine 11
# Define a function that takes a path and an extent value as parameters
function Get-ExtentInfo {`
    param (`
        [string]$Path,`
        [System.Management.Automation.Language.IScriptExtent]$Extent`
    )`
`
    # Check if the path is valid and the file exists`
    if (-not (Test-Path -Path $Path -PathType Leaf)) {`
        Write-Error "Invalid path or file not found: $Path"`
        return`
    }`
`
    # Check if the extent is valid`
    if (-not $Extent) {`
        Write-Error "Invalid extent value"`
        return`
    }`
`
    # Get the content of the file as a single string`
    $Content = Get-Content -Path $Path -Raw`
`
    # Get the start row and the end row of the extent using the Get-RowNumber function defined earlier`
    $StartRow = Get-RowNumber -Path $Path -Extent $Extent`
    $EndRow = Get-RowNumber -Path $Path -Extent $Extent.EndScriptPosition`
`
    # Get the start index and the end index of the extent in the content string`
    $StartIndex = $Extent.StartOffset`
    $EndIndex = $Extent.EndOffset`
`
    # Get the text of the extent by slicing the content string`
    $ExtentText = $Content.Substring($StartIndex, $EndIndex - $StartIndex + 1)`
`
    # Create a custom object with the properties: StartRow, EndRow, and ExtentText`
    $Object = [PSCustomObject]@{`
        StartRow = $StartRow`
        EndRow = $EndRow`
        ExtentText = $ExtentText`
    }`
`
    # Return the custom object`
    return $Object`
}
Get-ExtentInfo -Path 'B:\PF\Archive\ps1\git\Tokenization.ps1' -Extent (get-AstExtent 'TokenizeCode')
# Define a function that takes a path and an extent value as parameters`
function Get-RowNumber {`
    param (`
        [string]$Path,`
        [System.Management.Automation.Language.IScriptExtent]$Extent`
    )`
`
    # Check if the path is valid and the file exists`
    if (-not (Test-Path -Path $Path -PathType Leaf)) {`
        Write-Error "Invalid path or file not found: $Path"`
        return`
    }`
`
    # Check if the extent is valid`
    if (-not $Extent) {`
        Write-Error "Invalid extent value"`
        return`
    }`
`
    # Get the length of each line in the file`
    $LineLengths = Get-Content -Path $Path | Measure-Object -Property Length`
`
    # Initialize the row number and the character count`
    $RowNumber = 0`
    $CharCount = 0`
`
    # Loop through the line lengths until the character count exceeds the start column number of the extent`
    foreach ($LineLength in $LineLengths) {`
        # Increment the row number`
        $RowNumber++`
`
        # Add the line length and one (for the newline character) to the character count`
        $CharCount += $LineLength.Length + 1`
`
        # Check if the character count is greater than or equal to the start column number of the extent`
        if ($CharCount -ge $Extent.StartColumnNumber) {`
            # Return the row number`
            return $RowNumber`
        }`
    }`
`
    # If the loop ends without finding a match, return an error message`
    Write-Error "The extent value does not match any row in the file"`
}`

Get-ExtentInfo -Path 'B:\PF\Archive\ps1\git\Tokenization.ps1' -Extent (get-AstExtent 'TokenizeCode')
$Extent = (Get-ChildItem Function:"TokenizeCode").ScriptBlock.Ast.Extent
$Path = $Extent.File
Get-RowNumber -Path $Path -Extent $Extent
Get-RowNumber -Path $Path -Extent $Extent.EndScriptPosition
$Extent.EndScriptPosition
# Define a function that takes an IScriptPosition object as a parameter
function Convert-PositionToExtent {`
    param (`
        [System.Management.Automation.Language.IScriptPosition]$Position`
    )`
`
    # Check if the position is valid`
    if (-not $Position) {`
        Write-Error "Invalid position value"`
        return`
    }`
`
    # Create a new IScriptExtent object with the same properties as the position`
    $Extent = New-Object -TypeName System.Management.Automation.Language.ScriptExtent -ArgumentList @($Position, $Position)`
`
    # Return the extent object`
    return $Extent`
}# Define a function that takes an IScriptPosition object as a parameter
function Convert-PositionToExtent {`
    param (`
        [System.Management.Automation.Language.IScriptPosition]$Position`
    )`
`
    # Check if the position is valid`
    if (-not $Position) {`
        Write-Error "Invalid position value"`
        return`
    }`
`
    # Create a new IScriptExtent object with the same properties as the position`
    $Extent = New-Object -TypeName System.Management.Automation.Language.ScriptExtent -ArgumentList @($Position, $Position)`
`
    # Return the extent object`
    return $Extent`
}
$Extent = (Get-ChildItem Function:TokenizeCode).ScriptBlock.Ast.Extent
$Path = $Extent.File
$EndExtent = Convert-PositionToExtent -Position $Extent.EndScriptPosition
# Define a function that takes a path and four properties of an IScriptExtent object as parameters
function Get-ExtentInfo {`
    param (`
        [string]$Path,`
        [int]$StartLineNumber,`
        [int]$StartColumnNumber,`
        [int]$EndLineNumber,`
        [int]$EndColumnNumber`
    )`
`
    # Check if the path is valid and the file exists`
    if (-not (Test-Path -Path $Path -PathType Leaf)) {`
        Write-Error "Invalid path or file not found: $Path"`
        return`
    }`
`
    # Check if the properties are valid`
    if ($StartLineNumber -le 0 -or $StartColumnNumber -le 0 -or $EndLineNumber -le 0 -or $EndColumnNumber -le 0) {`
        Write-Error "The properties must be positive integers"`
        return`
    }`
`
    # Check if the start line and column are less than or equal to the end line and column`
    if ($StartLineNumber -gt $EndLineNumber -or ($StartLineNumber -eq $EndLineNumber -and $StartColumnNumber -gt $EndColumnNumber)) {`
        Write-Error "The start line and column must be less than or equal to the end line and column"`
        return`
    }`
`
    # Get the content of the file as a single string`
    $Content = Get-Content -Path $Path -Raw`
`
    # Get the start row and the end row of the extent using the Get-RowNumber function defined earlier`
    $StartRow = Get-RowNumber -Path $Path -Extent ([System.Management.Automation.Language.ScriptExtent]::new($StartLineNumber, $StartColumnNumber, $StartLineNumber, $StartColumnNumber))`
    $EndRow = Get-RowNumber -Path $Path -Extent ([System.Management.Automation.Language.ScriptExtent]::new($EndLineNumber, $EndColumnNumber, $EndLineNumber, $EndColumnNumber))`
`
    # Get the start index and the end index of the extent in the content string using a loop`
    $StartIndex = 0`
    $EndIndex = 0`
    $CurrentLine = 1`
    $CurrentColumn = 1`
`
    for ($i = 0; $i -lt $Content.Length; $i++) {`
        # Check if the current character is a newline character`
        if ($Content[$i] -eq "`n") {`
            # Increment the current line and reset the current column`
            $CurrentLine++`
            $CurrentColumn = 1`
        }`
        else {`
            # Increment the current column`
            $CurrentColumn++`
        }`
`
        # Check if the current line and column match the start line and column of the extent`
        if ($CurrentLine -eq $StartLineNumber -and $CurrentColumn -eq $StartColumnNumber) {`
            # Set the start index to the current index`
            $StartIndex = $i`
        }`
`
        # Check if the current line and column match the end line and column of the extent`
        if ($CurrentLine -eq $EndLineNumber -and $CurrentColumn -eq $EndColumnNumber) {`
            # Set the end index to the current index`
            $EndIndex = $i`
`
            # Break out of the loop`
            break`
        }`
    }`
`
    # Get the text of the extent by slicing the content string`
    $ExtentText = $Content.Substring($StartIndex, $EndIndex - $StartIndex + 1)`
`
    # Create a custom object with the properties: StartRow, EndRow, and ExtentText`
    $Object = [PSCustomObject]@{`
        StartRow = $StartRow`
        EndRow = $EndRow`
        ExtentText = $ExtentText`
    }`
`
    # Return the custom object`
    return $Object`
}
$e = (get-AstExtent 'TokenizeCode') ; Get-ExtentInfo -Path 'B:\PF\Archive\ps1\git\Tokenization.ps1' -StartLineNumber $e.StartLineNumber -StartColumnNumber $e.startColumnNumber -EndLineNumber $e.EndlineNumber -EndColumnNumber $e.EndColumnNumber
$e = (get-AstExtent 'TokenizeCode') ; $ee
$e = (get-AstExtent 'TokenizeCode') ; $e
# Define a function that takes a path and four properties of an IScriptExtent object as parameters
function Get-RowNumber {`
    param (`
        [string]$Path,`
        [int]$StartLineNumber,`
        [int]$StartColumnNumber,`
        [int]$EndLineNumber,`
        [int]$EndColumnNumber`
    )`
`
    # Check if the path is valid and the file exists`
    if (-not (Test-Path -Path $Path -PathType Leaf)) {`
        Write-Error "Invalid path or file not found: $Path"`
        return`
    }`
`
    # Check if the properties are valid`
    if ($StartLineNumber -le 0 -or $StartColumnNumber -le 0 -or $EndLineNumber -le 0 -or $EndColumnNumber -le 0) {`
        Write-Error "The properties must be positive integers"`
        return`
    }`
`
    # Check if the start line and column are less than or equal to the end line and column`
    if ($StartLineNumber -gt $EndLineNumber -or ($StartLineNumber -eq $EndLineNumber -and $StartColumnNumber -gt $EndColumnNumber)) {`
        Write-Error "The start line and column must be less than or equal to the end line and column"`
        return`
    }`
`
    # Get the length of each line in the file`
    $LineLengths = Get-Content -Path $Path | Measure-Object -Property Length`
`
    # Initialize the row number and the character count`
    $RowNumber = 0`
    $CharCount = 0`
`
    # Loop through the line lengths until the character count exceeds the start column number of the extent`
    foreach ($LineLength in $LineLengths) {`
        # Increment the row number`
        $RowNumber++`
`
        # Add the line length and one (for the newline character) to the character count`
        $CharCount += $LineLength.Length + 1`
`
        # Check if the character count is greater than or equal to the start column number of the extent`
        if ($CharCount -ge $StartColumnNumber) {`
            # Return the row number`
            return $RowNumber`
        }`
    }`
`
    # If the loop ends without finding a match, return an error message`
    Write-Error "The extent value does not match any row in the file"`
}
# Define a function that takes a path and four properties of an IScriptExtent object as parameters
function Get-ExtentInfo {`
    param (`
        [string]$Path,`
        [int]$StartLineNumber,`
        [int]$StartColumnNumber,`
        [int]$EndLineNumber,`
        [int]$EndColumnNumber`
    )`
`
    # Check if the path is valid and the file exists`
    if (-not (Test-Path -Path $Path -PathType Leaf)) {`
        Write-Error "Invalid path or file not found: $Path"`
        return`
    }`
`
    # Check if the properties are valid`
    if ($StartLineNumber -le 0 -or $StartColumnNumber -le 0 -or $EndLineNumber -le 0 -or $EndColumnNumber -le 0) {`
        Write-Error "The properties must be positive integers"`
        return`
    }`
`
    # Check if the start line and column are less than or equal to the end line and column`
    if ($StartLineNumber -gt $EndLineNumber -or ($StartLineNumber -eq $EndLineNumber -and $StartColumnNumber -gt $EndColumnNumber)) {`
        Write-Error "The start line and column must be less than or equal to the end line and column"`
        return`
    }`
`
    # Get the content of the file as a single string`
    $Content = Get-Content -Path $Path -Raw`
`
    # Get the start row and the end row of the extent using the Get-RowNumber function defined earlier`
    $StartRow = Get-RowNumber -Path $Path -StartLineNumber $StartLineNumber -StartColumnNumber $StartColumnNumber -EndLineNumber $StartLineNumber -EndColumnNumber $StartColumnNumber `
    $EndRow = Get-RowNumber -Path $Path -StartLineNumber $EndLineNumber -StartColumnNumber $EndColumnNumber -EndLineNumber $EndLineNumber -EndColumnNumber $EndColumnNumber `
`
    # Get the start index and the end index of the extent in the content string using a loop`
    $StartIndex = 0`
    $EndIndex = 0`
    $CurrentLine = 1`
    $CurrentColumn = 1`
`
    for ($i = 0; $i -lt $Content.Length; $i++) {`
        # Check if the current character is a newline character`
        if ($Content[$i] -eq "`n") {`
            # Increment the current line and reset the current column`
            $CurrentLine++`
            $CurrentColumn = 1`
        }`
        else {`
            # Increment the current column`
            $CurrentColumn++`
        }`
`
        # Check if the current line and column match the start line and column of the extent`
        if ($CurrentLine -eq $StartLineNumber -and $CurrentColumn -eq $StartColumnNumber) {`
            # Set the start index to the current index`
            $StartIndex = $i`
        }`
`
        # Check if the current line and column match the end line and column of the extent`
        if ($CurrentLine -eq $EndLineNumber -and $CurrentColumn -eq $EndColumnNumber) {`
            # Set the end index to the current index`
            $EndIndex = $i`
`
            # Break out of the loop`
            break`
        }`
    }`
`
    # Get the text of the extent by slicing the content string`
    $ExtentText = $Content.Substring($StartIndex, $EndIndex - $StartIndex + 1)`
`
    # Create a custom object with the properties: StartRow, EndRow, and ExtentText`
    $Object = [PSCustomObject]@{`
        StartRow = $StartRow`
        EndRow = $EndRow`
        ExtentText = $ExtentText`
    }`
`
    # Return the custom object`
    return $Object`
}
$e = (get-AstExtent 'TokenizeCode') ; Get-ExtentInfo -Path 'B:\PF\Archive\ps1\git\Tokenization.ps1' -StartLineNumber $e.StartLineNumber -StartColumnNumber $e.startColumnNumber -EndLineNumber $e.EndlineNumber -EndColumnNumber $e.EndColumnNumber
# Define a function that takes a path, a line number, and a switch parameter as parameters
function Get-RowNumber {`
    param (`
        [string]$Path,`
        [int]$LineNumber,`
        [switch]$EndLine`
    )`
`
    # Check if the path is valid and the file exists`
    if (-not (Test-Path -Path $Path -PathType Leaf)) {`
        Write-Error "Invalid path or file not found: $Path"`
        return`
    }`
`
    # Check if the line number is valid`
    if ($LineNumber -le 0) {`
        Write-Error "The line number must be a positive integer"`
        return`
    }`
`
    # Get the length of each line in the file`
    $LineLengths = Get-Content -Path $Path | Measure-Object -Property Length`
`
    # Initialize the row number and the character count`
    $RowNumber = 0`
    $CharCount = 0`
`
    # Loop through the line lengths until the character count exceeds the column number of the line`
    foreach ($LineLength in $LineLengths) {`
        # Increment the row number`
        $RowNumber++`
`
        # Add the line length and one (for the newline character) to the character count`
        $CharCount += $LineLength.Length + 1`
`
        # Check if the EndLine switch is specified`
        if ($EndLine) {`
            # Use the end column number of the line as the target column number`
            $ColumnNumber = $LineLength.Length + 1`
        }`
        else {`
            # Use the start column number of the line as the target column number`
            $ColumnNumber = 1`
        }`
`
        # Check if the character count is greater than or equal to the target column number of the line`
        if ($CharCount -ge $ColumnNumber) {`
            # Return the row number`
            return $RowNumber`
        }`
    }`
`
    # If the loop ends without finding a match, return an error message`
    Write-Error "The line number does not match any row in the file"`
}
# Define a function that takes an IScriptExtent object as a parameter
function Get-ExtentInfo {`
    param (`
        [System.Management.Automation.Language.IScriptExtent]$Extent`
    )`
`
    # Check if the extent is valid`
    if (-not $Extent) {`
        Write-Error "Invalid extent value"`
        return`
    }`
`
    # Get the path from the File property of the extent object`
    $Path = $Extent.File`
`
    # Check if the path is valid and the file exists`
    if (-not (Test-Path -Path $Path -PathType Leaf)) {`
        Write-Error "Invalid path or file not found: $Path"`
        return`
    }`
`
    # Get the start row and the end row of the extent using the Get-RowNumber function or its variants defined earlier`
    $StartRow = Get-RowNumber -Path $Path -StartLineNumber $Extent.StartLineNumber `
    $EndRow = Get-RowNumber -Path $Path -EndLineNumber $Extent.EndLineNumber -EndLine `
`
    # Get the start index and the end index of the extent in the content string using a loop`
    $StartIndex = 0`
    $EndIndex = 0`
    $CurrentLine = 1`
    $CurrentColumn = 1`
`
    for ($i = 0; $i -lt $Content.Length; $i++) {`
        # Check if the current character is a newline character`
        if ($Content[$i] -eq "`n") {`
            # Increment the current line and reset the current column`
            $CurrentLine++`
            $CurrentColumn = 1`
        }`
        else {`
            # Increment the current column`
            $CurrentColumn++`
        }`
`
        # Check if the current line and column match the start line and column of the extent`
        if ($CurrentLine -eq $StartLineNumber -and $CurrentColumn -eq $StartColumnNumber) {`
            # Set the start index to the current index`
            $StartIndex = $i`
        }`
`
        # Check if the current line and column match the end line and column of the extent`
        if ($CurrentLine -eq $EndLineNumber -and $CurrentColumn -eq $EndColumnNumber) {`
            # Set the end index to the current index`
            $EndIndex = $i`
`
            # Break out of the loop`
            break`
        }`
    }`
`
    # Get the text of the extent by slicing the content string`
    $ExtentText = $Content.Substring($StartIndex, $EndIndex - $StartIndex + 1)`
`
    # Create a custom object with the properties: StartRow, EndRow, and ExtentText`
    $Object = [PSCustomObject]@{`
        StartRow = $StartRow`
        EndRow = $EndRow`
        ExtentText = $ExtentText`
    }`
`
    # Return the custom object`
    return $Object`
}
$e = (get-AstExtent 'TokenizeCode') ; Get-ExtentInfo $e
copy-function Get-ExtentInfo
copy-function Get-RowNumber
get-Functions 'B:\PF\Archive\ps1\git\Tokenization.ps1'
get-AstExtent "*"
get-Functions 'B:\PF\Archive\ToGit\scoopbucket-presist\Documents\WindowsPowerShell\is-windows.ps1'
get-Functions 'B:\PF\Archive\ps1\git\Tokenization.ps1'
Import-module 'B:\PF\Archive\ps1\git\Tokenization.ps1'
get-Functions 'B:\PF\Archive\ps1\git\Tokenization.ps1'
get-Functions -path 'B:\PF\Archive\ps1\git\Tokenization.ps1'
get-Functions 'B:\PF\Archive\ps1\git\Tokenization.ps1'
get-Functions 'B:\PF\Archive\ToGit\scoopbucket-presist\Documents\WindowsPowerShell\is-windows.ps1'
Get-RowNumber 'B:\PF\Archive\ToGit\scoopbucket-presist\Documents\WindowsPowerShell\is-windows.ps1' -StartColumnNumber 3
Get-RowNumber 'B:\PF\Archive\ToGit\scoopbucket-presist\Documents\WindowsPowerShell\is-windows.ps1' -StartColumnNumber 3 -EndLine $false
explorer $profileFolder
$ErrorView = 'FullView'
explorer $profileFolder
Get-RowNumber 'B:\PF\Archive\ToGit\scoopbucket-presist\Documents\WindowsPowerShell\is-windows.ps1' -StartColumnNumber 3 -EndLine $false
Get-RowNumber 'B:\PF\Archive\ToGit\scoopbucket-presist\Documents\WindowsPowerShell\is-windows.ps1' -StartColumnNumber 3 -EndLine $true
get-Functions -path 'B:\PF\Archive\ps1\git\Tokenization.ps1'
Get-RowNumber 'B:\PF\Archive\ps1\git\Tokenization.ps1' -StartColumnNumber 9 -EndLine $true
get-Functions -path 'B:\PF\Archive\ps1\git\Tokenization.ps1'
function everything-GitRoots ($search)`
{`
    # Import the Everything module from https://github.com/volkanx/Everything`
    Import-Module Everything`
`
    # Search for files with extension .ps1 using Everything`
    $files = Invoke-Everything $search`
`
    # Initialize a hashtable to store the git root paths and the file paths`
    $gitRoots = @{}`
`
    # Loop through each file`
    foreach ($file in $files) {`
        # Get the full path of the file`
        $filePath = $file.FullPathName`
`
        # Try to get the git root path of the file using git rev-parse --show-toplevel`
        try {`
            $gitRoot = git -C $filePath rev-parse --show-toplevel`
        }`
        # Catch any error and assign it to the git root variable`
        catch {`
            $gitRoot = "error: $_"`
        }`
`
        # If the git root path is not in the hashtable, create a new entry with an empty array`
        if (-not $gitRoots.ContainsKey($gitRoot)) {`
            $gitRoots[$gitRoot] = @()`
        }`
`
        # Add the file path to the array of the corresponding git root path`
        $gitRoots[$gitRoot] += $filePath`
    }`
`
    # Loop through each git root path in the hashtable`
    foreach ($gitRoot in $gitRoots.Keys) {`
        # Print the git root path`
        Write-Host "Git root: $gitRoot"`
`
        # Print the file paths under the git root path`
        foreach ($filePath in $gitRoots[$gitRoot]) {`
            Write-Host "  - $filePath"`
        }`
    }`
}
everything-GitRoots 'join ext:ps1'
$ErrorView = fullview
function Set-ErrorView {`
    # Define the enum type for the ErrorView options`
    enum ErrorViewOption {`
        NormalView`
        CategoryView`
        ConciseView`
    }`
`
    # Use the parameter attribute to make it mandatory and validate the input`
    param(`
        [Parameter(Mandatory=$true)]`
        [ValidateSet("NormalView", "CategoryView", "ConciseView")]`
        [ErrorViewOption]$ErrorView`
    )`
`
    # Set the ErrorView variable to the specified value`
    $global:ErrorView = $ErrorView`
}
Set-PSReadLineKeyHandler -Key Tab -Function MenuComplete
function Set-ErrorView {`
    # Use the parameter attribute to make it mandatory and validate the input`
    param(`
        [Parameter(Mandatory=$true)]`
        [ValidateSet("NormalView", "CategoryView", "ConciseView")]`
        [string]$ErrorView`
    )`
`
    # Set the ErrorView variable to the specified value`
    $global:ErrorView = $ErrorView`
}
Set-ErrorView CategoryView
everything-GitRoots 'join ext:ps1'
Set-ErrorView NormalView
everything-GitRoots 'join ext:ps1'
function everything-GitRoots ($search)`
{`
       # Get the folder path from the user input`
    function invoke-Everything {`
        param(`
            [Parameter(Mandatory=$false)]`
            [string]$folderPath = "B:\PF\NoteTakingProjectFolder",`
            [Parameter(Mandatory=$false)]`
            [string]$filter = '<wholefilename:child:.git file:>|<wholefilename:child:.git folder:>',`
            [Parameter(Mandatory=$false)]`
            [switch]$notGlobal = $false`
        )`
    `
        install-module pseverything`
        Import-Module pseverything`
    `
        $folderPath = $folderPath.trim("\\")`
    `
        # Build a string with the parameters for Search-Everything`
        $searchString = "Search-Everything"`
        `
        if ($folderPath) {`
            $searchString += " -PathInclude '$folderPath'"`
        }`
    `
        if ($filter) {`
            $searchString += " -Filter '$filter'"`
        }`
    `
        if (!$notGlobal) {`
            $searchString += " -Global"`
        }`
    `
        # Invoke the string as a command and get the folders`
        $folders = Invoke-Expression $searchString`
    }`
    `
`
    # Search for files with extension .ps1 using Everything`
    $files = Invoke-Everything $search`
`
    # Initialize a hashtable to store the git root paths and the file paths`
    $gitRoots = @{}`
`
    # Loop through each file`
    foreach ($file in $files) {`
        # Get the full path of the file`
        $filePath = $file.FullPathName`
`
        # Try to get the git root path of the file using git rev-parse --show-toplevel`
        try {`
            $gitRoot = git -C $filePath rev-parse --show-toplevel`
        }`
        # Catch any error and assign it to the git root variable`
        catch {`
            $gitRoot = "error: $_"`
        }`
`
        # If the git root path is not in the hashtable, create a new entry with an empty array`
        if (-not $gitRoots.ContainsKey($gitRoot)) {`
            $gitRoots[$gitRoot] = @()`
        }`
`
        # Add the file path to the array of the corresponding git root path`
        $gitRoots[$gitRoot] += $filePath`
    }`
`
    # Loop through each git root path in the hashtable`
    foreach ($gitRoot in $gitRoots.Keys) {`
        # Print the git root path`
        Write-Host "Git root: $gitRoot"`
`
        # Print the file paths under the git root path`
        foreach ($filePath in $gitRoots[$gitRoot]) {`
            Write-Host "  - $filePath"`
        }`
    }`
}
everything-GitRoots 'join ext:ps1'
Copy-Function set-errorView
everything-GitRoots 'join ext:ps1'
function everything-GitRoots ($search)`
{`
       # Get the folder path from the user input`
    function invoke-Everything {`
        param(`
            [Parameter(Mandatory=$false)]`
            [string]$folderPath = "B:\PF\NoteTakingProjectFolder",`
            [Parameter(Mandatory=$false)]`
            [string]$filter = '<wholefilename:child:.git file:>|<wholefilename:child:.git folder:>',`
            [Parameter(Mandatory=$false)]`
            [switch]$notGlobal = $false`
        )`
    `
        #install-module pseverything`
        #Import-Module pseverything`
    `
        $folderPath = $folderPath.trim("\\")`
    `
        # Build a string with the parameters for Search-Everything`
        $searchString = "Search-Everything"`
        `
        if ($folderPath) {`
            $searchString += " -PathInclude '$folderPath'"`
        }`
    `
        if ($filter) {`
            $searchString += " -Filter '$filter'"`
        }`
    `
        if (!$notGlobal) {`
            $searchString += " -Global"`
        }`
    `
        # Invoke the string as a command and get the folders`
        $folders = Invoke-Expression $searchString`
    }`
    `
`
    # Search for files with extension .ps1 using Everything`
    $files = Invoke-Everything -filter $search`
`
    # Initialize a hashtable to store the git root paths and the file paths`
    $gitRoots = @{}`
`
    # Loop through each file`
    foreach ($file in $files) {`
        # Get the full path of the file`
        $filePath = $file.FullPathName`
`
        # Try to get the git root path of the file using git rev-parse --show-toplevel`
        try {`
            $gitRoot = git -C $filePath rev-parse --show-toplevel`
        }`
        # Catch any error and assign it to the git root variable`
        catch {`
            $gitRoot = "error: $_"`
        }`
`
        # If the git root path is not in the hashtable, create a new entry with an empty array`
        if (-not $gitRoots.ContainsKey($gitRoot)) {`
            $gitRoots[$gitRoot] = @()`
        }`
`
        # Add the file path to the array of the corresponding git root path`
        $gitRoots[$gitRoot] += $filePath`
    }`
`
    # Loop through each git root path in the hashtable`
    foreach ($gitRoot in $gitRoots.Keys) {`
        # Print the git root path`
        Write-Host "Git root: $gitRoot"`
`
        # Print the file paths under the git root path`
        foreach ($filePath in $gitRoots[$gitRoot]) {`
            Write-Host "  - $filePath"`
        }`
    }`
}function everything-GitRoots ($search)`
{`
       # Get the folder path from the user input`
    function invoke-Everything {`
        param(`
            [Parameter(Mandatory=$false)]`
            [string]$folderPath = "B:\PF\NoteTakingProjectFolder",`
            [Parameter(Mandatory=$false)]`
            [string]$filter = '<wholefilename:child:.git file:>|<wholefilename:child:.git folder:>',`
            [Parameter(Mandatory=$false)]`
            [switch]$notGlobal = $false`
        )`
    `
        #install-module pseverything`
        #Import-Module pseverything`
    `
        $folderPath = $folderPath.trim("\\")`
    `
        # Build a string with the parameters for Search-Everything`
        $searchString = "Search-Everything"`
        `
        if ($folderPath) {`
            $searchString += " -PathInclude '$folderPath'"`
        }`
    `
        if ($filter) {`
            $searchString += " -Filter '$filter'"`
        }`
    `
        if (!$notGlobal) {`
            $searchString += " -Global"`
        }`
    `
        # Invoke the string as a command and get the folders`
        $folders = Invoke-Expression $searchString`
    }`
    `
`
    # Search for files with extension .ps1 using Everything`
    $files = Invoke-Everything -filter $search`
`
    # Initialize a hashtable to store the git root paths and the file paths`
    $gitRoots = @{}`
`
    # Loop through each file`
    foreach ($file in $files) {`
        # Get the full path of the file`
        $filePath = $file.FullPathName`
`
        # Try to get the git root path of the file using git rev-parse --show-toplevel`
        try {`
            $gitRoot = git -C $filePath rev-parse --show-toplevel`
        }`
        # Catch any error and assign it to the git root variable`
        catch {`
            $gitRoot = "error: $_"`
        }`
`
        # If the git root path is not in the hashtable, create a new entry with an empty array`
        if (-not $gitRoots.ContainsKey($gitRoot)) {`
            $gitRoots[$gitRoot] = @()`
        }`
`
        # Add the file path to the array of the corresponding git root path`
        $gitRoots[$gitRoot] += $filePath`
    }`
`
    # Loop through each git root path in the hashtable`
    foreach ($gitRoot in $gitRoots.Keys) {`
        # Print the git root path`
        Write-Host "Git root: $gitRoot"`
`
        # Print the file paths under the git root path`
        foreach ($filePath in $gitRoots[$gitRoot]) {`
            Write-Host "  - $filePath"`
        }`
    }`
}
everything-GitRoots 'join ext:ps1'
function everything-GitRoots ($search)`
{`
       # Get the folder path from the user input`
    function invoke-Everything {`
        param(`
            [Parameter(Mandatory=$false)]`
            [string]$folderPath = "B:\PF\NoteTakingProjectFolder",`
            [Parameter(Mandatory=$false)]`
            [string]$filter = '<wholefilename:child:.git file:>|<wholefilename:child:.git folder:>',`
            [Parameter(Mandatory=$false)]`
            [switch]$notGlobal = $false`
        )`
    `
        #install-module pseverything`
        #Import-Module pseverything`
    `
        $folderPath = $folderPath.trim("\\")`
    `
        # Build a string with the parameters for Search-Everything`
        $searchString = "Search-Everything"`
        `
        if ($folderPath) {`
            $searchString += " -PathInclude '$folderPath'"`
        }`
    `
        if ($filter) {`
            $searchString += " -Filter '$filter'"`
        }`
    `
        if (!$notGlobal) {`
            $searchString += " -Global"`
        }`
    `
        # Invoke the string as a command and get the folders`
        Invoke-Expression $searchString`
    }`
    `
`
    # Search for files with extension .ps1 using Everything`
    $files = Invoke-Everything -filter $search`
`
    # Initialize a hashtable to store the git root paths and the file paths`
    $gitRoots = @{}`
`
    # Loop through each file`
    foreach ($file in $files) {`
        # Get the full path of the file`
        $filePath = $file.FullPathName`
`
        # Try to get the git root path of the file using git rev-parse --show-toplevel`
        try {`
            $gitRoot = git -C $filePath rev-parse --show-toplevel`
        }`
        # Catch any error and assign it to the git root variable`
        catch {`
            $gitRoot = "error: $_"`
        }`
`
        # If the git root path is not in the hashtable, create a new entry with an empty array`
        if (-not $gitRoots.ContainsKey($gitRoot)) {`
            $gitRoots[$gitRoot] = @()`
        }`
`
        # Add the file path to the array of the corresponding git root path`
        $gitRoots[$gitRoot] += $filePath`
    }`
`
    # Loop through each git root path in the hashtable`
    foreach ($gitRoot in $gitRoots.Keys) {`
        # Print the git root path`
        Write-Host "Git root: $gitRoot"`
`
        # Print the file paths under the git root path`
        foreach ($filePath in $gitRoots[$gitRoot]) {`
            Write-Host "  - $filePath"`
        }`
    }`
}
everything-GitRoots 'join ext:ps1'
invoke-everything -filter 'join ext:ps1'
function invoke-Everything {`
    param(`
        [Parameter(Mandatory=$false)]`
        [string]$folderPath = "B:\PF\NoteTakingProjectFolder",`
        [Parameter(Mandatory=$false)]`
        [string]$filter = '<wholefilename:child:.git file:>|<wholefilename:child:.git folder:>',`
        [Parameter(Mandatory=$false)]`
        [switch]$notGlobal = $false`
    )`
`
    #install-module pseverything`
    #Import-Module pseverything`
`
    $folderPath = $folderPath.trim("\\")`
`
    # Build a string with the parameters for Search-Everything`
    $searchString = "Search-Everything"`
    `
    if ($folderPath) {`
        $searchString += " -PathInclude '$folderPath'"`
    }`
`
    if ($filter) {`
        $searchString += " -Filter '$filter'"`
    }`
`
    if (!$notGlobal) {`
        $searchString += " -Global"`
    }`
`
    # Invoke the string as a command and get the folders`
    Invoke-Expression $searchString`
}
function everything-GitRoots ($search)`
{`
       # Get the folder path from the user input`
    `
    `
`
    # Search for files with extension .ps1 using Everything`
    $files = Invoke-Everything -filter $search`
`
    # Initialize a hashtable to store the git root paths and the file paths`
    $gitRoots = @{}`
`
    # Loop through each file`
    foreach ($file in $files) {`
        # Get the full path of the file`
        $filePath = $file.FullPathName`
`
        # Try to get the git root path of the file using git rev-parse --show-toplevel`
        try {`
            $gitRoot = git -C $filePath rev-parse --show-toplevel`
        }`
        # Catch any error and assign it to the git root variable`
        catch {`
            $gitRoot = "error: $_"`
        }`
`
        # If the git root path is not in the hashtable, create a new entry with an empty array`
        if (-not $gitRoots.ContainsKey($gitRoot)) {`
            $gitRoots[$gitRoot] = @()`
        }`
`
        # Add the file path to the array of the corresponding git root path`
        $gitRoots[$gitRoot] += $filePath`
    }`
`
    # Loop through each git root path in the hashtable`
    foreach ($gitRoot in $gitRoots.Keys) {`
        # Print the git root path`
        Write-Host "Git root: $gitRoot"`
`
        # Print the file paths under the git root path`
        foreach ($filePath in $gitRoots[$gitRoot]) {`
            Write-Host "  - $filePath"`
        }`
    }`
}
invoke-everything -filter 'join ext:ps1'
invoke-everything -folderPath 'B:\PF\'  -filter 'join ext:ps1'
function invoke-Everything {`
    param(`
        [Parameter(Mandatory=$false)]`
        [string]$folderPath = "B:\PF\NoteTakingProjectFolder",`
        [Parameter(Mandatory=$false)]`
        [string]$filter = '<wholefilename:child:.git file:>|<wholefilename:child:.git folder:>',`
        [Parameter(Mandatory=$false)]`
        [switch]$notGlobal = $false`
    )`
`
    #install-module pseverything`
    #Import-Module pseverything`
`
    $folderPath = $folderPath.trim("\\")`
`
    # Build a string with the parameters for Search-Everything`
    $searchString = "Search-Everything"`
    `
    if ($folderPath) {`
        $searchString += " -PathInclude '$folderPath'"`
    }`
`
    if ($filter) {`
        $searchString += " -Filter '$filter'"`
    }`
`
    if (!$notGlobal) {`
        $searchString += " -Global"`
    }`
`
    # Invoke the string as a command and get the folders`
    Invoke-Expression $searchString`
}
function everything-GitRoots ($pathx,$search)`
{`
       # Get the folder path from the user input`
    `
    `
`
    # Search for files with extension .ps1 using Everything`
    $files = Invoke-Everything -folderPath $pathx -filter $search`
`
    # Initialize a hashtable to store the git root paths and the file paths`
    $gitRoots = @{}`
`
    # Loop through each file`
    foreach ($file in $files) {`
        # Get the full path of the file`
        $filePath = $file.FullPathName`
`
        # Try to get the git root path of the file using git rev-parse --show-toplevel`
        try {`
            $gitRoot = git -C $filePath rev-parse --show-toplevel`
        }`
        # Catch any error and assign it to the git root variable`
        catch {`
            $gitRoot = "error: $_"`
        }`
`
        # If the git root path is not in the hashtable, create a new entry with an empty array`
        if (-not $gitRoots.ContainsKey($gitRoot)) {`
            $gitRoots[$gitRoot] = @()`
        }`
`
        # Add the file path to the array of the corresponding git root path`
        $gitRoots[$gitRoot] += $filePath`
    }`
`
    # Loop through each git root path in the hashtable`
    foreach ($gitRoot in $gitRoots.Keys) {`
        # Print the git root path`
        Write-Host "Git root: $gitRoot"`
`
        # Print the file paths under the git root path`
        foreach ($filePath in $gitRoots[$gitRoot]) {`
            Write-Host "  - $filePath"`
        }`
    }`
}
everything-GitRoots -search 'join ext:ps1' -pathx 'B:\pf\'
function invoke-Everything {`
    param(`
        [Parameter(Mandatory=$false)]`
        [string]$folderPath = "B:\PF\NoteTakingProjectFolder",`
        [Parameter(Mandatory=$false)]`
        [string]$filter = '<wholefilename:child:.git file:>|<wholefilename:child:.git folder:>',`
        [Parameter(Mandatory=$false)]`
        [switch]$notGlobal = $false`
    )`
`
    #install-module pseverything`
    #Import-Module pseverything`
`
    $folderPath = $folderPath.trim("\\")`
`
    # Build a string with the parameters for Search-Everything`
    $searchString = "Search-Everything"`
    `
    if ($folderPath) {`
        $searchString += " -PathInclude '$folderPath'"`
    }`
`
    if ($filter) {`
        $searchString += " -Filter '$filter'"`
    }`
`
    if (!$notGlobal) {`
        $searchString += " -Global"`
    }`
`
    # Invoke the string as a command and get the folders`
    Invoke-Expression $searchString`
}
function everything-GitRoots ($pathx,$search)`
{`
       # Get the folder path from the user input`
    `
    `
`
    # Search for files with extension .ps1 using Everything`
    $files = Invoke-Everything -folderPath $pathx -filter $search`
`
    # Initialize a hashtable to store the git root paths and the file paths`
    $gitRoots = @{}`
`
    # Loop through each file`
    foreach ($file in $files) {`
        # Get the full path of the file`
        $filePath = $file.FullPathName`
`
        # Try to get the git root path of the file using git rev-parse --show-toplevel`
        try {`
            $gitRoot = invoke-expression "git -C $filePath rev-parse --show-toplevel"`
`
            # If the git root path is not in the hashtable, create a new entry with an empty array`
            if (-not $gitRoots.ContainsKey($gitRoot)) {`
                $gitRoots[$gitRoot] = @()`
            }`
`
            # Add the file path to the array of the corresponding git root path`
            $gitRoots[$gitRoot] += $filePath`
        }`
        # Catch any error and assign it to the git root variable`
        catch {`
            Write-Error $filePath`
            $gitRoot = "error: $_"`
        }`
`
        `
    }`
`
    # Loop through each git root path in the hashtable`
    foreach ($gitRoot in $gitRoots.Keys) {`
        # Print the git root path`
        Write-Host "Git root: $gitRoot"`
`
        # Print the file paths under the git root path`
        foreach ($filePath in $gitRoots[$gitRoot]) {`
            Write-Host "  - $filePath"`
        }`
    }`
}
everything-GitRoots -search 'join ext:ps1' -pathx 'B:\pf\'
function invoke-Everything {`
    param(`
        [Parameter(Mandatory=$false)]`
        [string]$folderPath = "B:\PF\NoteTakingProjectFolder",`
        [Parameter(Mandatory=$false)]`
        [string]$filter = '<wholefilename:child:.git file:>|<wholefilename:child:.git folder:>',`
        [Parameter(Mandatory=$false)]`
        [switch]$notGlobal = $false`
    )`
`
    #install-module pseverything`
    #Import-Module pseverything`
`
    $folderPath = $folderPath.trim("\\")`
`
    # Build a string with the parameters for Search-Everything`
    $searchString = "Search-Everything"`
    `
    if ($folderPath) {`
        $searchString += " -PathInclude '$folderPath'"`
    }`
`
    if ($filter) {`
        $searchString += " -Filter '$filter'"`
    }`
`
    if (!$notGlobal) {`
        $searchString += " -Global"`
    }`
`
    # Invoke the string as a command and get the folders`
    Invoke-Expression $searchString`
}
function everything-GitRoots ($pathx,$search)`
{`
       # Get the folder path from the user input`
    `
    `
`
    # Search for files with extension .ps1 using Everything`
    $files = Invoke-Everything -folderPath $pathx -filter $search`
`
    # Initialize a hashtable to store the git root paths and the file paths`
    $gitRoots = @{}`
`
    # Loop through each file`
    foreach ($file in $files) {`
        # Get the full path of the file`
        $filePath = $file.FullPathName`
`
        # Try to get the git root path of the file using git rev-parse --show-toplevel`
        try {`
            $gitRoot = invoke-expression "git -C '$filePath' rev-parse --show-toplevel"`
`
            # If the git root path is not in the hashtable, create a new entry with an empty array`
            if (-not $gitRoots.ContainsKey($gitRoot)) {`
                $gitRoots[$gitRoot] = @()`
            }`
`
            # Add the file path to the array of the corresponding git root path`
            $gitRoots[$gitRoot] += $filePath`
        }`
        # Catch any error and assign it to the git root variable`
        catch {`
            Write-Error $filePath`
            $gitRoot = "error: $_"`
        }`
`
        `
    }`
`
    # Loop through each git root path in the hashtable`
    foreach ($gitRoot in $gitRoots.Keys) {`
        # Print the git root path`
        Write-Host "Git root: $gitRoot"`
`
        # Print the file paths under the git root path`
        foreach ($filePath in $gitRoots[$gitRoot]) {`
            Write-Host "  - $filePath"`
        }`
    }`
}
function invoke-Everything {`
    param(`
        [Parameter(Mandatory=$false)]`
        [string]$folderPath = "B:\PF\NoteTakingProjectFolder",`
        [Parameter(Mandatory=$false)]`
        [string]$filter = '<wholefilename:child:.git file:>|<wholefilename:child:.git folder:>',`
        [Parameter(Mandatory=$false)]`
        [switch]$notGlobal = $false`
    )`
`
    #install-module pseverything`
    #Import-Module pseverything`
`
    $folderPath = $folderPath.trim("\\")`
`
    # Build a string with the parameters for Search-Everything`
    $searchString = "Search-Everything"`
    `
    if ($folderPath) {`
        $searchString += " -PathInclude '$folderPath'"`
    }`
`
    if ($filter) {`
        $searchString += " -Filter '$filter'"`
    }`
`
    if (!$notGlobal) {`
        $searchString += " -Global"`
    }`
`
    # Invoke the string as a command and get the folders`
    Invoke-Expression $searchString`
}
function everything-GitRoots ($pathx,$search)`
{`
       # Get the folder path from the user input`
    `
    `
`
    # Search for files with extension .ps1 using Everything`
    $files = Invoke-Everything -folderPath $pathx -filter $search`
`
    # Initialize a hashtable to store the git root paths and the file paths`
    $gitRoots = @{}`
`
    # Loop through each file`
    foreach ($file in $files) {`
        # Get the full path of the file`
        $filePath = $file.FullPathName`
`
        # Try to get the git root path of the file using git rev-parse --show-toplevel`
        try {`
            $gitRoot = invoke-expression "git -C '$filePath' rev-parse --show-toplevel"`
`
            # If the git root path is not in the hashtable, create a new entry with an empty array`
            if (-not $gitRoots.ContainsKey($gitRoot)) {`
                $gitRoots[$gitRoot] = @()`
            }`
`
            # Add the file path to the array of the corresponding git root path`
            $gitRoots[$gitRoot] += $filePath`
        }`
        # Catch any error and assign it to the git root variable`
        catch {`
            Write-Error $filePath`
            $gitRoot = "error: $_"`
        }`
`
        `
    }`
`
    # Loop through each git root path in the hashtable`
    foreach ($gitRoot in $gitRoots.Keys) {`
        # Print the git root path`
        Write-Host "Git root: $gitRoot"`
`
        # Print the file paths under the git root path`
        foreach ($filePath in $gitRoots[$gitRoot]) {`
            Write-Host "  - $filePath"`
        }`
    }`
}
everything-GitRoots -search 'join ext:ps1' -pathx 'B:\pf\'
function invoke-Everything {`
    param(`
        [Parameter(Mandatory=$false)]`
        [string]$folderPath = "B:\PF\NoteTakingProjectFolder",`
        [Parameter(Mandatory=$false)]`
        [string]$filter = '<wholefilename:child:.git file:>|<wholefilename:child:.git folder:>',`
        [Parameter(Mandatory=$false)]`
        [switch]$notGlobal = $false`
    )`
`
    #install-module pseverything`
    #Import-Module pseverything`
`
    $folderPath = $folderPath.trim("\\")`
`
    # Build a string with the parameters for Search-Everything`
    $searchString = "Search-Everything"`
    `
    if ($folderPath) {`
        $searchString += " -PathInclude '$folderPath'"`
    }`
`
    if ($filter) {`
        $searchString += " -Filter '$filter'"`
    }`
`
    if (!$notGlobal) {`
        $searchString += " -Global"`
    }`
`
    # Invoke the string as a command and get the folders`
    Invoke-Expression $searchString`
}
function everything-GitRoots ($pathx,$search)`
{`
       # Get the folder path from the user input`
    `
    `
`
    # Search for files with extension .ps1 using Everything`
    $files = Invoke-Everything -folderPath $pathx -filter $search`
`
    # Initialize a hashtable to store the git root paths and the file paths`
    $gitRoots = @{}`
`
    # Loop through each file`
    foreach ($file in $files) {`
        # Get the full path of the file`
        $filePath = $file.FullPathName`
`
        # Try to get the git root path of the file using git rev-parse --show-toplevel`
        try {`
            $expr = "git -C '$filePath' rev-parse --show-toplevel"`
            $gitRoot = invoke-expression $expr`
`
            # If the git root path is not in the hashtable, create a new entry with an empty array`
            if (-not $gitRoots.ContainsKey($gitRoot)) {`
                $gitRoots[$gitRoot] = @()`
            }`
`
            # Add the file path to the array of the corresponding git root path`
            $gitRoots[$gitRoot] += $filePath`
        }`
        # Catch any error and assign it to the git root variable`
        catch {`
            write-error $expr`
            Write-Error $filePath`
            $gitRoot = "error: $_"`
        }`
`
        `
    }`
`
    # Loop through each git root path in the hashtable`
    foreach ($gitRoot in $gitRoots.Keys) {`
        # Print the git root path`
        Write-Host "Git root: $gitRoot"`
`
        # Print the file paths under the git root path`
        foreach ($filePath in $gitRoots[$gitRoot]) {`
            Write-Host "  - $filePath"`
        }`
    }`
}
everything-GitRoots -search 'join ext:ps1' -pathx 'B:\pf\'
function invoke-Everything {`
    param(`
        [Parameter(Mandatory=$false)]`
        [string]$folderPath = "B:\PF\NoteTakingProjectFolder",`
        [Parameter(Mandatory=$false)]`
        [string]$filter = '<wholefilename:child:.git file:>|<wholefilename:child:.git folder:>',`
        [Parameter(Mandatory=$false)]`
        [switch]$notGlobal = $false`
    )`
`
    #install-module pseverything`
    #Import-Module pseverything`
`
    $folderPath = $folderPath.trim("\\")`
`
    # Build a string with the parameters for Search-Everything`
    $searchString = "Search-Everything"`
    `
    if ($folderPath) {`
        $searchString += " -PathInclude '$folderPath'"`
    }`
`
    if ($filter) {`
        $searchString += " -Filter '$filter'"`
    }`
`
    if (!$notGlobal) {`
        $searchString += " -Global"`
    }`
`
    # Invoke the string as a command and get the folders`
    Invoke-Expression $searchString`
}
function everything-GitRoots ($pathx,$search)`
{`
       # Get the folder path from the user input`
    `
    `
`
    # Search for files with extension .ps1 using Everything`
    $files = @(Invoke-Everything -folderPath $pathx -filter $search)`
`
    # Initialize a hashtable to store the git root paths and the file paths`
    $gitRoots = @{}`
`
    # Loop through each file`
    foreach ($file in $files) {`
        # Get the full path of the file`
        $filePath = $file.FullPathName`
`
        # Try to get the git root path of the file using git rev-parse --show-toplevel`
        try {`
            $expr = "git -C '$filePath' rev-parse --show-toplevel"`
            $gitRoot = invoke-expression $expr`
`
            # If the git root path is not in the hashtable, create a new entry with an empty array`
            if (-not $gitRoots.ContainsKey($gitRoot)) {`
                $gitRoots[$gitRoot] = @()`
            }`
`
            # Add the file path to the array of the corresponding git root path`
            $gitRoots[$gitRoot] += $filePath`
        }`
        # Catch any error and assign it to the git root variable`
        catch {`
            write-error $expr`
            Write-Error $filePath`
            $gitRoot = "error: $_"`
        }`
`
        `
    }`
`
    # Loop through each git root path in the hashtable`
    foreach ($gitRoot in $gitRoots.Keys) {`
        # Print the git root path`
        Write-Host "Git root: $gitRoot"`
`
        # Print the file paths under the git root path`
        foreach ($filePath in $gitRoots[$gitRoot]) {`
            Write-Host "  - $filePath"`
        }`
    }`
}
everything-GitRoots -search 'join ext:ps1' -pathx 'B:\pf\'
function invoke-Everything {`
    param(`
        [Parameter(Mandatory=$false)]`
        [string]$folderPath = "B:\PF\NoteTakingProjectFolder",`
        [Parameter(Mandatory=$false)]`
        [string]$filter = '<wholefilename:child:.git file:>|<wholefilename:child:.git folder:>',`
        [Parameter(Mandatory=$false)]`
        [switch]$notGlobal = $false`
    )`
`
    #install-module pseverything`
    #Import-Module pseverything`
`
    $folderPath = $folderPath.trim("\\")`
`
    # Build a string with the parameters for Search-Everything`
    $searchString = "Search-Everything"`
    `
    if ($folderPath) {`
        $searchString += " -PathInclude '$folderPath'"`
    }`
`
    if ($filter) {`
        $searchString += " -Filter '$filter'"`
    }`
`
    if (!$notGlobal) {`
        $searchString += " -Global"`
    }`
    $lines = @()`
    # Invoke the string as a command and get the folders`
    $lines =  Invoke-Expression $searchString`
    return $lines`
}
function everything-GitRoots ($pathx,$search)`
{`
       # Get the folder path from the user input`
    `
    `
`
    # Search for files with extension .ps1 using Everything`
    $files = @(Invoke-Everything -folderPath $pathx -filter $search)`
`
    # Initialize a hashtable to store the git root paths and the file paths`
    $gitRoots = @{}`
`
    # Loop through each file`
    foreach ($file in $files) {`
        # Get the full path of the file`
        $filePath = $file.FullPathName`
`
        # Try to get the git root path of the file using git rev-parse --show-toplevel`
        try {`
            $expr = "git -C '$filePath' rev-parse --show-toplevel"`
            $gitRoot = invoke-expression $expr`
`
            # If the git root path is not in the hashtable, create a new entry with an empty array`
            if (-not $gitRoots.ContainsKey($gitRoot)) {`
                $gitRoots[$gitRoot] = @()`
            }`
`
            # Add the file path to the array of the corresponding git root path`
            $gitRoots[$gitRoot] += $filePath`
        }`
        # Catch any error and assign it to the git root variable`
        catch {`
            write-error $expr`
            Write-Error $filePath`
            $gitRoot = "error: $_"`
        }`
`
        `
    }`
`
    # Loop through each git root path in the hashtable`
    foreach ($gitRoot in $gitRoots.Keys) {`
        # Print the git root path`
        Write-Host "Git root: $gitRoot"`
`
        # Print the file paths under the git root path`
        foreach ($filePath in $gitRoots[$gitRoot]) {`
            Write-Host "  - $filePath"`
        }`
    }`
}function invoke-Everything {`
    param(`
        [Parameter(Mandatory=$false)]`
        [string]$folderPath = "B:\PF\NoteTakingProjectFolder",`
        [Parameter(Mandatory=$false)]`
        [string]$filter = '<wholefilename:child:.git file:>|<wholefilename:child:.git folder:>',`
        [Parameter(Mandatory=$false)]`
        [switch]$notGlobal = $false`
    )`
`
    #install-module pseverything`
    #Import-Module pseverything`
`
    $folderPath = $folderPath.trim("\\")`
`
    # Build a string with the parameters for Search-Everything`
    $searchString = "Search-Everything"`
    `
    if ($folderPath) {`
        $searchString += " -PathInclude '$folderPath'"`
    }`
`
    if ($filter) {`
        $searchString += " -Filter '$filter'"`
    }`
`
    if (!$notGlobal) {`
        $searchString += " -Global"`
    }`
    $lines = @()`
    # Invoke the string as a command and get the folders`
    $lines =  Invoke-Expression $searchString`
    return $lines`
}
function everything-GitRoots ($pathx,$search)`
{`
       # Get the folder path from the user input`
    `
    `
`
    # Search for files with extension .ps1 using Everything`
    $files = @(Invoke-Everything -folderPath $pathx -filter $search)`
`
    # Initialize a hashtable to store the git root paths and the file paths`
    $gitRoots = @{}`
`
    # Loop through each file`
    foreach ($file in $files) {`
        # Get the full path of the file`
        $filePath = $file.FullPathName`
`
        # Try to get the git root path of the file using git rev-parse --show-toplevel`
        try {`
            $expr = "git -C '$filePath' rev-parse --show-toplevel"`
            $gitRoot = invoke-expression $expr`
`
            # If the git root path is not in the hashtable, create a new entry with an empty array`
            if (-not $gitRoots.ContainsKey($gitRoot)) {`
                $gitRoots[$gitRoot] = @()`
            }`
`
            # Add the file path to the array of the corresponding git root path`
            $gitRoots[$gitRoot] += $filePath`
        }`
        # Catch any error and assign it to the git root variable`
        catch {`
            write-error $expr`
            Write-Error $filePath`
            $gitRoot = "error: $_"`
        }`
`
        `
    }`
`
    # Loop through each git root path in the hashtable`
    foreach ($gitRoot in $gitRoots.Keys) {`
        # Print the git root path`
        Write-Host "Git root: $gitRoot"`
`
        # Print the file paths under the git root path`
        foreach ($filePath in $gitRoots[$gitRoot]) {`
            Write-Host "  - $filePath"`
        }`
    }`
}
everything-GitRoots -search 'join ext:ps1' -pathx 'B:\pf\'
Set-ErrorView NormalView
Resize-VHD -Path 'U:\OtherDrives\side_profile-40g.vhdx' -SizeBytes 60GB
Resize-VHD -h
Resize-VHD -help
Resize-VHD --help
Resize-VHD --h
man Resize-VHD 
get-help Resize-vhd -examples
Resize-VHD -Path 'U:\OtherDrives\side_profile-40g.vhdx' -SizeBytes 60GB -WhatIf
Resize-VHD -Path 'U:\OtherDrives\side_profile-40g.vhdx' -SizeBytes 60GB
invoke-Everything -search 'join ext:ps1' -pathx 'B:\pf\'
invoke-Everything -filter 'join ext:ps1' -folderPath 'B:\pf\'
invoke-Everything -filter 'join ext:ps1' -folderPath 'B:\pf\' | %{ $_ | convert-path }
invoke-Everything -filter 'join ext:ps1' -folderPath 'B:\pf\' | %{ $_ | convert-path } | Measure-Object
invoke-Everything -filter 'join ext:ps1' -folderPath 'B:\pf\' | %{ $_ | Get-Item } | Measure-Object
invoke-Everything -filter 'join ext:ps1' -folderPath 'B:\pf\' | %{ $_ | Get-Item }
function invoke-Everything {`
    param(`
        [Parameter(Mandatory=$false)]`
        [string]$folderPath = "B:\PF\NoteTakingProjectFolder",`
        [Parameter(Mandatory=$false)]`
        [string]$filter = '<wholefilename:child:.git file:>|<wholefilename:child:.git folder:>',`
        [Parameter(Mandatory=$false)]`
        [switch]$notGlobal = $false`
    )`
`
    #install-module pseverything`
    #Import-Module pseverything`
`
    $folderPath = $folderPath.trim("\\")`
`
    # Build a string with the parameters for Search-Everything`
    $searchString = "Search-Everything"`
    `
    if ($folderPath) {`
        $searchString += " -PathInclude '$folderPath'"`
    }`
`
    if ($filter) {`
        $searchString += " -Filter '$filter'"`
    }`
`
    if (!$notGlobal) {`
        $searchString += " -Global"`
    }`
    $lines = @()`
    # Invoke the string as a command and get the folders`
    $lines =  Invoke-Expression $searchString`
    return $lines`
}
function everything-GitRoots ($pathx,$search)`
{`
       # Get the folder path from the user input`
    `
    `
`
    # Search for files with extension .ps1 using Everything`
    $files = Invoke-Everything -folderPath $pathx -filter $search  | %{ $_ | Get-Item }`
`
    # Initialize a hashtable to store the git root paths and the file paths`
    $gitRoots = @{}`
`
    # Loop through each file`
    foreach ($file in $files) {`
        # Get the full path of the file`
        $filePath = $file.FullPathName`
`
        # Try to get the git root path of the file using git rev-parse --show-toplevel`
        try {`
            $expr = "git -C '$filePath' rev-parse --show-toplevel"`
            $gitRoot = invoke-expression $expr`
`
            # If the git root path is not in the hashtable, create a new entry with an empty array`
            if (-not $gitRoots.ContainsKey($gitRoot)) {`
                $gitRoots[$gitRoot] = @()`
            }`
`
            # Add the file path to the array of the corresponding git root path`
            $gitRoots[$gitRoot] += $filePath`
        }`
        # Catch any error and assign it to the git root variable`
        catch {`
            write-error $expr`
            Write-Error $filePath`
            $gitRoot = "error: $_"`
        }`
`
        `
    }`
`
    # Loop through each git root path in the hashtable`
    foreach ($gitRoot in $gitRoots.Keys) {`
        # Print the git root path`
        Write-Host "Git root: $gitRoot"`
`
        # Print the file paths under the git root path`
        foreach ($filePath in $gitRoots[$gitRoot]) {`
            Write-Host "  - $filePath"`
        }`
    }`
}
everything-GitRoots -search 'join ext:ps1' -pathx 'B:\pf\'
function invoke-Everything {`
    param(`
        [Parameter(Mandatory=$false)]`
        [string]$folderPath = "B:\PF\NoteTakingProjectFolder",`
        [Parameter(Mandatory=$false)]`
        [string]$filter = '<wholefilename:child:.git file:>|<wholefilename:child:.git folder:>',`
        [Parameter(Mandatory=$false)]`
        [switch]$notGlobal = $false`
    )`
`
    #install-module pseverything`
    #Import-Module pseverything`
`
    $folderPath = $folderPath.trim("\\")`
`
    # Build a string with the parameters for Search-Everything`
    $searchString = "Search-Everything"`
    `
    if ($folderPath) {`
        $searchString += " -PathInclude '$folderPath'"`
    }`
`
    if ($filter) {`
        $searchString += " -Filter '$filter'"`
    }`
`
    if (!$notGlobal) {`
        $searchString += " -Global"`
    }`
    $lines = @()`
    # Invoke the string as a command and get the folders`
    $lines =  Invoke-Expression $searchString`
    return $lines`
}
function everything-GitRoots ($pathx,$search)`
{`
       # Get the folder path from the user input`
    `
    `
`
    # Search for files with extension .ps1 using Everything`
    $files = Invoke-Everything -folderPath $pathx -filter $search  | %{ $_ | Get-Item }`
`
    # Initialize a hashtable to store the git root paths and the file paths`
    $gitRoots = @{}`
    Write-Output ($files | Measure-Object)`
    # Loop through each file`
    foreach ($file in $files) {`
        # Get the full path of the file`
        $filePath = $file.FullPathName`
`
        # Try to get the git root path of the file using git rev-parse --show-toplevel`
        try {`
            $expr = "git -C '$filePath' rev-parse --show-toplevel"`
            $gitRoot = invoke-expression $expr`
`
            # If the git root path is not in the hashtable, create a new entry with an empty array`
            if (-not $gitRoots.ContainsKey($gitRoot)) {`
                $gitRoots[$gitRoot] = @()`
            }`
`
            # Add the file path to the array of the corresponding git root path`
            $gitRoots[$gitRoot] += $filePath`
        }`
        # Catch any error and assign it to the git root variable`
        catch {`
            write-error $expr`
            Write-Error $filePath`
            $gitRoot = "error: $_"`
        }`
`
        `
    }`
`
    # Loop through each git root path in the hashtable`
    foreach ($gitRoot in $gitRoots.Keys) {`
        # Print the git root path`
        Write-Host "Git root: $gitRoot"`
`
        # Print the file paths under the git root path`
        foreach ($filePath in $gitRoots[$gitRoot]) {`
            Write-Host "  - $filePath"`
        }`
    }`
}
everything-GitRoots -search 'join ext:ps1' -pathx 'B:\pf\'
function invoke-Everything {`
    param(`
        [Parameter(Mandatory=$false)]`
        [string]$folderPath = "B:\PF\NoteTakingProjectFolder",`
        [Parameter(Mandatory=$false)]`
        [string]$filter = '<wholefilename:child:.git file:>|<wholefilename:child:.git folder:>',`
        [Parameter(Mandatory=$false)]`
        [switch]$notGlobal = $false`
    )`
`
    #install-module pseverything`
    #Import-Module pseverything`
`
    $folderPath = $folderPath.trim("\\")`
`
    # Build a string with the parameters for Search-Everything`
    $searchString = "Search-Everything"`
    `
    if ($folderPath) {`
        $searchString += " -PathInclude '$folderPath'"`
    }`
`
    if ($filter) {`
        $searchString += " -Filter '$filter'"`
    }`
`
    if (!$notGlobal) {`
        $searchString += " -Global"`
    }`
    $lines = @()`
    # Invoke the string as a command and get the folders`
    $lines =  Invoke-Expression $searchString`
    return $lines`
}
function everything-GitRoots ($pathx,$search)`
{`
       # Get the folder path from the user input`
    `
    `
`
    # Search for files with extension .ps1 using Everything`
    $files = Invoke-Everything -folderPath $pathx -filter $search  | %{ $_ | Get-Item }`
`
    # Initialize a hashtable to store the git root paths and the file paths`
    $gitRoots = @{}`
    Write-Output ($files | Measure-Object)`
    # Loop through each file`
    foreach ($file in $files) {`
        # Get the full path of the file`
        $filePath = $file.Parent`
`
        # Try to get the git root path of the file using git rev-parse --show-toplevel`
        try {`
            $expr = "git -C '$filePath' rev-parse --show-toplevel"`
            $gitRoot = invoke-expression $expr`
`
            # If the git root path is not in the hashtable, create a new entry with an empty array`
            if (-not $gitRoots.ContainsKey($gitRoot)) {`
                $gitRoots[$gitRoot] = @()`
            }`
`
            # Add the file path to the array of the corresponding git root path`
            $gitRoots[$gitRoot] += $filePath`
        }`
        # Catch any error and assign it to the git root variable`
        catch {`
            write-error $expr`
            Write-Error $filePath`
            $gitRoot = "error: $_"`
        }`
`
        `
    }`
`
    # Loop through each git root path in the hashtable`
    foreach ($gitRoot in $gitRoots.Keys) {`
        # Print the git root path`
        Write-Host "Git root: $gitRoot"`
`
        # Print the file paths under the git root path`
        foreach ($filePath in $gitRoots[$gitRoot]) {`
            Write-Host "  - $filePath"`
        }`
    }`
}
everything-GitRoots -search 'join ext:ps1' -pathx 'B:\pf\'
function invoke-Everything {`
    param(`
        [Parameter(Mandatory=$false)]`
        [string]$folderPath = "B:\PF\NoteTakingProjectFolder",`
        [Parameter(Mandatory=$false)]`
        [string]$filter = '<wholefilename:child:.git file:>|<wholefilename:child:.git folder:>',`
        [Parameter(Mandatory=$false)]`
        [switch]$notGlobal = $false`
    )`
`
    #install-module pseverything`
    #Import-Module pseverything`
`
    $folderPath = $folderPath.trim("\\")`
`
    # Build a string with the parameters for Search-Everything`
    $searchString = "Search-Everything"`
    `
    if ($folderPath) {`
        $searchString += " -PathInclude '$folderPath'"`
    }`
`
    if ($filter) {`
        $searchString += " -Filter '$filter'"`
    }`
`
    if (!$notGlobal) {`
        $searchString += " -Global"`
    }`
    $lines = @()`
    # Invoke the string as a command and get the folders`
    $lines =  Invoke-Expression $searchString`
    return $lines`
}
function everything-GitRoots ($pathx,$search)`
{`
       # Get the folder path from the user input`
    `
    `
`
    # Search for files with extension .ps1 using Everything`
    $files = Invoke-Everything -folderPath $pathx -filter $search  | %{ $_ | Get-Item }`
`
    # Initialize a hashtable to store the git root paths and the file paths`
    $gitRoots = @{}`
    Write-Output ($files | Measure-Object)`
    # Loop through each file`
    foreach ($file in $files) {`
        # Get the full path of the file`
        $filePath = $file.Parent`
`
        # Try to get the git root path of the file using git rev-parse --show-toplevel`
        try {`
            $expr = "git -C '+$filePath+' rev-parse --show-toplevel"`
            $gitRoot = invoke-expression $expr`
`
            # If the git root path is not in the hashtable, create a new entry with an empty array`
            if (-not $gitRoots.ContainsKey($gitRoot)) {`
                $gitRoots[$gitRoot] = @()`
            }`
`
            # Add the file path to the array of the corresponding git root path`
            $gitRoots[$gitRoot] += $filePath`
        }`
        # Catch any error and assign it to the git root variable`
        catch {`
            write-error $expr`
            Write-Error $filePath`
            $gitRoot = "error: $_"`
        }`
`
        `
    }`
`
    # Loop through each git root path in the hashtable`
    foreach ($gitRoot in $gitRoots.Keys) {`
        # Print the git root path`
        Write-Host "Git root: $gitRoot"`
`
        # Print the file paths under the git root path`
        foreach ($filePath in $gitRoots[$gitRoot]) {`
            Write-Host "  - $filePath"`
        }`
    }`
}
everything-GitRoots -search 'join ext:ps1' -pathx 'B:\pf\'
invoke-Everything -filter 'join ext:ps1' -folderPath 'B:\pf\' | %{ $_ | Get-Item } | %{ $_.parent }
invoke-Everything -filter 'join ext:ps1' -folderPath 'B:\pf\' | %{ $_ | Get-Item } | %{ $_ }
invoke-Everything -filter 'join ext:ps1' -folderPath 'B:\pf\' | %{ $_ | Get-Item } | %{ $_ | Split-Path -Parent }
invoke-Everything -filter 'join ext:ps1' -folderPath 'B:\pf\' | %{ $_ | Get-Item } | %{ $_ | Split-Path -Parentfunction invoke-Everything {`
    param(`
        [Parameter(Mandatory=$false)]`
        [string]$folderPath = "B:\PF\NoteTakingProjectFolder",`
        [Parameter(Mandatory=$false)]`
        [string]$filter = '<wholefilename:child:.git file:>|<wholefilename:child:.git folder:>',`
        [Parameter(Mandatory=$false)]`
        [switch]$notGlobal = $false`
    )`
`
    #install-module pseverything`
    #Import-Module pseverything`
`
    $folderPath = $folderPath.trim("\\")`
`
    # Build a string with the parameters for Search-Everything`
    $searchString = "Search-Everything"`
    `
    if ($folderPath) {`
        $searchString += " -PathInclude '$folderPath'"`
    }`
`
    if ($filter) {`
        $searchString += " -Filter '$filter'"`
    }`
`
    if (!$notGlobal) {`
        $searchString += " -Global"`
    }`
    $lines = @()`
    # Invoke the string as a command and get the folders`
    $lines =  Invoke-Expression $searchString`
    return $lines`
} }
function invoke-Everything {`
    param(`
        [Parameter(Mandatory=$false)]`
        [string]$folderPath = "B:\PF\NoteTakingProjectFolder",`
        [Parameter(Mandatory=$false)]`
        [string]$filter = '<wholefilename:child:.git file:>|<wholefilename:child:.git folder:>',`
        [Parameter(Mandatory=$false)]`
        [switch]$notGlobal = $false`
    )`
`
    #install-module pseverything`
    #Import-Module pseverything`
`
    $folderPath = $folderPath.trim("\\")`
`
    # Build a string with the parameters for Search-Everything`
    $searchString = "Search-Everything"`
    `
    if ($folderPath) {`
        $searchString += " -PathInclude '$folderPath'"`
    }`
`
    if ($filter) {`
        $searchString += " -Filter '$filter'"`
    }`
`
    if (!$notGlobal) {`
        $searchString += " -Global"`
    }`
    $lines = @()`
    # Invoke the string as a command and get the folders`
    $lines =  Invoke-Expression $searchString`
    return $lines`
}
function everything-GitRoots ($pathx,$search)`
{`
       # Get the folder path from the user input`
    `
    `
`
    # Search for files with extension .ps1 using Everything`
    $files = Invoke-Everything -folderPath $pathx -filter $search  | %{ $_ | Get-Item }`
`
    # Initialize a hashtable to store the git root paths and the file paths`
    $gitRoots = @{}`
    Write-Output ($files | Measure-Object)`
    # Loop through each file`
    foreach ($file in $files) {`
        # Get the full path of the file`
        $filePath = $file | Split-Path -Parent`
`
        # Try to get the git root path of the file using git rev-parse --show-toplevel`
        try {`
            $expr = "git -C '+$filePath+' rev-parse --show-toplevel"`
            $gitRoot = invoke-expression $expr`
`
            # If the git root path is not in the hashtable, create a new entry with an empty array`
            if (-not $gitRoots.ContainsKey($gitRoot)) {`
                $gitRoots[$gitRoot] = @()`
            }`
`
            # Add the file path to the array of the corresponding git root path`
            $gitRoots[$gitRoot] += $filePath`
        }`
        # Catch any error and assign it to the git root variable`
        catch {`
            write-error $expr`
            Write-Error $filePath`
            $gitRoot = "error: $_"`
        }`
`
        `
    }`
`
    # Loop through each git root path in the hashtable`
    foreach ($gitRoot in $gitRoots.Keys) {`
        # Print the git root path`
        Write-Host "Git root: $gitRoot"`
`
        # Print the file paths under the git root path`
        foreach ($filePath in $gitRoots[$gitRoot]) {`
            Write-Host "  - $filePath"`
        }`
    }`
}
everything-GitRoots -search 'join ext:ps1' -pathx 'B:\pf\'
function invoke-Everything {`
    param(`
        [Parameter(Mandatory=$false)]`
        [string]$folderPath = "B:\PF\NoteTakingProjectFolder",`
        [Parameter(Mandatory=$false)]`
        [string]$filter = '<wholefilename:child:.git file:>|<wholefilename:child:.git folder:>',`
        [Parameter(Mandatory=$false)]`
        [switch]$notGlobal = $false`
    )`
`
    #install-module pseverything`
    #Import-Module pseverything`
`
    $folderPath = $folderPath.trim("\\")`
`
    # Build a string with the parameters for Search-Everything`
    $searchString = "Search-Everything"`
    `
    if ($folderPath) {`
        $searchString += " -PathInclude '$folderPath'"`
    }`
`
    if ($filter) {`
        $searchString += " -Filter '$filter'"`
    }`
`
    if (!$notGlobal) {`
        $searchString += " -Global"`
    }`
    $lines = @()`
    # Invoke the string as a command and get the folders`
    $lines =  Invoke-Expression $searchString`
    return $lines`
}
function everything-GitRoots ($pathx,$search)`
{`
       # Get the folder path from the user input`
    `
    `
`
    # Search for files with extension .ps1 using Everything`
    $files = Invoke-Everything -folderPath $pathx -filter $search  | %{ $_ | Get-Item }`
`
    # Initialize a hashtable to store the git root paths and the file paths`
    $gitRoots = @{}`
    Write-Output ($files | Measure-Object)`
    # Loop through each file`
    foreach ($file in $files) {`
        # Get the full path of the file`
        $filePath = $file | Split-Path -Parent`
`
        # Try to get the git root path of the file using git rev-parse --show-toplevel`
        try {`
            $expr = "git -C "+$filePath+" rev-parse --show-toplevel"`
            $gitRoot = invoke-expression $expr`
`
            # If the git root path is not in the hashtable, create a new entry with an empty array`
            if (-not $gitRoots.ContainsKey($gitRoot)) {`
                $gitRoots[$gitRoot] = @()`
            }`
`
            # Add the file path to the array of the corresponding git root path`
            $gitRoots[$gitRoot] += $filePath`
        }`
        # Catch any error and assign it to the git root variable`
        catch {`
            write-error $expr`
            Write-Error $filePath`
            $gitRoot = "error: $_"`
        }`
`
        `
    }`
`
    # Loop through each git root path in the hashtable`
    foreach ($gitRoot in $gitRoots.Keys) {`
        # Print the git root path`
        Write-Host "Git root: $gitRoot"`
`
        # Print the file paths under the git root path`
        foreach ($filePath in $gitRoots[$gitRoot]) {`
            Write-Host "  - $filePath"`
        }`
    }`
}
everything-GitRoots -search 'join ext:ps1' -pathx 'B:\pf\'
function invoke-Everything {`
    param(`
        [Parameter(Mandatory=$false)]`
        [string]$folderPath = "B:\PF\NoteTakingProjectFolder",`
        [Parameter(Mandatory=$false)]`
        [string]$filter = '<wholefilename:child:.git file:>|<wholefilename:child:.git folder:>',`
        [Parameter(Mandatory=$false)]`
        [switch]$notGlobal = $false`
    )`
`
    #install-module pseverything`
    #Import-Module pseverything`
`
    $folderPath = $folderPath.trim("\\")`
`
    # Build a string with the parameters for Search-Everything`
    $searchString = "Search-Everything"`
    `
    if ($folderPath) {`
        $searchString += " -PathInclude '$folderPath'"`
    }`
`
    if ($filter) {`
        $searchString += " -Filter '$filter'"`
    }`
`
    if (!$notGlobal) {`
        $searchString += " -Global"`
    }`
    $lines = @()`
    # Invoke the string as a command and get the folders`
    $lines =  Invoke-Expression $searchString`
    return $lines`
}
function everything-GitRoots ($pathx,$search)`
{`
       # Get the folder path from the user input`
    `
    `
`
    # Search for files with extension .ps1 using Everything`
    $files = Invoke-Everything -folderPath $pathx -filter $search  | %{ $_ | Get-Item }`
`
    # Initialize a hashtable to store the git root paths and the file paths`
    $gitRoots = @{}`
    Write-Output ($files | Measure-Object)`
    # Loop through each file`
    foreach ($file in $files) {`
        # Get the full path of the file`
        $filePath = $file | Split-Path -Parent`
`
        # Try to get the git root path of the file using git rev-parse --show-toplevel`
        try {`
            $expr = "git -C '"+$filePath+"' rev-parse --show-toplevel"`
            $gitRoot = invoke-expression $expr`
`
            # If the git root path is not in the hashtable, create a new entry with an empty array`
            if (-not $gitRoots.ContainsKey($gitRoot)) {`
                $gitRoots[$gitRoot] = @()`
            }`
`
            # Add the file path to the array of the corresponding git root path`
            $gitRoots[$gitRoot] += $filePath`
        }`
        # Catch any error and assign it to the git root variable`
        catch {`
            write-error $expr`
            Write-Error $filePath`
            $gitRoot = "error: $_"`
        }`
`
        `
    }`
`
    # Loop through each git root path in the hashtable`
    foreach ($gitRoot in $gitRoots.Keys) {`
        # Print the git root path`
        Write-Host "Git root: $gitRoot"`
`
        # Print the file paths under the git root path`
        foreach ($filePath in $gitRoots[$gitRoot]) {`
            Write-Host "  - $filePath"`
        }`
    }`
}
everything-GitRoots -search 'join ext:ps1' -pathx 'B:\pf\'
function invoke-Everything {`
    param(`
        [Parameter(Mandatory=$false)]`
        [string]$folderPath = "B:\PF\NoteTakingProjectFolder",`
        [Parameter(Mandatory=$false)]`
        [string]$filter = '<wholefilename:child:.git file:>|<wholefilename:child:.git folder:>',`
        [Parameter(Mandatory=$false)]`
        [switch]$notGlobal = $false`
    )`
`
    #install-module pseverything`
    #Import-Module pseverything`
`
    $folderPath = $folderPath.trim("\\")`
`
    # Build a string with the parameters for Search-Everything`
    $searchString = "Search-Everything"`
    `
    if ($folderPath) {`
        $searchString += " -PathInclude '$folderPath'"`
    }`
`
    if ($filter) {`
        $searchString += " -Filter '$filter'"`
    }`
`
    if (!$notGlobal) {`
        $searchString += " -Global"`
    }`
    $lines = @()`
    # Invoke the string as a command and get the folders`
    $lines =  Invoke-Expression $searchString`
    return $lines`
}
function everything-GitRoots ($pathx,$search)`
{`
       # Get the folder path from the user input`
    `
    `
`
    # Search for files with extension .ps1 using Everything`
    $files = Invoke-Everything -folderPath $pathx -filter $search  | %{ $_ | Get-Item }`
`
    # Initialize a hashtable to store the git root paths and the file paths`
    $gitRoots = @{}`
    Write-Output ($files | Measure-Object)`
    # Loop through each file`
    foreach ($file in $files) {`
        # Get the full path of the file`
        $filePath = $file`
`
        # Try to get the git root path of the file using git rev-parse --show-toplevel`
        try {`
            $filexp = $file | Split-Path -Parent`
            $expr = "git -C '"+$filexp+"' rev-parse --show-toplevel"`
            $gitRoot = invoke-expression $expr`
`
            # If the git root path is not in the hashtable, create a new entry with an empty array`
            if (-not $gitRoots.ContainsKey($gitRoot)) {`
                $gitRoots[$gitRoot] = @()`
            }`
`
            # Add the file path to the array of the corresponding git root path`
            $gitRoots[$gitRoot] += $filePath`
        }`
        # Catch any error and assign it to the git root variable`
        catch {`
            write-error $expr`
            Write-Error $filePath`
            $gitRoot = "error: $_"`
        }`
`
        `
    }`
`
    # Loop through each git root path in the hashtable`
    foreach ($gitRoot in $gitRoots.Keys) {`
        # Print the git root path`
        Write-Host "Git root: $gitRoot"`
`
        # Print the file paths under the git root path`
        foreach ($filePath in $gitRoots[$gitRoot]) {`
            Write-Host "  - $filePath"`
        }`
    }`
}function invoke-Everything {`
    param(`
        [Parameter(Mandatory=$false)]`
        [string]$folderPath = "B:\PF\NoteTakingProjectFolder",`
        [Parameter(Mandatory=$false)]`
        [string]$filter = '<wholefilename:child:.git file:>|<wholefilename:child:.git folder:>',`
        [Parameter(Mandatory=$false)]`
        [switch]$notGlobal = $false`
    )`
`
    #install-module pseverything`
    #Import-Module pseverything`
`
    $folderPath = $folderPath.trim("\\")`
`
    # Build a string with the parameters for Search-Everything`
    $searchString = "Search-Everything"`
    `
    if ($folderPath) {`
        $searchString += " -PathInclude '$folderPath'"`
    }`
`
    if ($filter) {`
        $searchString += " -Filter '$filter'"`
    }`
`
    if (!$notGlobal) {`
        $searchString += " -Global"`
    }`
    $lines = @()`
    # Invoke the string as a command and get the folders`
    $lines =  Invoke-Expression $searchString`
    return $lines`
}
function everything-GitRoots ($pathx,$search)`
{`
       # Get the folder path from the user input`
    `
    `
`
    # Search for files with extension .ps1 using Everything`
    $files = Invoke-Everything -folderPath $pathx -filter $search  | %{ $_ | Get-Item }`
`
    # Initialize a hashtable to store the git root paths and the file paths`
    $gitRoots = @{}`
    Write-Output ($files | Measure-Object)`
    # Loop through each file`
    foreach ($file in $files) {`
        # Get the full path of the file`
        $filePath = $file`
`
        # Try to get the git root path of the file using git rev-parse --show-toplevel`
        try {`
            $filexp = $file | Split-Path -Parent`
            $expr = "git -C '"+$filexp+"' rev-parse --show-toplevel"`
            $gitRoot = invoke-expression $expr`
`
            # If the git root path is not in the hashtable, create a new entry with an empty array`
            if (-not $gitRoots.ContainsKey($gitRoot)) {`
                $gitRoots[$gitRoot] = @()`
            }`
`
            # Add the file path to the array of the corresponding git root path`
            $gitRoots[$gitRoot] += $filePath`
        }`
        # Catch any error and assign it to the git root variable`
        catch {`
            write-error $expr`
            Write-Error $filePath`
            $gitRoot = "error: $_"`
        }`
`
        `
    }`
`
    # Loop through each git root path in the hashtable`
    foreach ($gitRoot in $gitRoots.Keys) {`
        # Print the git root path`
        Write-Host "Git root: $gitRoot"`
`
        # Print the file paths under the git root path`
        foreach ($filePath in $gitRoots[$gitRoot]) {`
            Write-Host "  - $filePath"`
        }`
    }`
}
everything-GitRoots -search 'join ext:ps1' -pathx 'B:\pf\'
Copy-Function invoke-everything
copy-function everything-GitRoots
Resize-VHD -Path 'I:\OtherDrives\side_profile-40g.vhdx' -SizeBytes 60GB
git status
invoke-Everything -filter 'content:Archive/ToGit/scoopbucket-presist/VisualStudio/8691414/WpfApp4'  -folderPath $pwd
invoke-Everything -filter 'content:WpfApp4'  -folderPath $pwd
 $pwd
invoke-Everything -filter 'content:WpfApp4'  -folderPath "$pwd"
git status
git reflog master # find the last valid reference for master
git reset --hard master@{n} # replace n with the number of the reference
fetch origin; git checkout master; git reset --hard origin/master
git fetch origin
git update-ref refs/heads/master remote/master
git update-ref refs/heads/master origin/master
git fetch origin
function repairHead {param($from="refs/heads/master",$to="origin/master"); $expr = "git update-ref "+$from+" "+ $to; invoke-expression $expr }
Copy-Function repairHead
Get-Clipboard | %{ $_ -replace 'https://open.spotify.com/playlist/', 'spotify:user:spotify:playlist:' -replace '\?si=.*', '' } | set-clipboardps Get-Clipboard | ForEach-Object { $_ -replace 'https://open.spotify.com/playlist/', 'spotify:user:spotify:playlist:' -replace '\?si=.*', '' } | set-clipboard
Get-Clipboard | %{ $_ -replace 'https://open.spotify.com/playlist/', 'spotify:user:spotify:playlist:' -replace '\?si=.*', '' } | set-clipboard
Get-Clipboard | %{$regex = [regex]::Escape('https://open.spotify.com/playlist/') ; $_ -replace $regex, 'spotify:user:spotify:playlist:' -replace '\?si=.*', '' } | set-clipboard
Get-Clipboard
Get-Clipboard | % { Get-Content $_}
Get-Clipboard | % { Get-Item $_ }
Get-Clipboard | % { Get-Content $_ } | % { $_.Directory }
Get-Clipboard | % { Get-Item $_ } | %{ $_.Directory }
Get-Clipboard | % { Get-Item -path $_ } | %{ $_.Directory }
Get-Clipboard | % { Get-Item -path $_ } | Group-Object -Property $_.Directory 
Get-Clipboard | % { Get-Item -path $_ } | Group-Object -Property $_.Directory.Directory 
Get-Clipboard | % { Get-Item -path $_ } | Group-Object -Property { $_.parent.parent}
Get-Clipboard | Get-Item | Group-Object -Property { $_.parent.parent}
Get-Clipboard | Get-Item | Group-Object -Property { $_.parent}
Get-Clipboard | Get-Item 
Get-Clipboard | Get-Item | select parent.parent
Get-Clipboard | Get-Item | select parent
Get-Clipboard | Get-Item | select Directory
Get-Clipboard | Get-Item | select Directory.directory
Get-Clipboard | Get-Item | select Directory
Get-Clipboard | Get-Item | select Directory | select directory
Get-Clipboard | Get-Item | select Directory | Split-Path -Parent
Get-Clipboard | Get-Item | group-object {$_.Directory | Split-Path -Parent}
$groups = Get-Clipboard | Get-Item | group-object {$_.Directory | Split-Path -Parent} ; $groups | ForEach-Object {Write-Output $_ }
$groups = Get-Clipboard | Get-Item | group-object {$_.Directory | Split-Path -Parent} ; $groups | ForEach-Object {Write-Output $_.Group }
$groups = Get-Clipboard | Get-Item | group-object {$_.Directory | Split-Path -Parent} ; $groups | ForEach-Object { $_.Group | Sort-Object -Property length | select -First 1 }
$groups = Get-Clipboard | Get-Item | group-object {$_.Directory | Split-Path -Parent} ; $groups | ForEach-Object { $_.Group | Sort-Object -Property length | select -First 1 } | select name, fullname
$groups = Get-Clipboard | Get-Item | group-object {$_.Directory | Split-Path -Parent} ; $groups | ForEach-Object { $_.Group | Sort-Object -Property length | select -First 1 } | select basename, fullname
$groups = Get-Clipboard | Get-Item | group-object {$_.Directory | Split-Path -Parent} ; $groups | ForEach-Object { $_.Group | Sort-Object -Property length | select -First 1 } | select @{n="ux", exp={ basename + " = " + fullname } }
$groups = Get-Clipboard | Get-Item | group-object {$_.Directory | Split-Path -Parent} ; $groups | ForEach-Object { $_.Group | Sort-Object -Property length | select -First 1 } | select @{n="ux", expr={ basename + " = " + fullname } }
$groups = Get-Clipboard | Get-Item | group-object {$_.Directory | Split-Path -Parent} ; $groups | ForEach-Object { $_.Group | Sort-Object -Property length | select -First 1 } | select @{n="ux", expression ={ basename + " = " + fullname } }
$groups = Get-Clipboard | Get-Item | group-object {$_.Directory | Split-Path -Parent} ; $groups | ForEach-Object { $_.Group | Sort-Object -Property length | select -First 1 } | select @{n="ux" expression ={ basename + " = " + fullname } }
$groups = Get-Clipboard | Get-Item | group-object {$_.Directory | Split-Path -Parent} ; $groups | ForEach-Object { $_.Group | Sort-Object -Property length | select -First 1 } | select @{n="ux"; expression ={ basename + " = " + fullname } }
$groups = Get-Clipboard | Get-Item | group-object {$_.Directory | Split-Path -Parent} ; $groups | ForEach-Object { $_.Group | Sort-Object -Property length | select -First 1 } | %{ $_.basename + " = " + $_.fullname }
$groups = Get-Clipboard | Get-Item | group-object {$_.Directory | Split-Path -Parent} ; $groups | ForEach-Object { $_.Group | Sort-Object -Property length | select -First 1 } | %{ $_.basename + " = " + $_.fullname } | Set-Clipboard
$groups = Get-Clipboard | Get-Item | group-object {$_.Directory | Split-Path -Parent} ; $groups | ForEach-Object { $_.Group | Sort-Object -Property length | select -First 1 } | %{ $regex = '\\[\d.]\\' ; $_.basename + " = " + ($_.fullname).replace($regex, '\current\') } 
$groups = Get-Clipboard | Get-Item | group-object {$_.Directory | Split-Path -Parent} ; $groups | ForEach-Object { $_.Group | Sort-Object -Property length | select -First 1 } | %{ $regex = '[\\][\d.][\\]' ; $_.basename + " = " + ($_.fullname).replace($regex, '\current\') } 
$groups = Get-Clipboard | Get-Item | group-object {$_.Directory | Split-Path -Parent} ; $groups | ForEach-Object { $_.Group | Sort-Object -Property length | select -First 1 } | %{ $regex = '[\\][\d.][\\]' ; $_.basename + " = " + (($_.fullname) -replace($regex, '\current\')) } 
$groups = Get-Clipboard | Get-Item | group-object {$_.Directory | Split-Path -Parent} ; $groups | ForEach-Object { $_.Group | Sort-Object -Property length | select -First 1 } | %{ $regex = '[\\][\d.]*[\\]' ; $_.basename + " = " + (($_.fullname) -replace($regex, '\current\')) } 
$groups = Get-Clipboard | Get-Item | group-object {$_.Directory | Split-Path -Parent} ; $groups | ForEach-Object { $_.Group | Sort-Object -Property length | select -First 1 } | %{ $regex = '[\\][\d.]*[\\]' ; $_.basename + " = " + (($_.fullname) -replace($regex, '\current\')) } | Set-Clipboard
function Flowlauncher-favoritesFrompaths {$groups = Get-Clipboard | Get-Item | group-object {$_.Directory | Split-Path -Parent} ; $groups | ForEach-Object { $_.Group | Sort-Object -Property length | select -First 1 } | %{ $regex = '[\\][\d.]*[\\]' ; $_.basename + " = " + (($_.fullname) -replace($regex, '\current\')) } | Set-Clipboard}
function filter-repo($from,$to,$ref) { $expr = "git filter-repo --path-rename "+$from+":"+$to +" --refs '" + $ref + "'" ; invoke-expression $expr }
function to-Subdirectory($to,$ref) { git filter-repo --to-subdirectory-filter $to --refs $ref }
function remove-directory($rel) { git filter-repo --path $rel --invert-path --force}
Copy-Function filter-repo
Copy-Function to-Subdirectory
Copy-Function remove-directory
git filter-repo -h
function subdir-ToRoot($rel) { git filter-repo --subdirectory-filter $rel --force}
Copy-Function subdir-ToRoot
function subdir-ToRoot($rel,$ref) { git filter-repo --subdirectory-filter $rel --force --refs $ref }
subdir-ToRoot -rel NotetakingProjectFolder -ref GeneralProjNoteT
subdir-ToRoot -rel NoteTakingProjectFolder -ref GenProjNot
subdir-ToRoot -rel NoteTakingProjectFolder -ref Branch_beforeFolderMerge
subdir-ToRoot -rel NoteTakingProjectFolder -ref 'remotes/General-ProjectFolders/HomeProjectFolder'
subdir-ToRoot -rel NoteTakingProjectFolder -ref 'remotes/General-ProjectFolders/Before'
subdir-ToRoot -rel NoteTakingProjectFolder -ref 'refs/remotes/General-ProjectFolders/master'
Copy-Function subdir-ToRoot 
filter-lamely
git filter-lamely
import-module 'posh-git'
git merge windot-files-main --allow-unrelated-histories
git merge 'WinDotFiles-main' --strategy 'resolve' --allow-unrelated-histories
git merge 'WinDotFiles-main' --strategy 'theirs' --allow-unrelated-histories
git merge 'WinDotFiles-main' --strategy octopus --allow-unrelated-histories
git merge 'WinDotFiles-main' --strategy resolve --allow-unrelated-histories
git merge 'WinDotFiles-main' --strategy ours --allow-unrelated-histories
git merge 'DotfileMaintag' --strategy ours --allow-unrelated-histories
git merge 'dotfiles/master' --strategy ours --allow-unrelated-histories
git merge 'deployed/NewPurePersist' --strategy ours --allow-unrelated-histories
function merge-ours($branch) { git merge $branch --strategy ours --allow-unrelated-histories }
merge-ours CsvLoaded
merge-ours Stable-butik
merge-ours calculatorSquished
merge-ours Lotto
merge-ours calculator
merge-ours masterK
to-Subdirectory -ref 'refs/remotes/git-toolbelt/main' -to 'bin'
merge-ours 'refs/remotes/git-toolbelt/main'
function merge-ours($branch) { git merge $branch --strategy ours --allow-unrelated-histories }
merge-ours 'refs/remotes/git-toolbelt/main'
Copy-Function merge-ours
SplitOutFunctions 'B:\PF\Archive\ps1\git\git-filter-repo.ps1'
SplitOutFunctions 'B:\PF\Archive\ps1\git\project\project-merge-File-With-History.ps1'
cd 'B:\PF\CSharpVisualStudio\repos' ; git push --all 'B:\PF\CSharpVisualStudio\repos\karlstad\KarlstadButik'
 git push --all 'B:\PF\CSharpVisualStudio\repos\karlstad\KarlstadButik'
param(`
    [Parameter(Mandatory=$true)]`
    [string]$path`
)
# Get the basename of the path
$branchName = Get-ChildItem -Path $path -BaseName
# Create a new branch that tracks only the provided path
git branch -t $branchName $path
# Delete the file after adding it to the commit
git add $path
git commit -m "Added file $path"
function replaceLinebreakes { $clipboardContent = Get-Clipboard ; $clipboardContent = $clipboardContent -replace '\r?\n', ';' ; Set-Clipboard $clipboardContent }
replaceLinebreakes
function FileToBranch { param( [Parameter(Mandatory=$true)][string]$path) ; $branchName = Get-ChildItem -Path $path -BaseName ; git branch -t $branchName $path ; $originalBranchName = (git symbolic-ref HEAD) ; git switch --detach $branchName ; git add $path ; git commit -m "Added file $path" ; git switch --detach $originalBranchName ; rm $path }
fileTobranch 'B:\PF\Archive\ps1\git\project\split-branches-byfiles.md'
function FileToBranch { param( [Parameter(Mandatory=$true)][string]$path) ; $branchName = get-item -Path $path -baseName ; git branch -t $branchName $path ; $originalBranchName = (git symbolic-ref HEAD) ; git switch --detach $branchName ; git add $path ; git commit -m "Added file $path" ; git switch --detach $originalBranchName ; rm $path }
function newFeatureBranch { param( [Parameter(Mandatory=$true)][string]$path) ; $branchName = get-item -Path $path -baseName ; git branch -t $branchName $path ; $originalBranchName = (git symbolic-ref HEAD) ; git switch --detach $branchName ; git add $path ; git commit -m "Added file $path" ; git switch --detach $originalBranchName ; rm $path }
Copy-Function newFeatureBranch
function CheckoutNotTree { [Parameter(Mandatory=$true)][string]$branchName) ; return (git symbolic-ref HEAD) ; git switch --detach $branchName }
function CheckoutNotTree() { [Parameter(Mandatory=$true)][string]$branchName) ; return (git symbolic-ref HEAD) ; git switch --detach $branchName }
function CheckoutNotTree() { param([Parameter(Mandatory=$true)][string]$branchName) ; return (git symbolic-ref HEAD) ; git switch --detach $branchName }
Copy-Function CheckoutNotTree
CheckoutNotTree 'refs/heads/split-Branches-ByFile'
CheckoutNotTree 'split-Branches-ByFile'
function CheckoutNotTree() { param([Parameter(Mandatory=$true)][string]$branchName) ; git switch --detach $branchName }
CheckoutNotTree 'split-Branches-ByFile'
git update-index --reset 75a47cc
git reset --soft 75a47cc
git checkout 'split-Branches-ByFile'
git reset --soft 75a47cc
git show-ref --heads
git ls-files --full-name 'B:\Unsorted\tempRepo\lib\git-Temp.ps1'
git rev-parse --show-toplevel -- 'B:\Unsorted\tempRepo\lib\git-Temp.ps1'
cd 'B:\Unsorted\tempRepo\lib\' ; git rev-parse --show-toplevel -- 'B:\Unsorted\tempRepo\lib\git-Temp.ps1'
Set-location 'B:\Unsorted\tempRepo\lib\' ; git rev-parse --show-toplevel -- 'B:\Unsorted\tempRepo\lib\git-Temp.ps1'
Set-location 'B:\Unsorted\tempRepo\lib\' ; git ls-files --full-name 'B:\Unsorted\tempRepo\lib\git-Temp.ps1'
git filter-repo --analyze 
Get-Content .\path-all-sizes.txt
Set-PSReadLineKeyHandler -Key "Tab" -Function MenuComplete
Get-Content .\path-all-sizes.txt | ConvertFrom-Csv 
Get-Content .\path-all-sizes.txt | ConvertFrom-Csv -Delimiter '\t'
Get-Content .\path-all-sizes.txt | ConvertFrom-Csv -Delimiter '`t'
Get-Content .\path-all-sizes.txt | ConvertFrom-Csv -Delimiter '  '
Get-Content .\path-all-sizes.txt | ConvertFrom-Csv -Delimiter '\s'
Get-Content .\path-all-sizes.txt | Import-Csv  -Delimiter "`t"
Import-Csv -Path (Get-Item .\path-all-sizes.txt)  -Delimiter "`t"
function replaceLinebreakes { $clipboardContent = Get-Clipboard ; $clipboardContent = $clipboardContent -replace '\r?\n', ';' ; Set-Clipboard $clipboardContent }
replaceLinebreakes
$Pattern = "(.{13})(.{11})(.{9})(.{100})"; $Data = Get-Content path-all-sizes.txt -TotalCount 0; $Headers = $Data[1] -split "," ; $Matches = $Data | Select-String $Pattern -AllMatches ; $Output = foreach ($Match in $Matches) { [PSCustomObject]@{ $Headers[0] = $Match.Matches[0].Groups[1].Value.Trim() ; $Headers[1] = $Match.Matches[0].Groups[2].Value.Trim();$Headers[2] = $Match.Matches[0].Groups[3].Value.Trim();$Headers[3] = $Match.Matches[0].Groups[4].Value.Trim()}} ; $output
$Pattern = "(.{13})(.{11})(.{9})(.{100})"; $Data = Get-Content path-all-sizes.txt | select -Skip 1 ; $Headers = $Data[1] -split "," ; $Matches = $Data | Select-String $Pattern -AllMatches ; $Output = foreach ($Match in $Matches) { [PSCustomObject]@{ $Headers[0] = $Match.Matches[0].Groups[1].Value.Trim() ; $Headers[1] = $Match.Matches[0].Groups[2].Value.Trim();$Headers[2] = $Match.Matches[0].Groups[3].Value.Trim();$Headers[3] = $Match.Matches[0].Groups[4].Value.Trim()}} ; $output
$Pattern = "(.{13})(.{11})(.{9})(.{100})"; $Data = Get-Content path-all-sizes.txt | select -Skip 1 ; $Headers = $Data[1] -split "," ; $Matches = $Data | Select-String $Pattern -AllMatches 
$Matches 
$Matches | get-parameters
$Matches | Get-Member
$Matches.matches
$Pattern = "(.{13})(.{11})(.{9})(.*)"; $Data = Get-Content path-all-sizes.txt | select -Skip 1 ; $Headers = $Data[1] -split "," ; $Matches = $Data | Select-String $Pattern -AllMatches ; $matches.matches
$Pattern = "(.{13})(.{11})(.{9})(.*)"; $Data = Get-Content path-all-sizes.txt | select -Skip 1 ; $Headers = $Data[1] -split "," ; $Matches = $Data | Select-String $Pattern -AllMatches ; $matches.matches[0]
$Pattern = "(.{13})(.{11})(.{9})(.*)"; $Data = Get-Content path-all-sizes.txt | select -Skip 1 ; $Headers = $Data[1] -split "," ; $Matches = $Data | Select-String $Pattern -AllMatches ; $matches.matches | %{ $_[0] }
$Pattern = "(.{13})(.{11})(.{9})(.*)"; $Data = Get-Content path-all-sizes.txt | select -Skip 1 ; $Headers = $Data[1] -split "," ; $Matches = $Data | Select-String $Pattern -AllMatches ; $matches.matches | %{ $_[1] }
$Pattern = "^(.{13})(.{11})(.{9})(.*)$"; $Data = Get-Content path-all-sizes.txt | select -Skip 1 ; $Headers = $Data[1] -split "," ; $Matches = $Data | Select-String $Pattern -AllMatches ; $matches.matches | %{ $_[1] }
$Pattern = "^(.{13})(.{11})(.{9})(.*)$"; $Data = Get-Content path-all-sizes.txt | select -Skip 1 ; $Headers = $Data[1] -split "," ; $Matches = $Data | Select-String $Pattern -AllMatches ; $matches.matches 
$Pattern = "^(.{13})(.{11})(.{9})(.*)$"; $Data = Get-Content path-all-sizes.txt | select -Skip 1 ; $Headers = $Data[1] -split "," ; $Matches = $Data %{ $_ | Select-String $Pattern -AllMatches} ; $matches.matches 
$Pattern = "^(.{13})(.{11})(.{9})(.*)$"; $Data = Get-Content path-all-sizes.txt | select -Skip 1 ; $Headers = $Data[1] -split "," ; $Matches = $Data %{ $_ | Select-String $Pattern} ; $matches.matches 
$Pattern = "^(.{13})(.{11})(.{9})(.*)$"; $Data = Get-Content path-all-sizes.txt | select -Skip 1 ; $Headers = $Data[1] -split "," ; $Matches = $Data %{ $_ | Select-String $Pattern} ; $matches.matches.grouos 
$Pattern = "^(.{13})(.{11})(.{9})(.*)$"; $Data = Get-Content path-all-sizes.txt | select -Skip 1 ; $Headers = $Data[1] -split "," ; $Matches = $Data %{ $_ | Select-String $Pattern} ; $matches.matches.groups
$Pattern = "^(.{13})(.{11})(.{9})(.*)$"; $Data = Get-Content path-all-sizes.txt | select -Skip 1 ; $Headers = $Data[1] -split "," ; $Matches = $Data %{ $_ | Select-String $Pattern} ; $matches.matches.groups[2]
$Pattern = "^(.{13})(.{11})(.{9})(.*)$"; $Data = Get-Content path-all-sizes.txt | select -Skip 1 ; $Headers = $Data[1] -split "," ; $Matches = $Data | %{ ($_ | Select-String $Pattern).matches.groups } ; 
$Pattern = "^(.{13})(.{11})(.{9})(.*)$"; $Data = Get-Content path-all-sizes.txt | select -Skip 1 ; $Headers = $Data[1] -split "," ; $Matches = $Data | %{ ($_ | Select-String $Pattern).matches.groups } ; $Matches 
$Pattern = "^(.{13})(.{11})(.{9})(.*)$"; $Data = Get-Content path-all-sizes.txt | select -Skip 1 ; $Headers = $Data[1] -split "," ; $Matches = $Data | %{ ($_ | Select-String $Pattern).matches.groups[2] } ; $Matches 
$Pattern = "^(.{13})(.{11})(.{9})(.*)$"; $Data = Get-Content path-all-sizes.txt | select -Skip 1 ; $Headers = $Data[1] -split "," ; $Matches = $Data | %{ ($_ | Select-String $Pattern).matches.groups[2] } ; $Output = foreach ($Match in $Matches) { [PSCustomObject]@{ $Headers[0] = $Match.Matches[0].Groups[1].Value.Trim() ; $Headers[1] = $Match.Matches[0].Groups[2].Value.Trim();$Headers[2] = $Match.Matches[0].Groups[3].Value.Trim();$Headers[3] = $Match.Matches[0].Groups[4].Value.Trim()}} ; $output
$Pattern = "^(.{13})(.{11})(.{9})(.*)$"; $Data = Get-Content path-all-sizes.txt | select -Skip 1 ; $Headers = $Data[1] -split "," ; $Matches = $Data | %{ ($_ | Select-String $Pattern).matches.groups[2] } ; $Output = foreach ($Match in $Matches) { [PSCustomObject]@{ $Headers[0] = $Match.Matches[0].Groups[1].Value.Trim() ; $Headers[1] = $Match.Matches[0].Groups[2].Value.Trim();$Headers[2] = $Match.Matches[0].Groups[3].Value.Trim();$Headers[3] = $Match.Matches[0].Groups[4].Value.Trim()}} ; $Headers
$Pattern = "^(.{13})(.{11})(.{9})(.*)$"; $Data = Get-Content path-all-sizes.txt | select -Skip 1 ; $Headers = $Data[1] -split "," ; $Headers
$Pattern = "^(.{13})(.{11})(.{9})(.*)$"; $Data = Get-Content path-all-sizes.txt ; $Headers = $Data[1] -split "," ; $Headers
$Pattern = "^(.{13})(.{11})(.{9})(.*)$"; $Data = Get-Content path-all-sizes.txt ; $Headers = $Data[1] -split "," ; $data = $data | select -skip 2 | % { $_ -replace $Pattern "$1,$2,$3,$4" } ; 
$Pattern = "^(.{13})(.{11})(.{9})(.*)$"; $Data = Get-Content path-all-sizes.txt ; $Headers = $Data[1] -split "," ; $data = $data | select -skip 2 | % { $_ -replace $Pattern, "$1,$2,$3,$4" } ; 
$Pattern = "^(.{13})(.{11})(.{9})(.*)$"; $Data = Get-Content path-all-sizes.txt ; $Headers = $Data[1] -split "," ; $data = $data | select -skip 2 | % { $_ -replace $Pattern, "$1,$2,$3,$4" } ; $Data
$Pattern = "^(.{13})(.{11})(.{9})(.*)$"; $Data = Get-Content path-all-sizes.txt ; $Headers = $Data[1] -split "," ; $data = $data | select -skip 2 | % { $_ -replace $Pattern, "\1,\2,\3,\4" } ; $Data
$Pattern = "^(.{13})(.{11})(.{9})(.*)$"; $Data = Get-Content path-all-sizes.txt ; $Headers = $Data[1] -split "," ; $data = $data | select -skip 2 | % { $_ -replace $Pattern, "/1,/2,/3,/4" } ; $Data
$Pattern = "^(.{13})(.{11})(.{9})(.*)$"; $Data = Get-Content path-all-sizes.txt ; $Headers = $Data[1] -split "," ; $data = $data | select -skip 2 | % { $_.replace($Pattern, "$1,$2,$3,$4") } ; $Data
$Pattern = "^(.{13})(.{11})(.{9})(.*)$"; $Data = Get-Content path-all-sizes.txt ; $Headers = $Data[1] -split "," ; $data = $data | select -skip 2 | % { $_ -replace ($Pattern, "$1,$2,$3,$4") } ; $Data
$Pattern = "^(.{13})(.{11})(.{9})(.*)$"; $Data = Get-Content path-all-sizes.txt ; $Headers = $Data[1] -split "," ; $data = $data | select -skip 2 | % { $_ -replace $Pattern, "$1,$2,$3,$4" } ; $Data
$Pattern = "^(.{13})(.{11})(.{9})(.*)$"; $Data = Get-Content path-all-sizes.txt | select -Skip 1 ; $Headers = $Data[1] -split "," ; $Matches = $Data | %{ ($_ | Select-String $Pattern).matches.groups } ; $Output = foreach ($Match in $Matches) { [PSCustomObject]@{ $Headers[0] = $Match[1].Value.Trim() ; $Headers[1] = $Match[2].Value.Trim();$Headers[2] = $Match[3].Value.Trim();$Headers[3] = $Match[4].Value.Trim()}} ; $Headers
$Pattern = "^(.{13})(.{11})(.{9})(.*)$"; $Data = Get-Content path-all-sizes.txt | select -Skip 1 ; $Headers = $Data[1] -split "," ; $Matches = $Data | %{ ($_ | Select-String $Pattern).matches.groups } ; $Output = foreach ($Match in $Matches) { [PSCustomObject]@{ $Headers[0] = $Match[1].Value.Trim() ; $Headers[1] = $Match[2].Value.Trim();$Headers[2] = $Match[3].Value.Trim();$Headers[3] = $Match[4].Value.Trim()}} ; 
$Pattern = "^(.{13})(.{11})(.{9})(.*)$"; $Data = Get-Content path-all-sizes.txt | select -Skip 1 ; $Headers = $Data[1] -split "," ; $Data | %{ ($_ | Select-String $Pattern).matches.groups }
$Pattern = "^(.{13})(.{11})(.{9})(.*)$"; $Data = Get-Content path-all-sizes.txt | select -Skip 1 ; $Headers = $Data[1] -split "," ; $Data | %{ (($_ | Select-String $Pattern).matches.groups)[2] }
$Pattern = "^(.{13})(.{11})(.{9})(.*)$"; $Data = Get-Content path-all-sizes.txt | select -Skip 1 ; $Headers = $Data[1] -split "," ; $Data | %{ (($_ | Select-String $Pattern).matches.groups)[2].Value }
$Pattern = "^(.{13})(.{11})(.{9})(.*)$"; $Data = Get-Content path-all-sizes.txt | select -Skip 1 ; $Headers = $Data[1] -split "," ; $Data 
$Pattern = "^(.{13})(.{11})(.{9})(.*)$"; $Data = Get-Content path-all-sizes.txt | select -Skip 1 ; $Headers = $Data[1] -split "," ; $Data | %{ $Match = (($_ | Select-String $Pattern).matches.groups)}
$Pattern = "^(.{13})(.{11})(.{9})(.*)$"; $Data = Get-Content path-all-sizes.txt | select -Skip 1 ; $Headers = $Data[1] -split "," ; $Data | %{ $Match = (($_ | Select-String $Pattern).matches.groups) ; $match }
$Pattern = "^(.{13})(.{11})(.{9})(.*)$"; $Data = Get-Content path-all-sizes.txt | select -Skip 1 ; $Headers = $Data[1] -split "," ; $Data | %{ $Match = (($_ | Select-String $Pattern).matches.groups) ; [PSCustomObject]@{ $Headers[0] = $Match[1].Value.Trim() ; $Headers[1] = $Match[2].Value.Trim(); $Headers[2] = $Match[3].Value.Trim(); $Headers[3] = $Match[4].Value.Trim() }}
$Pattern = "^(.{13})(.{11})(.{9})(.*)$"; $Data = Get-Content path-all-sizes.txt | select -Skip 1 ; $Headers = $Data[1] -split "," ; $Headers[0],$Headers[1],$Headers[2],$Headers[3] ;
$Pattern = "^(.{13})(.{11})(.{9})(.*)$"; $Data = Get-Content path-all-sizes.txt | select -Skip 1 ; $Headers = $Data[0] -split "," ; $Headers[0],$Headers[1],$Headers[2],$Headers[3] ;
$Pattern = "^(.{13})(.{11})(.{9})(.*)$"; $Data = Get-Content path-all-sizes.txt | select -Skip 1 ; $Headers = $Data[0] -split "," ; $Headers[0],$Headers[1],$Headers[2],$Headers[3] ;  $Data | %{ $Match = (($_ | Select-String $Pattern).matches.groups) ; [PSCustomObject]@{ $Headers[0] = $Match[1].Value.Trim() ; $Headers[1] = $Match[2].Value.Trim(); $Headers[2] = $Match[3].Value.Trim(); $Headers[3] = $Match[4].Value.Trim() }}
$Pattern = "^(.{13})(.{11})(.{9})(.*)$"; $Data = Get-Content path-all-sizes.txt | select -Skip 1 ; $Headers = $Data[0] -split "," ; $Data = $data | select -Skip 1 ; $Headers[0],$Headers[1],$Headers[2],$Headers[3] ;  $Data | %{ $Match = (($_ | Select-String $Pattern).matches.groups) ; [PSCustomObject]@{ $Headers[0] = $Match[1].Value.Trim() ; $Headers[1] = $Match[2].Value.Trim(); $Headers[2] = $Match[3].Value.Trim(); $Headers[3] = $Match[4].Value.Trim() }}
$Pattern = "^(.{13})(.{11})(\S{3,})\s(.*)$"; $Data = Get-Content path-all-sizes.txt | select -Skip 1 ; $Headers = $Data[0] -split "," ; $Data = $data | select -Skip 1 ; $Headers[0],$Headers[1],$Headers[2],$Headers[3] ;  $Data | %{ $Match = (($_ | Select-String $Pattern).matches.groups) ; [PSCustomObject]@{ $Headers[0] = $Match[1].Value.Trim() ; $Headers[1] = $Match[2].Value.Trim(); $Headers[2] = $Match[3].Value.Trim(); $Headers[3] = $Match[4].Value.Trim() }}
$Pattern = "^(.{13})(.{11})(.{9})(.*)$"; $Data = Get-Content path-all-sizes.txt -Encoding "utf-8" | select -Skip 1 ; $Headers = $Data[0] -split "," ; $Data = $data | select -Skip 1 ; $Headers[0],$Headers[1],$Headers[2],$Headers[3] ;  $Data | %{ $Match = (($_ | Select-String $Pattern).matches.groups) ; [PSCustomObject]@{ $Headers[0] = $Match[1].Value.Trim() ; $Headers[1] = $Match[2].Value.Trim(); $Headers[2] = $Match[3].Value.Trim(); $Headers[3] = $Match[4].Value.Trim() }}
$Pattern = "^(.{13})(.{11})(.{9})(.*)$"; $Data = Get-Content path-all-sizes.txt -Encoding "utf-8" | select -Skip 1
$Pattern = "^(.{13})(.{11})(.{9})(.*)$"; $Data = Get-Content path-all-sizes.txt -Encoding UTF8 | select -Skip 1
$Pattern = "^(.{13})(.{11})(.{9})(.*)$"; $Data = Get-Content path-all-sizes.txt -Encoding UTF8 
$Pattern = "^(.{13})(.{11})(.{9})(.*)$"; $Data = Get-Content path-all-sizes.txt -Encoding UTF8 | $data
$Pattern = "^(.{13})(.{11})(.{9})(.*)$"; $Data = Get-Content path-all-sizes.txt -Encoding UTF8 ; $data
$Pattern = "^(.{13})(.{11})(.{9})(.*)$"; $Data = Get-Content path-all-sizes.txt -Encoding UTF8 | select -Skip 1 ; $Headers = $Data[0] -split "," ; $Data = $data | select -Skip 1 ; $Headers[0],$Headers[1],$Headers[2],$Headers[3] ;  $Data | %{ $Match = (($_ | Select-String $Pattern).matches.groups) ; [PSCustomObject]@{ $Headers[0] = $Match[1].Value.Trim() ; $Headers[1] = $Match[2].Value.Trim(); $Headers[2] = $Match[3].Value.Trim(); $Headers[3] = $Match[4].Value.Trim() }}
$Pattern = "^(.{13})(.{11})(\S{3,})\s(.*)$"; $Data = Get-Content path-all-sizes.txt -Encoding UTF8 | select -Skip 1 ; $Headers = $Data[0] -split "," ; $Data = $data | select -Skip 1 ; $Headers[0],$Headers[1],$Headers[2],$Headers[3] ;  $Data | %{ $Match = (($_ | Select-String $Pattern).matches.groups) ; [PSCustomObject]@{ $Headers[0] = $Match[1].Value.Trim() ; $Headers[1] = $Match[2].Value.Trim(); $Headers[2] = $Match[3].Value.Trim(); $Headers[3] = $Match[4].Value.Trim() }}
$Pattern = "^(.{13})(.{11})(\S{3,})\s(.*)$"; $Data = Get-Content path-all-sizes.txt -Encoding UTF8 | select -Skip 1 ; $Headers = $Data[0] -split "," ; $Data = $data | select -Skip 1 ; $Headers[0],$Headers[1],$Headers[2],$Headers[3] ;  $Data | %{ $Match = (($_ | Select-String $Pattern).matches.groups) ; [PSCustomObject]@{ $Headers[0] = $Match[1].Value.Trim() ; $Headers[1] = $Match[2].Value.Trim(); $Headers[2] = $Match[3].Value.Trim(); $Headers[3] = $Match[4].Value.Trim() }} | get-property
$Pattern = "^(.{13})(.{11})(\S{3,})\s(.*)$"; $Data = Get-Content path-all-sizes.txt -Encoding UTF8 | select -Skip 1 ; $Headers = $Data[0] -split "," ; $Data = $data | select -Skip 1 ; $Headers[0],$Headers[1],$Headers[2],$Headers[3] ;  $Data | %{ $Match = (($_ | Select-String $Pattern).matches.groups) ; [PSCustomObject]@{ $Headers[0] = $Match[1].Value.Trim() ; $Headers[1] = $Match[2].Value.Trim(); $Headers[2] = $Match[3].Value.Trim(); $Headers[3] = $Match[4].Value.Trim() }} | get-properties
$Pattern = "^(.{13})(.{11})(\S{3,})\s(.*)$"; $Data = Get-Content path-all-sizes.txt -Encoding UTF8 | select -Skip 1 ; $Headers = $Data[0] -split "," ; $Data = $data | select -Skip 1 ; $Headers[0],$Headers[1],$Headers[2],$Headers[3] ;  $Data | %{ $Match = (($_ | Select-String $Pattern).matches.groups) ; [PSCustomObject]@{ $Headers[0] = $Match[1].Value.Trim() ; $Headers[1] = $Match[2].Value.Trim(); $Headers[2] = $Match[3].Value.Trim(); $Headers[3] = $Match[4].Value.Trim() }} | get-parameters
$Pattern = "^(.{13})(.{11})(\S{3,})\s(.*)$"; $Data = Get-Content path-all-sizes.txt -Encoding UTF8 | select -Skip 1 ; $Headers = $Data[0] -split "," ; $Data = $data | select -Skip 1 ; $Headers[0],$Headers[1],$Headers[2],$Headers[3] ;  $Data | %{ $Match = (($_ | Select-String $Pattern).matches.groups) ; [PSCustomObject]@{ $Headers[0] = $Match[1].Value.Trim() ; $Headers[1] = $Match[2].Value.Trim(); $Headers[2] = $Match[3].Value.Trim(); $Headers[3] = $Match[4].Value.Trim() }} | Get-Member
$Pattern = "^(.{13})(.{11})(\S{3,})\s(.*)$"; $Data = Get-Content path-all-sizes.txt -Encoding UTF8 | select -Skip 1 ; $Headers = $Data[0].replace(" ","_") -split "," ; $Data = $data | select -Skip 1 ; $Headers[0],$Headers[1],$Headers[2],$Headers[3] ;  $Data | %{ $Match = (($_ | Select-String $Pattern).matches.groups) ; [PSCustomObject]@{ $Headers[0] = $Match[1].Value.Trim() ; $Headers[1] = $Match[2].Value.Trim(); $Headers[2] = $Match[3].Value.Trim(); $Headers[3] = $Match[4].Value.Trim() }} | Get-Member
$Pattern = "^(.{13})(.{11})(\S{3,})\s(.*)$"; $Data = Get-Content path-all-sizes.txt -Encoding UTF8 | select -Skip 1 ; $Headers = $Data[0].replace(" ","_") -split "," ; $Data = $data | select -Skip 1 ; $Headers[0],$Headers[1],$Headers[2],$Headers[3] ;  $Data | %{ $Match = (($_ | Select-String $Pattern).matches.groups) ; [PSCustomObject]@{ $Headers[0] = $Match[1].Value.Trim() ; $Headers[1] = $Match[2].Value.Trim(); $Headers[2] = $Match[3].Value.Trim(); $Headers[3] = $Match[4].Value.Trim() }}
$Pattern = "^(.{13})(.{11})(\S{3,})\s(.*)$"; $Data = Get-Content path-all-sizes.txt -Encoding UTF8 | select -Skip 1 ; $Headers = $Data[0].replace(" ","_") -split "," ; $Data = $data | select -Skip 1 ; $Headers[0],$Headers[1],$Headers[2],$Headers[3] ;  $Data | %{ $Match = (($_ | Select-String $Pattern).matches.groups) ; [PSCustomObject]@{ $Headers[0] = $Match[1].Value.Trim() ; $Headers[1] = $Match[2].Value.Trim(); $Headers[2] = $Match[3].Value.Trim(); $Headers[3] = $Match[4].Value.Trim() }} | select -Property _path_name
cd 'B:\Unsorted\tempRepo\' ; $Pattern = "^(.{13})(.{11})(\S{3,})\s(.*)$"; $Data = Get-Content 'B:\Unsorted\tempRepo\.git\filter-repo\analysis\path-all-sizes.txt' -Encoding UTF8 | select -Skip 1 ; $Headers = $Data[0].replace(" ","_") -split "," ; $Data = $data | select -Skip 1 ; $Headers[0],$Headers[1],$Headers[2],$Headers[3] ;  $Data | %{ $Match = (($_ | Select-String $Pattern).matches.groups) ; [PSCustomObject]@{ $Headers[0] = $Match[1].Value.Trim() ; $Headers[1] = $Match[2].Value.Trim(); $Headers[2] = $Match[3].Value.Trim(); $Headers[3] = $Match[4].Value.Trim() }} | % { Resolve-Path $_._path_name } ; 
cd 'B:\Unsorted\tempRepo\' ; $Pattern = "^(.{13})(.{11})(\S{3,})\s(.*)$"; $Data = Get-Content 'B:\Unsorted\tempRepo\.git\filter-repo\analysis\path-all-sizes.txt' -Encoding UTF8 | select -Skip 1 ; $Headers = $Data[0].replace(" ","_") -split "," ; $Data = $data | select -Skip 1 ; $Headers[0],$Headers[1],$Headers[2],$Headers[3] ;  $Data | %{ $Match = (($_ | Select-String $Pattern).matches.groups) ; [PSCustomObject]@{ $Headers[0] = $Match[1].Value.Trim() ; $Headers[1] = $Match[2].Value.Trim(); $Headers[2] = $Match[3].Value.Trim(); $Headers[3] = $Match[4].Value.Trim() }} | % { Resolve-Path -Relative $_._path_name } ; 
cd 'B:\Unsorted\tempRepo\' ; $Pattern = "^(.{13})(.{11})(\S{3,})\s(.*)$"; $Data = Get-Content 'B:\Unsorted\tempRepo\.git\filter-repo\analysis\path-all-sizes.txt' -Encoding UTF8 | select -Skip 1 ; $Headers = $Data[0].replace(" ","_") -split "," ; $Data = $data | select -Skip 1 ; $Headers[0],$Headers[1],$Headers[2],$Headers[3] ;  $Data | %{ $Match = (($_ | Select-String $Pattern).matches.groups) ; [PSCustomObject]@{ $Headers[0] = $Match[1].Value.Trim() ; $Headers[1] = $Match[2].Value.Trim(); $Headers[2] = $Match[3].Value.Trim(); $Headers[3] = $Match[4].Value.Trim() }} | % { Resolve-Path -Relative "$_._path_name" } ; 
cd 'B:\Unsorted\tempRepo\' ; $Pattern = "^(.{13})(.{11})(\S{3,})\s(.*)$"; $Data = Get-Content 'B:\Unsorted\tempRepo\.git\filter-repo\analysis\path-all-sizes.txt' -Encoding UTF8 | select -Skip 1 ; $Headers = $Data[0].replace(" ","_") -split "," ; $Data = $data | select -Skip 1 ; $Headers[0],$Headers[1],$Headers[2],$Headers[3] ;  $Data | %{ $Match = (($_ | Select-String $Pattern).matches.groups) ; [PSCustomObject]@{ $Headers[0] = $Match[1].Value.Trim() ; $Headers[1] = $Match[2].Value.Trim(); $Headers[2] = $Match[3].Value.Trim(); $Headers[3] = $Match[4].Value.Trim() }} | % { $q = $_._path_name ;  Resolve-Path -Relative "$q"  } ; 
cd 'B:\Unsorted\tempRepo\' ; $Pattern = "^(.{13})(.{11})(\S{3,})\s(.*)$"; $Data = Get-Content 'B:\Unsorted\tempRepo\.git\filter-repo\analysis\path-all-sizes.txt' -Encoding UTF8 | select -Skip 1 ; $Headers = $Data[0].replace(" ","_") -split "," ; $Data = $data | select -Skip 1 ; $Headers[0],$Headers[1],$Headers[2],$Headers[3] ;  $Data | %{ $Match = (($_ | Select-String $Pattern).matches.groups) ; [PSCustomObject]@{ $Headers[0] = $Match[1].Value.Trim() ; $Headers[1] = $Match[2].Value.Trim(); $Headers[2] = $Match[3].Value.Trim(); $Headers[3] = $Match[4].Value.Trim() }} | % { $q = $_._path_name ; $q = "B:\Unsorted\tempRepo\" + $q -replace("/","\") ; $q   } ; 
cd 'B:\Unsorted\tempRepo\' ; $Pattern = "^(.{13})(.{11})(\S{3,})\s(.*)$"; $Data = Get-Content 'B:\Unsorted\tempRepo\.git\filter-repo\analysis\path-all-sizes.txt' -Encoding UTF8 | select -Skip 1 ; $Headers = $Data[0].replace(" ","_") -split "," ; $Data = $data | select -Skip 1 ; $Headers[0],$Headers[1],$Headers[2],$Headers[3] ;  $Data | %{ $Match = (($_ | Select-String $Pattern).matches.groups) ; [PSCustomObject]@{ $Headers[0] = $Match[1].Value.Trim() ; $Headers[1] = $Match[2].Value.Trim(); $Headers[2] = $Match[3].Value.Trim(); $Headers[3] = $Match[4].Value.Trim() }} | % { $q = $_._path_name ; $q = "B:\Unsorted\tempRepo\" + $q -replace("/","\") ; $q | Get-Item  } ; 
cd 'B:\Unsorted\tempRepo\' ; $Pattern = "^(.{13})(.{11})(\S{3,})\s(.*)$"; $Data = Get-Content 'B:\Unsorted\tempRepo\.git\filter-repo\analysis\path-all-sizes.txt' -Encoding UTF8 | select -Skip 1 ; $Headers = $Data[0].replace(" ","_") -split "," ; $Data = $data | select -Skip 1 ; $Headers[0],$Headers[1],$Headers[2],$Headers[3] ;  $Data | %{ $Match = (($_ | Select-String $Pattern).matches.groups) ; [PSCustomObject]@{ $Headers[0] = $Match[1].Value.Trim() ; $Headers[1] = $Match[2].Value.Trim(); $Headers[2] = $Match[3].Value.Trim(); $Headers[3] = $Match[4].Value.Trim() }} | % { $q = $_._path_name ; $q = "B:\Unsorted\tempRepo\" + $q -replace("/","\") ; $q | Get-Item -ErrorAction SilentlyContinue  } ; 
cd 'B:\Unsorted\tempRepo\' ; $Pattern = "^(.{13})(.{11})(\S{3,})\s(.*)$"; $Data = Get-Content 'B:\Unsorted\tempRepo\.git\filter-repo\analysis\path-all-sizes.txt' -Encoding UTF8 | select -Skip 1 ; $Headers = $Data[0].replace(" ","_") -split "," ; $Data = $data | select -Skip 1 ; $Headers[0],$Headers[1],$Headers[2],$Headers[3] ;  $Data | %{ $Match = (($_ | Select-String $Pattern).matches.groups) ; [PSCustomObject]@{ $Headers[0] = $Match[1].Value.Trim() ; $Headers[1] = $Match[2].Value.Trim(); $Headers[2] = $Match[3].Value.Trim(); $Headers[3] = $Match[4].Value.Trim() }} | % { $q = $_._path_name ; $q = "B:\Unsorted\tempRepo\" + $q -replace("/","\") ; $q | split-path -Leaf } ; 
cd 'B:\Unsorted\tempRepo\' ; $Pattern = "^(.{13})(.{11})(\S{3,})\s(.*)$"; $Data = Get-Content 'B:\Unsorted\tempRepo\.git\filter-repo\analysis\path-all-sizes.txt' -Encoding UTF8 | select -Skip 1 ; $Headers = $Data[0].replace(" ","_") -split "," ; $Data = $data | select -Skip 1 ; $Headers[0],$Headers[1],$Headers[2],$Headers[3] ;  $Data | %{ $Match = (($_ | Select-String $Pattern).matches.groups) ; [PSCustomObject]@{ $Headers[0] = $Match[1].Value.Trim() ; $Headers[1] = $Match[2].Value.Trim(); $Headers[2] = $Match[3].Value.Trim(); $Headers[3] = $Match[4].Value.Trim() ; filename=( "B:\Unsorted\tempRepo\" + $match[4].Value.Trim() -replace("/","\") | split-path -Leaf ) }}  ; 
cd 'B:\Unsorted\tempRepo\' ; $Pattern = "^(.{13})(.{11})(\S{3,})\s(.*)$"; $Data = Get-Content 'B:\Unsorted\tempRepo\.git\filter-repo\analysis\path-all-sizes.txt' -Encoding UTF8 | select -Skip 1 ; $Headers = $Data[0].replace(" ","_") -split "," ; $Data = $data | select -Skip 1 ; $Headers[0],$Headers[1],$Headers[2],$Headers[3] ;  $Data | %{ $Match = (($_ | Select-String $Pattern).matches.groups) ; [PSCustomObject]@{ $Headers[0] = $Match[1].Value.Trim() ; $Headers[1] = $Match[2].Value.Trim(); $Headers[2] = $Match[3].Value.Trim(); $Headers[3] = $Match[4].Value.Trim() ; filename=( "B:\Unsorted\tempRepo\" + $match[4].Value.Trim() -replace("/","\") | split-path -Leaf ) }}  | Group-Object -Property filename
cd 'B:\Unsorted\tempRepo\' ; $Pattern = "^(.{13})(.{11})(\S{3,})\s(.*)$"; $Data = Get-Content 'B:\Unsorted\tempRepo\.git\filter-repo\analysis\path-all-sizes.txt' -Encoding UTF8 | select -Skip 1 ; $Headers = $Data[0].replace(" ","_") -split "," ; $Data = $data | select -Skip 1 ; $Headers[0],$Headers[1],$Headers[2],$Headers[3] ;  $Data | %{ $Match = (($_ | Select-String $Pattern).matches.groups) ; [PSCustomObject]@{ $Headers[0] = $Match[1].Value.Trim() ; $Headers[1] = $Match[2].Value.Trim(); $Headers[2] = $Match[3].Value.Trim(); $Headers[3] = $Match[4].Value.Trim() ; filename=( "B:\Unsorted\tempRepo\" + $match[4].Value.Trim() -replace("/","\") | split-path -Leaf ) }}  | Group-Object -Property filename | Sort-Object -Property Name
cd 'B:\Unsorted\tempRepo\' ; $Pattern = "^(.{13})(.{11})(\S{3,})\s(.*)$"; $Data = Get-Content 'B:\Unsorted\tempRepo\.git\filter-repo\analysis\path-all-sizes.txt' -Encoding UTF8 | select -Skip 1 ; $Headers = $Data[0].replace(" ","_") -split "," ; $Data = $data | select -Skip 1 ; $Headers[0],$Headers[1],$Headers[2],$Headers[3] ;  $Data | %{ $Match = (($_ | Select-String $Pattern).matches.groups) ; [PSCustomObject]@{ $Headers[0] = $Match[1].Value.Trim() ; $Headers[1] = $Match[2].Value.Trim(); $Headers[2] = $Match[3].Value.Trim(); $Headers[3] = $Match[4].Value.Trim() ; filename=( "B:\Unsorted\tempRepo\" + $match[4].Value.Trim() -replace("/","\") | split-path -Leaf ) }}  | Group-Object -Property filename | Sort-Object -Property Name | select name
$table ='App.config`
App.g.cs`
App.g.i.cs`
App.xaml`
App.xaml.cs`
AppendMultiplyParameterObject.cs`
AssemblyInfo.cs`
BaseNotifyModel.cs`
Butik.cs`
Butik.datasource`
butik_1.cs`
butik_1.Designer.cs`
butik_1.resx`
Calculator_CBrobäck.rar`
ClassDiagram1.cd`
CollectionHolder.cs`
CollectionHolder.datasource`
CollectionHolder.ShoppingList.cs`
CollectionHolder.ShoppingListItem.cs`
collectionHolder_1.cs`
CommandManager.cs`
Controller.cs`
Csharp-karlstad-butik.code-workspace`
data.xsl`
Databindings.cs`
DesignTimeResolveAssemblyReferences.cache`
DesignTimeResolveAssemblyReferencesInput.cache`
DragningsGenerator.cs`
DynamicXml.cs`
encodings.xml`
ErializeXML.cs`
EventHandlers.cs`
extensions.json`
Filhantering.cs`
Form1.cs`
Form1.Designer.cs`
Form1.resx`
Form1s.resx`
git_toolbox_prj.xml`
indexLayout.xml`
Inventarie.cs`
InventarieLista.cs`
Item.cs`
karlstad1.csproj`
karlstad1.csproj.user`
karlstad1.sln`
karlstad1-discarded.sln`
Karlstad2.csproj.user`
Karlstad2.sln`
Karlstad2-discarded.csproj`
Karlstad2-discarded.sln`
karlstad3.csproj.AssemblyReference.cache`
karlstad3.csproj.CoreCompileInputs.cache`
karlstad3.csproj.FileListAbsolute.txt`
karlstad3.csproj.GenerateResource.cache`
karlstad3.pdb`
karlstad3.sln`
karlstad3.UserControl1.resources`
Karlstad4Butik.csproj`
Karlstad4Butik.sln`
Kassa.cs`
KassaFonster.cs`
KassaFonster.Designer.cs`
KassaFonster.Desinger.cs`
KassaFonster.resx`
Lagerarbete.cs`
LagerFonster.cs`
LagerFonster.Designer.~cs`
LagerFonster.Designer.cs`
LagerFonster.resx`
Lotto.csproj`
Lotto.csproj.AssemblyReference.cache`
Lotto.csproj.CoreCompileInputs.cache`
Lotto.csproj.FileListAbsolute.txt`
Lotto.csproj.GenerateResource.cache`
Lotto_CBrobäck.rar`
MainWindow.baml`
MainWindow.g.cs`
MainWindow.g.i.cs`
MainWindow.xaml`
MainWindow.xaml.~cs`
MainWindow.xaml.cs`
Menu.cs`
Metadata.cs`
Model.cs`
namae.txt`
NewFile.cs`
NotifierOfChange.cs`
Product.book.cs`
product.cs`
produkt.Game.cs`
produkt.Movie.cs`
Program.cs`
Project_Default.xml`
ProjectSettings.json`
projectSettingsUpdater.xml`
Properties.Resources.Designer.cs.dll`
read.lock`
RegisterController.cs`
RegisterController.datasource`
RegisterObject.cs`
reknare.cs`
RelayCommand.cs`
Resources.Designer.cs`
Resources.resx`
SerializeXml.cs`
Settings.Designer.cs`
Settings.settings`
shelved.patch`
ShoppinglistItem.cs`
slnx.sqlite`
StatusEvent.cs`
System.FileStyleUriParser.datasource`
System.FtpStyleUriParser.datasource`
System.GenericUriParser.datasource`
System.GopherStyleUriParser.datasource`
System.HttpStyleUriParser.datasource`
System.LdapStyleUriParser.datasource`
System.NetPipeStyleUriParser.datasource`
System.NetTcpStyleUriParser.datasource`
System.NewsStyleUriParser.datasource`
System.StringNormalizationExtensions.datasource`
System.Uri.datasource`
System.UriBuilder.datasource`
System.UriFormatException.datasource`
System.UriParser.datasource`
System.UriTypeConverter.datasource`
TabbedMDIChildForms.csproj`
TabbedMDIChildForms.csproj.AssemblyReference.cache`
testlog.manifest`
Uncommitted_changes_before_Checkout_at_2023-09-16_01_11__Changes_.xml`
upg11.csproj`
upg11.sln`
UserControl1.cs`
UserControl1.datasource`
UserControl1.Designer.cs`
UserControl1.resx`
vcs.xml`
VSWorkspaceState.json`
WindowsFormsControlLibrary1.csproj`
WindowsFormsControlLibrary1.sln`
workspace.xml`
WpfFUnctional.csproj`
WPfFunctional.sln`
WPFSample.csproj`
WPFSample.csproj.AssemblyReference.cache`
WPFSample.csproj.CoreCompileInputs.cache`
WPFSample.csproj.FileListAbsolute.txt`
WPFSample.csproj.GenerateResource.cache`
WPFSample.exe`
WPFSample.exe.config`
WPFSample.g.resources`
WPFSample.pdb`
WPFSample.Properties.Resources.resources`
WPFSample.sln`
WPFSample_Content.g.cs`
WPFSample_Content.g.i.cs`
WPFSample_MarkupCompile.cache`
WPFSample_MarkupCompile.i.cache`
WPFSample_MarkupCompile.i.lref`
WPFSample_MarkupCompile.lref'
$table
cd 'B:\Unsorted\tempRepo\' ; $Pattern = "^(.{13})(.{11})(\S{3,})\s(.*)$"; $Data = Get-Content 'B:\Unsorted\tempRepo\.git\filter-repo\analysis\path-all-sizes.txt' -Encoding UTF8 | select -Skip 1 ; $Headers = $Data[0].replace(" ","_") -split "," ; $Data = $data | select -Skip 1 ; $Headers[0],$Headers[1],$Headers[2],$Headers[3] ;  $Data | %{ $Match = (($_ | Select-String $Pattern).matches.groups) ; [PSCustomObject]@{ $Headers[0] = $Match[1].Value.Trim() ; $Headers[1] = $Match[2].Value.Trim(); $Headers[2] = $Match[3].Value.Trim(); $Headers[3] = $Match[4].Value.Trim() ; filename=( "B:\Unsorted\tempRepo\" + $match[4].Value.Trim() -replace("/","\") | split-path -Leaf ) }}  | ?{ $_.filename -in $table }
set-location 'B:\Unsorted\tempRepo\' ; $Pattern = "^(.{13})(.{11})(\S{3,})\s(.*)$"; $Data = Get-Content 'B:\Unsorted\tempRepo\.git\filter-repo\analysis\path-all-sizes.txt' -Encoding UTF8 | select -Skip 1 ; $Headers = $Data[0].replace(" ","_") -split "," ; $Data = $data | select -Skip 1 ; $Headers[0],$Headers[1],$Headers[2],$Headers[3] ;  $Data | %{ $Match = (($_ | Select-String $Pattern).matches.groups) ; [PSCustomObject]@{ $Headers[0] = $Match[1].Value.Trim() ; $Headers[1] = $Match[2].Value.Trim(); $Headers[2] = $Match[3].Value.Trim(); $Headers[3] = $Match[4].Value.Trim() ; filename=( "B:\Unsorted\tempRepo\" + $match[4].Value.Trim() -replace("/","\") | split-path -Leaf ) }}  | ?{ $_.filename -in $table }
$table
$table | %{ $_ }
$table @( $table | %{ $_ } )
$table = @( $table | %{ $_ } )
$table
set-location 'B:\Unsorted\tempRepo\' ; $Pattern = "^(.{13})(.{11})(\S{3,})\s(.*)$"; $Data = Get-Content 'B:\Unsorted\tempRepo\.git\filter-repo\analysis\path-all-sizes.txt' -Encoding UTF8 | select -Skip 1 ; $Headers = $Data[0].replace(" ","_") -split "," ; $Data = $data | select -Skip 1 ; $Headers[0],$Headers[1],$Headers[2],$Headers[3] ;  $Data | %{ $Match = (($_ | Select-String $Pattern).matches.groups) ; [PSCustomObject]@{ $Headers[0] = $Match[1].Value.Trim() ; $Headers[1] = $Match[2].Value.Trim(); $Headers[2] = $Match[3].Value.Trim(); $Headers[3] = $Match[4].Value.Trim() ; filename=( "B:\Unsorted\tempRepo\" + $match[4].Value.Trim() -replace("/","\") | split-path -Leaf ) }}  | ?{ $_.filename -in $table }
set-location 'B:\Unsorted\tempRepo\' ; $Pattern = "^(.{13})(.{11})(\S{3,})\s(.*)$"; $Data = Get-Content 'B:\Unsorted\tempRepo\.git\filter-repo\analysis\path-all-sizes.txt' -Encoding UTF8 | select -Skip 1 ; $Headers = $Data[0].replace(" ","_") -split "," ; $Data = $data | select -Skip 1 ; $Headers[0],$Headers[1],$Headers[2],$Headers[3] ;  $Data | %{ $Match = (($_ | Select-String $Pattern).matches.groups) ; [PSCustomObject]@{ $Headers[0] = $Match[1].Value.Trim() ; $Headers[1] = $Match[2].Value.Trim(); $Headers[2] = $Match[3].Value.Trim(); $Headers[3] = $Match[4].Value.Trim() ; filename=( "B:\Unsorted\tempRepo\" + $match[4].Value.Trim() -replace("/","\") | split-path -Leaf ) }}  | ?{ $_.filename -match $table }
set-location 'B:\Unsorted\tempRepo\' ; $Pattern = "^(.{13})(.{11})(\S{3,})\s(.*)$"; $Data = Get-Content 'B:\Unsorted\tempRepo\.git\filter-repo\analysis\path-all-sizes.txt' -Encoding UTF8 | select -Skip 1 ; $Headers = $Data[0].replace(" ","_") -split "," ; $Data = $data | select -Skip 1 ; $Headers[0],$Headers[1],$Headers[2],$Headers[3] ;  $Data | %{ $Match = (($_ | Select-String $Pattern).matches.groups) ; [PSCustomObject]@{ $Headers[0] = $Match[1].Value.Trim() ; $Headers[1] = $Match[2].Value.Trim(); $Headers[2] = $Match[3].Value.Trim(); $Headers[3] = $Match[4].Value.Trim() ; filename=( "B:\Unsorted\tempRepo\" + $match[4].Value.Trim() -replace("/","\") | split-path -Leaf ) }}  | ?{ $_.filename -like $table }
set-location 'B:\Unsorted\tempRepo\' ; $Pattern = "^(.{13})(.{11})(\S{3,})\s(.*)$"; $Data = Get-Content 'B:\Unsorted\tempRepo\.git\filter-repo\analysis\path-all-sizes.txt' -Encoding UTF8 | select -Skip 1 ; $Headers = $Data[0].replace(" ","_") -split "," ; $Data = $data | select -Skip 1 ; $Headers[0],$Headers[1],$Headers[2],$Headers[3] ;  $Data | %{ $Match = (($_ | Select-String $Pattern).matches.groups) ; [PSCustomObject]@{ $Headers[0] = $Match[1].Value.Trim() ; $Headers[1] = $Match[2].Value.Trim(); $Headers[2] = $Match[3].Value.Trim(); $Headers[3] = $Match[4].Value.Trim() ; filename=( "B:\Unsorted\tempRepo\" + $match[4].Value.Trim() -replace("/","\") | split-path -Leaf ) }} 
$table = @( $table | %{ $_.trim() } )
set-location 'B:\Unsorted\tempRepo\' ; $Pattern = "^(.{13})(.{11})(\S{3,})\s(.*)$"; $Data = Get-Content 'B:\Unsorted\tempRepo\.git\filter-repo\analysis\path-all-sizes.txt' -Encoding UTF8 | select -Skip 1 ; $Headers = $Data[0].replace(" ","_") -split "," ; $Data = $data | select -Skip 1 ; $Headers[0],$Headers[1],$Headers[2],$Headers[3] ;  $Data | %{ $Match = (($_ | Select-String $Pattern).matches.groups) ; [PSCustomObject]@{ $Headers[0] = $Match[1].Value.Trim() ; $Headers[1] = $Match[2].Value.Trim(); $Headers[2] = $Match[3].Value.Trim(); $Headers[3] = $Match[4].Value.Trim() ; filename=( "B:\Unsorted\tempRepo\" + $match[4].Value.Trim() -replace("/","\") | split-path -Leaf ) }}  | ?{ $_.filename -like $table }
set-location 'B:\Unsorted\tempRepo\' ; $Pattern = "^(.{13})(.{11})(\S{3,})\s(.*)$"; $Data = Get-Content 'B:\Unsorted\tempRepo\.git\filter-repo\analysis\path-all-sizes.txt' -Encoding UTF8 | select -Skip 1 ; $Headers = $Data[0].replace(" ","_") -split "," ; $Data = $data | select -Skip 1 ; $Headers[0],$Headers[1],$Headers[2],$Headers[3] ;  $Data | %{ $Match = (($_ | Select-String $Pattern).matches.groups) ; [PSCustomObject]@{ $Headers[0] = $Match[1].Value.Trim() ; $Headers[1] = $Match[2].Value.Trim(); $Headers[2] = $Match[3].Value.Trim(); $Headers[3] = $Match[4].Value.Trim() ; filename=( "B:\Unsorted\tempRepo\" + $match[4].Value.Trim() -replace("/","\") | split-path -Leaf ) }}  | ?{ $_.filename -in $table }
set-location 'B:\Unsorted\tempRepo\' ; $Pattern = "^(.{13})(.{11})(\S{3,})\s(.*)$"; $Data = Get-Content 'B:\Unsorted\tempRepo\.git\filter-repo\analysis\path-all-sizes.txt' -Encoding UTF8 | select -Skip 1 ; $Headers = $Data[0].replace(" ","_") -split "," ; $Data = $data | select -Skip 1 ; $Headers[0],$Headers[1],$Headers[2],$Headers[3] ;  $Data | %{ $Match = (($_ | Select-String $Pattern).matches.groups) ; [PSCustomObject]@{ $Headers[0] = $Match[1].Value.Trim() ; $Headers[1] = $Match[2].Value.Trim(); $Headers[2] = $Match[3].Value.Trim(); $Headers[3] = $Match[4].Value.Trim() ; filename=( "B:\Unsorted\tempRepo\" + $match[4].Value.Trim() -replace("/","\") | split-path -Leaf ) }}  | ?{ $_.filename -cin $table }
set-location 'B:\Unsorted\tempRepo\' ; $Pattern = "^(.{13})(.{11})(\S{3,})\s(.*)$"; $Data = Get-Content 'B:\Unsorted\tempRepo\.git\filter-repo\analysis\path-all-sizes.txt' -Encoding UTF8 | select -Skip 1 ; $Headers = $Data[0].replace(" ","_") -split "," ; $Data = $data | select -Skip 1 ; $Headers[0],$Headers[1],$Headers[2],$Headers[3] ;  $Data | %{ $Match = (($_ | Select-String $Pattern).matches.groups) ; [PSCustomObject]@{ $Headers[0] = $Match[1].Value.Trim() ; $Headers[1] = $Match[2].Value.Trim(); $Headers[2] = $Match[3].Value.Trim(); $Headers[3] = $Match[4].Value.Trim() ; filename=( "B:\Unsorted\tempRepo\" + $match[4].Value.Trim() -replace("/","\") | split-path -Leaf ) }}  | ?{  $table -contains $_.filename }
$table |Measure-Object
$table = @( $table -split '\r?\n|\r' | %{ $_.trim() } )
$table |Measure-Object
set-location 'B:\Unsorted\tempRepo\' ; $Pattern = "^(.{13})(.{11})(\S{3,})\s(.*)$"; $Data = Get-Content 'B:\Unsorted\tempRepo\.git\filter-repo\analysis\path-all-sizes.txt' -Encoding UTF8 | select -Skip 1 ; $Headers = $Data[0].replace(" ","_") -split "," ; $Data = $data | select -Skip 1 ; $Headers[0],$Headers[1],$Headers[2],$Headers[3] ;  $Data | %{ $Match = (($_ | Select-String $Pattern).matches.groups) ; [PSCustomObject]@{ $Headers[0] = $Match[1].Value.Trim() ; $Headers[1] = $Match[2].Value.Trim(); $Headers[2] = $Match[3].Value.Trim(); $Headers[3] = $Match[4].Value.Trim() ; filename=( "B:\Unsorted\tempRepo\" + $match[4].Value.Trim() -replace("/","\") | split-path -Leaf ) }}  | ?{  $table -contains $_.filename }
$table
$table = @( Get-Clipboard -split '\r?\n|\r' | %{ $_.trim() } ); $table 
$table = @( $q = Get-Clipboard; $q -split '\r?\n|\r' | %{ $_.trim() } ); $table 
$table | %{ $_ -notin @( Get-Clipboard -split '\r?\n|\r' | %{ $_.trim() } ) }
$table | %{ $_ -notin @( $u = Get-Clipboard ; $u -split '\r?\n|\r' | %{ $_.trim() } ) }
$table | ?{ $_ -notin @( $u = Get-Clipboard ; $u -split '\r?\n|\r' | %{ $_.trim() } ) }
$table = $table | ?{ $_ -notin @( $u = Get-Clipboard ; $u -split '\r?\n|\r' | %{ $_.trim() } ) } ; $table
$table | Set-Clipboard
set-location 'B:\Unsorted\tempRepo\' ; $Pattern = "^(.{13})(.{11})(\S{3,})\s(.*)$"; $Data = Get-Content 'B:\Unsorted\tempRepo\.git\filter-repo\analysis\path-all-sizes.txt' -Encoding UTF8 | select -Skip 1 ; $Headers = $Data[0].replace(" ","_") -split "," ; $Data = $data | select -Skip 1 ; $Headers[0],$Headers[1],$Headers[2],$Headers[3] ;  $Data | %{ $Match = (($_ | Select-String $Pattern).matches.groups) ; [PSCustomObject]@{ $Headers[0] = $Match[1].Value.Trim() ; $Headers[1] = $Match[2].Value.Trim(); $Headers[2] = $Match[3].Value.Trim(); $Headers[3] = $Match[4].Value.Trim() ; filename=( "B:\Unsorted\tempRepo\" + $match[4].Value.Trim() -replace("/","\") | split-path -Leaf ) }}  | ?{  $table -contains $_.filename }
$Pattern = "^(.{13})(.{11})(\S{3,})\s(.*)$"; $Data = Get-Content 'B:\Unsorted\tempRepo\.git\filter-repo\analysis\path-all-sizes.txt' -Encoding UTF8 | select -Skip 1 ; $Headers = $Data[0].replace(" ","_") -split "," ; $Data = $data | select -Skip 1 ; $Headers[0],$Headers[1],$Headers[2],$Headers[3] ;  $Data | %{ $Match = (($_ | Select-String $Pattern).matches.groups) ; [PSCustomObject]@{ $Headers[0] = $Match[1].Value.Trim() ; $Headers[1] = $Match[2].Value.Trim(); $Headers[2] = $Match[3].Value.Trim(); $Headers[3] = $Match[4].Value.Trim() ; filename=( "B:\Unsorted\tempRepo\" + $match[4].Value.Trim() -replace("/","\") | split-path -Leaf ) }}  | ?{  $table -contains $_.filename }
$Pattern = "^(.{13})(.{11})(\S{3,})\s(.*)$"; $Data = Get-Content 'B:\Unsorted\tempRepo\.git\filter-repo\analysis\path-all-sizes.txt' -Encoding UTF8 | select -Skip 1 ; $Headers = $Data[0].replace(" ","_") -split "," ; $Data = $data | select -Skip 1 ; $Headers[0],$Headers[1],$Headers[2],$Headers[3] ;  $Data | %{ $Match = (($_ | Select-String $Pattern).matches.groups) ; [PSCustomObject]@{ $Headers[0] = $Match[1].Value.Trim() ; $Headers[1] = $Match[2].Value.Trim(); $Headers[2] = $Match[3].Value.Trim(); $Headers[3] = $Match[4].Value.Trim() ; filename=( "B:\Unsorted\tempRepo\" + $match[4].Value.Trim() -replace("/","\") | split-path -Leaf ) }}  | ?{  $table -contains $_.filename } | %{ [PSCustomObject]@{ path=$_._path_name, alias=$_.filename } }
$Pattern = "^(.{13})(.{11})(\S{3,})\s(.*)$"; $Data = Get-Content 'B:\Unsorted\tempRepo\.git\filter-repo\analysis\path-all-sizes.txt' -Encoding UTF8 | select -Skip 1 ; $Headers = $Data[0].replace(" ","_") -split "," ; $Data = $data | select -Skip 1 ; $Headers[0],$Headers[1],$Headers[2],$Headers[3] ;  $Data | %{ $Match = (($_ | Select-String $Pattern).matches.groups) ; [PSCustomObject]@{ $Headers[0] = $Match[1].Value.Trim() ; $Headers[1] = $Match[2].Value.Trim(); $Headers[2] = $Match[3].Value.Trim(); $Headers[3] = $Match[4].Value.Trim() ; filename=( "B:\Unsorted\tempRepo\" + $match[4].Value.Trim() -replace("/","\") | split-path -Leaf ) }}  | ?{  $table -contains $_.filename } | %{ [PSCustomObject]@{ path=$_._path_name; alias=$_.filename } }
Import-Module posh-git
git state
git status
 merge-ours 'refs/remotes/General-ProjectFolders/Before'
$table | Set-Clipboard
Get-Clipboard | %{$regex = [regex]::Escape('https://open.spotify.com/playlist/') ; $_ -replace $regex, 'spotify:user:spotify:playlist:' -replace '\?si=.*', '' } | set-clipboard
git remote add 'B:\PF\CSharpVisualStudio\repos\karlstad\KarlstadButik'
git remote add --fetch origion 'B:\PF\CSharpVisualStudio\repos\karlstad\KarlstadButik'
git remote add --fetch origion 'App.config'
App.xaml
App.xaml.cs
AppendMultiplyParameterObject.cs
AssemblyInfo.cs
BaseNotifyModel.cs
Butik.cs
Butik.datasource
butik_1.cs
butik_1.Designer.cs
butik_1.resx
CollectionHolder.cs
CollectionHolder.datasource
CollectionHolder.ShoppingList.cs
CollectionHolder.ShoppingListItem.cs
collectionHolder_1.cs
CommandManager.cs
Controller.cs
Csharp-karlstad-butik.code-workspace
data.xsl
Databindings.cs
DragningsGenerator.cs
DynamicXml.cs
encodings.xml
ErializeXML.cs
EventHandlers.cs
extensions.json
Filhantering.cs
Form1.cs
Form1.Designer.cs
Form1.resx
Form1s.resx
git_toolbox_prj.xml
indexLayout.xml
Inventarie.cs
InventarieLista.cs
Item.cs
karlstad1.csproj
karlstad1.csproj.user
karlstad1.sln
karlstad1-discarded.sln
Karlstad2.csproj.user
Karlstad2.sln
karlstad3.pdb
karlstad3.sln
karlstad3.UserControl1.resources
Karlstad4Butik.csproj
Karlstad4Butik.sln
Kassa.cs
KassaFonster.cs
KassaFonster.Designer.cs
KassaFonster.Desinger.cs
KassaFonster.resx
Lagerarbete.cs
LagerFonster.cs
LagerFonster.Designer.~cs
LagerFonster.Designer.cs
LagerFonster.resx
Lotto.csproj
MainWindow.xaml
MainWindow.xaml.~cs
MainWindow.xaml.cs
Menu.cs
Metadata.cs
Model.cs
namae.txt
NewFile.cs
NotifierOfChange.cs
Product.book.cs
product.cs
produkt.Game.cs
produkt.Movie.cs
Program.cs
Project_Default.xml
ProjectSettings.json
projectSettingsUpdater.xml
Properties.Resources.Designer.cs.dll
read.lock
RegisterController.cs
RegisterController.datasource
RegisterObject.cs
reknare.cs
RelayCommand.cs
Resources.Designer.cs
Resources.resx
SerializeXml.cs
Settings.Designer.cs
Settings.settings
shelved.patch
ShoppinglistItem.cs
slnx.sqlite
StatusEvent.cs
System.FileStyleUriParser.datasource
System.FtpStyleUriParser.datasource
System.GenericUriParser.datasource
System.GopherStyleUriParser.datasource
System.HttpStyleUriParser.datasource
System.LdapStyleUriParser.datasource
System.NetPipeStyleUriParser.datasource
System.NetTcpStyleUriParser.datasource
System.NewsStyleUriParser.datasource
System.StringNormalizationExtensions.datasource
System.Uri.datasource
System.UriBuilder.datasource
System.UriFormatException.datasource
System.UriParser.datasource
System.UriTypeConverter.datasource
TabbedMDIChildForms.csproj
upg11.csproj
upg11.sln
UserControl1.cs
UserControl1.datasource
UserControl1.Designer.cs
UserControl1.resx
vcs.xml
VSWorkspaceState.json
WindowsFormsControlLibrary1.csproj
WindowsFormsControlLibrary1.sln
workspace.xml
WpfFUnctional.csproj
WPfFunctional.sln
WPFSample.csproj
everything.exe -instance "NasRecycle" -database "C:\Users\CrRoot\AppData\Roaming\Avant Profiles\Everything.db" -settings "B:\PF\Archive\NewWindows\scoopbucket-presist\Everything\Everything.ini" 
es.exe -instance "NasRecycle" -database "C:\Users\CrRoot\AppData\Roaming\Avant Profiles\Everything.db" -settings "B:\PF\Archive\NewWindows\scoopbucket-presist\Everything\Everything.ini" 
git remote add Ahk_config czx:czx
git remote -v
git remote add Ahk_config https://github.com/czx/Ahk_config.git
git branch -vv 
git status
git pull
scoop install revo-uninstaller
scoop install revouninstaller
merge-ours 'refs/heads/czx'
git filter-repo --analyze --force
. B:\PF\Archive\ps1\git\lib\git-Temp.ps1
Copy-Function Invoke-GitTemp
git push --all 'B:\Unsorted\ps1'
git fetch 'B:\PF\Archive\ps1\' --all
git fetch 'B:\PF\Archive\ps1\' 
git remote orginx 'B:\PF\Archive\ps1\' 
git remote 'B:\PF\Archive\ps1\' orginx
git remote add orginx 'B:\PF\Archive\ps1\' 
function Git-disable-OwnershipCheck { git config --global core.ignoreStat all }
Copy-Function Git-disable-OwnershipCheck
git push --all 'B:\PF\CSharpVisualStudio\repos\karlstad\KarlstadButik\KarlstadButik'
git push -h
git push --tags 'B:\PF\CSharpVisualStudio\repos\karlstad\KarlstadButik\KarlstadButik'
git push --tags 'B:\PF\CSharpVisualStudio\repos\karlstad\KarlstadButik\'
git push --all 'B:\PF\CSharpVisualStudio\repos\karlstad\KarlstadButik\'
$pwd
git push --all 'B:\PF\CSharpVisualStudio\repos\karlstad\Wpf-Upgift 1'
merge-ours 2
merge-ours 3
merge-ours 4
merge-ours 5
merge-ours 6
git filter-repo --refs 'Shoppinglist' --path 'CollectionHolder.cs'
git filter-repo --refs 'Shoppinglist' --path 'CollectionHolder.cs' --force
git config --list
git config --list mergetool
git config --get mergetool
git config --global --get mergetool
git config --global --list
git config --global --get merge
git config --global --get merge.tool
git config --global --get mergetool.bc
Import-Module posh-git
git config --global --get mergetool.bc
git config --global --get mergetool
git config --global --get-all merge.tool
git config --global --get-all merge
git config --global --get mergetool.bc.cmd
bcomp
git config --global -
git config --global 
git config --global --list --show-origin
git push 'Stable_runns_errorOnOpening' 'B:\PF\CSharpVisualStudio\repos\karlstad\KarlstadButik\New folder'
git push 'B:\PF\CSharpVisualStudio\repos\karlstad\KarlstadButik\New folder' 'Stable_runns_errorOnOpening'
git push 'B:\PF\CSharpVisualStudio\repos\karlstad\KarlstadButik\New folder\.git' 'Stable_runns_errorOnOpening'
git push 'B:\PF\CSharpVisualStudio\repos\karlstad\KarlstadButik\New folder\.git' oic
git filter-repo
git filter-repo -h
git filter-repo --parent-filter 'if [ "$GIT_COMMIT" = 1053f682d380bee311ea95135336c995fa072aa0 ]; then echo a826b7ec99a6608f291b00ebc6c4225ddf75c738; else echo "$GIT_COMMIT"; fi'
install-module -name re
install-module -name regexhelper
install-module -name re
get-psrepository
Install-Module -Name re -Repository PSGalleryRolling
Register-PSRepository -Name PSGallery -SourceLocation https://www.powershellgallery.com/api/v3/ -Force
Register-PSRepository -Name PSGallery -SourceLocation https://www.powershellgallery.com/api/v3/
scoop install okibcn_ScoopMaster/Dependency-Walker_(1)
scoop install Dependency-Walker_(1)
scoop install Dependency-Walker
scoop install dllexportviewer
scoop install vs_buildtools
scoop uninstall vs_buildtools
scoop install vs_buildtools-aoks
scoop install vs_buildtools-aoks -s
conda create --name=3.7 python=3.7
anaconda
python conda
_conda
& C:\Python311\Anaconda\_conda.exe
scoop install okibcn_ScoopMaster/Irfanview-plugins_(1)
scoop install okibcn_ScoopMaster/Irfanview-plugins
irfanview
scoop install extras/scoop-completion
scoop install anderlli0053_DEV-tools/scoop-check
scoop install anderlli0053_DEV-tools/scoop-check -r
sudo scoop install anderlli0053_DEV-tools/scoop-check 
gsudo scoop install anderlli0053_DEV-tools/scoop-check 
scoop install anderlli0053_DEV-tools/scoop-check 
scoop install -s anderlli0053_DEV-tools/scoop-check 
scoop check smartgit
scoop-check smartgit
git rev-parse --git-dir
$pathx = invoke-expression "git rev-parse --git-dir" ; explorer.exe \e $pathx
$pathx = invoke-expression "git rev-parse --git-dir" ; explorer.exe -e $pathx
$pathx = invoke-expression "git rev-parse --git-dir" ; explorer.exe -e "$pathx"
$pathx = invoke-expression "git rev-parse --git-dir" ; cmd \c explorer \e  "$pathx"
$pathx = invoke-expression "git rev-parse --git-dir" ; cmd \c "explorer \e  $pathx"
$pathx = invoke-expression "git rev-parse --git-dir" ; explorer $pathx
$pathx = invoke-expression "git rev-parse --git-dir" ; explorer ( resolve-path $pathx )
git filter-repo --rename-path settings/Fork:script/Fork
git filter-repo --rename-path Data/Fork:script/Fork
git filter-repo --path-rename Data/Fork:script/Fork
git filter-repo --path-rename Data/Fork:script/Fork --force
git filter-repo --path-rename settings/Fork:script/Fork --force
git filter-repo --rename-path Main.ahk:AutoHotkey.ahk --refs portable
git filter-repo --rename-path Main.ahk:AutoHotkey.ahk --refs portable --force
git filter-repo --rename-path Main.ahk:AutoHotkey.ahk --refs Portable --force
cd 'B:\PF\.git\modules\NoteTakingProjectFolder'
set-dir 'B:\PF\.git\modules\NoteTakingProjectFolder'
set-directory 'B:\PF\.git\modules\NoteTakingProjectFolder'
-directory 'B:\PF\.git\modules\NoteTakingProjectFolder'
set-location 'B:\PF\.git\modules\NoteTakingProjectFolder'
git status
git push --all --mirror 'B:\Users\20231011202613080'
git push --mirror 'B:\Users\20231011202613080'
set-location 'B:\Users\20231011202613080'
git push --mirror 'B:\Users\20231011202412429'
git push --all 'B:\Users\20231011202412429'
git status
git push --mirror 'B:\Users\20231011204816165'
Get-WindowsFeature Hyper-V-VirtualSwitch
Install-WindowsFeature Hyper-V-VirtualSwitch
git status
git push
git push origin HEAD:NoteTakingProjectFolder
git log --first-parent HEAD~278..HEAD
git log --first-parent 1..HEAD
git status HEAD
git log HEAD
git log 'origin/NoteTakingProjectFolder'..HEAD
git log origin/NoteTakingProjectFolder..HEAD
git log origin/NoteTakingProjectFolder~270..HEAD
git log origin/NoteTakingProjectFolder..HEAD~270
git log --first-parent origin/NoteTakingProjectFolder..HEAD
git log --first-parent origin/NoteTakingProjectFolder..270~HEAD
git log --first-parent 260..HEAD
git log --help
git log --first-parent origin/NoteTakingProjectFolder..masterc~10
git log --first-parent origin/NoteTakingProjectFolder..masterc~250
git log --first-parent origin/NoteTakingProjectFolder..masterc~270
git log --first-parent origin/NoteTakingProjectFolder..masterc~260
git push 'origin/NoteTakingProjectFolder' HEAD..masterc~260
git push 'origin/NoteTakingProjectFolder' origin..masterc~260
git log --first-parent origin..masterc~260
git log --first-parent notetakingprojectfolder..masterc~260
git log --first-parent origin/notetakingprojectfolder..masterc~260
git log --first-parent origin/NoteTakingProjectFolder..masterc~260
git log --first-parent origin/NoteTakingProjectFolder..masterc~265
git log --first-parent origin/NoteTakingProjectFolder..masterc~269
git log --first-parent origin/NoteTakingProjectFolder..masterc~270
git log --first-parent origin/NoteTakingProjectFolder..masterc~269
git log origin/NoteTakingProjectFolder..masterc~269
git push 'origin/NoteTakingProjectFolder' origin/NoteTakingProjectFolder..masterc~269
git push 'origin/NoteTakingProjectFolder' origin/NoteTakingProjectFolder..masterc~200
git push 'origin/NoteTakingProjectFolder' origin/NoteTakingProjectFolder..masterc~100
git push 'origin/NoteTakingProjectFolder' origin/NoteTakingProjectFolder..masterc~50
git push 'origin/NoteTakingProjectFolder' origin/NoteTakingProjectFolder..masterc~20
scoop install apache-nifi
"B:\PF\.git\modules\PowershellProjectFolder\modules\Scripts\modules\yamjyn.commandlist" cd "C:\Program Files\TortoiseGit\bin\TortoiseGitProc.exe" /command:settings
"B:\PF\.git\modules\PowershellProjectFolder\modules\Scripts\modules\yamjyn.commandlist" set-location "C:\Program Files\TortoiseGit\bin\TortoiseGitProc.exe" /command:settings
set-location "B:\PF\.git\modules\PowershellProjectFolder\modules\Scripts\modules\yamjyn.commandlist" ; "C:\Program Files\TortoiseGit\bin\TortoiseGitProc.exe" /command:settings
set-location "B:\PF\.git\modules\PowershellProjectFolder\modules\Scripts\modules\yamjyn.commandlist" ; & "C:\Program Files\TortoiseGit\bin\TortoiseGitProc.exe" /command:settings
set-location "B:\PF\Archive\.git\modules\TextProcessingProjectF\test\xml" ; & "C:\Program Files\TortoiseGit\bin\TortoiseGitProc.exe" /command:settings
scoop install ShellMenuView
es "wfn:child:config"
scoop install regjump
scoop install gitkraken
GIT PUSH
git filter-repo --rename-path 'Scripts:Edit Scripts' --refs RebaseRoot
git filter-repo --path-rename Scripts:'Edit Scripts' --refs RebaseRoot
git filter-repo --path-rename Scripts:'Edit Scripts' --refs RebaseRoot --force
git filter-repo --path-rename 'TES5Edit Scripts':'Edit Scripts' --refs tes --force
git push --all 'B:\Users\target\BeondCompare4'
git push --all 'B:\Users\target\BeondCompare4\.git'
git status
git push --mirror 'B:\Users\target\AppData\Roaming\Scooter Software\Beyond Compare 4'
DiskInfo
scoop install DiskInfo
Diskinfo
scoop uninstall DiskInfo
scoop install crystalDiskInfo
crystalDiskInfo
diskinfo65
diskinfo64
diskinfo
dism /online /cleanup-image /startcomponentcleanup
ndm
scoop install main/pnpm
pnpm i -g align-yaml
pnpm setup
pnpm i -g align-yaml
pnpm i align-yaml
ndm
npm i -g align-yaml
ndm
scoop install main/ast-grep
scoop install diffsitter
scoop install husky
which watchman
watchman watch 'C:\Users\CrRoot\AppData\Roaming\Microsoft\Windows\PowerShell'
$repoPath = 'C:\Users\CrRoot\AppData\Roaming\Microsoft\Windows\PowerShell'
$autoCommitPath ='C:\Users\CrRoot\.config\git\watchman-autocommit\auto-commit.sh'
watchman -- trigger $repoPath auto-commit '*' -- $autoCommitPath
explorer $repoPath
watchman
watchman --help
watchman watch-list
watchman watch-project
watchman since
watchman get-config
watchman list-capabilities
watchman watch
watchman query all
watchman query '*'
watchman watch .
cd $repoPath ; watchman watch .
set-directory $repoPath ; watchman watch .
set-location $repoPath ; watchman watch .
watchman trigger . $autoCommitPath
$autoCommitPath ='C:\Users\CrRoot\.config\git\watchman-autocommit\auto-commit.ps1'
watchman trigger . $autoCommitPath
watchman trigger . 'C:\Users\CrRoot\.config\git\watchman-autocommit\auto-commit.ps1'
watchman trigger . 'C:\Users\CrRoot\.config\git\watchman-autocommit\auto-commit.ps1' -- auto-commit
watchman trigger . 'C:\Users\CrRoot\.config\git\watchman-autocommit\auto-commit.ps1' auto-commit
watchman trigger . . 'C:\Users\CrRoot\.config\git\watchman-autocommit\auto-commit.ps1' auto-commit
watchman trigger . auto-commit
watchman trigger . function auto-commit()
watchman trigger . function auto-commit({ git add --all ; git commit -am "Changed file $*, Auto-Commit V0.1";  git push })
watchman trigger . auto-commit({ git add --all ; git commit -am "Changed file $*, Auto-Commit V0.1";  git push })
watchman trigger . { git add --all ; git commit -am "Changed file $*, Auto-Commit V0.1";  git push }
watchman trigger . ({ git add --all ; git commit -am "Changed file $*, Auto-Commit V0.1";  git push })
$ watchman -j <<-EOT
["trigger", "/path/to/root", {`
  "name": "assets",`
  "expression": ["pcre", "\.(js|css|c|cpp)$"],`
  "command": ["make"]`
}]
$ watchman -j <<-["trigger", "/path/to/root", {  "name": "assets",  "expression": ["pcre", "\.(js|css|c|cpp)$"],  "command": ["make"] }]
$ watchman -j ["trigger", "/path/to/root", {  "name": "assets",  "expression": ["pcre", "\.(js|css|c|cpp)$"],  "command": ["make"] }]
watchman -j ["trigger", "/path/to/root", {  "name": "assets",  "expression": ["pcre", "\.(js|css|c|cpp)$"],  "command": ["make"] }]
set-clipboard '["trigger", "/path/to/root", {  "name": "assets",  "expression": ["pcre", "\.(js|css|c|cpp)$"],  "command": ["make"] }]' ; watchman -j get-clipboard
scoop install watchman
cd 'C:\Users\CrRoot\AppData\Roaming\Microsoft\Windows\PowerShell'
New-VMSwitch -Name "InternalSwitch" -SwitchType Internal
filezilla
get-vmconfigurationFile -path 'C:\ProgramData\Microsoft\Windows\Hyper-V\Virtual Machines Cache\8E8D3964-EBF6-40AC-BD8D-6E0BC1B9C0FA.vmcx'
scoop install StarWind
scoop install okibcn_ScoopMaster/V2V-Converter_(1)
scoop install okibcn_ScoopMaster/V2V-Converter
scoop install V2V-Converter
starwindconverter
set-vmhost -EnableEnhancedSessionMode $True
set-location I
I:
get-diskImage -path .\Porteus-KDE-v5.01-x86_64.iso
Get-ItemProperty -path .\Porteus-KDE-v5.01-x86_64.iso
Get-ItemProperty -v -path .\Porteus-KDE-v5.01-x86_64.iso
Get-ItemProperty -help
Get-ItemProperty -Verbose  -path .\Porteus-KDE-v5.01-x86_64.iso
install-module storage
install-windowsFeature storage-storageCmdlet-vhdmount
install-windowsFeature -online -featurename storage-storageCmdlet-vhdmount
add-windowsCapability -online -name Storage.VHDMount.commandLine
get-diskImage -path .\Porteus-KDE-v5.01-x86_64.iso
get-diskImage .\Porteus-KDE-v5.01-x86_64.iso
B:
get-diskImage .\Porteus-KDE-v5.01-x86_64.iso
get-diskImage -help
get-diskImage 
get-diskImage B:\Porteus-KDE-v5.01-x86_64.iso
get-diskImage I:\Porteus-Kiosk-5.5.0-x86_64.iso
Get-ItemProperty -Verbose  -path .\Porteus-KDE-v5.01-x86_64.iso
get-filemetadata -Verbose  -path .\Porteus-KDE-v5.01-x86_64.iso
scoop install file-identifier
scoop install exiftool
exiftool
exiftoolgui
scoop install exiftoolgui
exiftoolgui
get-content 'HKEY_LOCAL_MACHINE\SOFTWARE\Classes\CLSID\{450D8FBA-AD25-11D0-98A8-0800361B1103}'
cd 'HKEY_LOCAL_MACHINE\SOFTWARE\Classes\CLSID\{450D8FBA-AD25-11D0-98A8-0800361B1103}'
set-location 'HKEY_LOCAL_MACHINE\SOFTWARE\Classes\CLSID\{450D8FBA-AD25-11D0-98A8-0800361B1103}'
'HKEY_LOCAL_MACHINE\SOFTWARE\Classes\CLSID\{450D8FBA-AD25-11D0-98A8-0800361B1103}'
scoop install anderlli0053_DEV-tools/MiniTool-Partition-Wizard-ims
scoop install MiniTool-Partition-Wizard-ims
Irfanview
scoop uninstall Irfanview
# Define a function to get the file extension from trid
function Get-FileExtensionFromTrid($fileName) {`
  # Invoke trid with the file name and capture the output`
  $tridOutput = trid $fileName`
`
  # Check if the output contains any matches`
  if ($tridOutput -match "(\d+\.?\d*)%\s+\((\.\S+)\)\s+(.*)") {`
    # Get the highest percentage match and its corresponding extension`
    $highestMatch = ($tridOutput | Select-String "(\d+\.?\d*)%\s+\((\.\S+)\)\s+(.*)" -AllMatches).Matches | Sort-Object -Property { double } -Descending | Select-Object -First 1`
    $extension = $highestMatch.Groups[2].Value`
`
    # Return the extension`
    return $extension`
  }`
  else {`
    # Return an empty string if no matches are found`
    return ""`
  }`
}
# Define a function to set the file extension if it does not match the one from trid
function Set-FileExtensionIfNotMatch($fileName) {`
  # Get the current file extension`
  $currentExtension = [System.IO.Path]::GetExtension($fileName)`
`
  # Get the expected file extension from trid`
  $expectedExtension = Get-FileExtensionFromTrid($fileName)`
`
  # Check if the current and expected extensions are different`
  if ($currentExtension -ne $expectedExtension) {`
    # Rename the file with the expected extension`
    Rename-Item -Path $fileName -NewName "$($fileName -replace "\.[^.]+$", $expectedExtension)"`
    # Write a message to the output`
    Write-Output "Renamed file '$fileName' to have extension '$expectedExtension'"`
  }`
}
# Get the list of files in the current directory
$files = Get-ChildItem -File
# Loop through each file in the list
foreach ($file in $files) {`
  # Set the file extension if it does not match the one from trid`
  Set-FileExtensionIfNotMatch($file.Name)`
}
$files = Get-ChildItem -File
Get-ChildItem -File
foreach ($file in $files) {`
  # Set the file extension if it does not match the one from trid`
  Set-FileExtensionIfNotMatch($file.Name)`
}
Get-ChildItem -File | % {  Get-FileExtensionFromTrid $_ }
Get-ChildItem -File | select -First 5 | % {  trid $_.FullName }
cd 'D:\#recycle\Users\Default\AppData\Roaming\Opera Software\Opera GX Stable\_side_profiles\a_jew\Cache'
set-location 'D:\#recycle\Users\Default\AppData\Roaming\Opera Software\Opera GX Stable\_side_profiles\a_jew\Cache'
Get-ChildItem -File | select -First 5 | % {  trid $_.FullName }
foreach ($file in $files) {`
  # Set the file extension if it does not match the one from trid`
  Set-FileExtensionIfNotMatch($file.Name)`
}
Get-ChildItem -File | % {  Get-FileExtensionFromTrid $_ }
function Get-FileExtensionFromTrid($fileName) {`
  # Invoke trid with the file name and capture the output`
  $tridOutput = trid $fileName`
`
  # Check if the output contains any matches`
  if ($tridOutput -match "(\d+\.?\d*)%\s+\((\.\S+)\)\s+(.*)") {`
    # Get the highest percentage match and its corresponding extension`
    $highestMatch = ($tridOutput | Select-String "(\d+\.?\d*)%\s+\((\.\S+)\)\s+(.*)" -AllMatches).Matches | Select-Object -First 1`
    $extension = $highestMatch.Groups[2].Value`
`
    # Return the extension`
    return $extension`
  }`
  else {`
    # Return an empty string if no matches are found`
    return ""`
  }`
}
Get-ChildItem -File | % {  Get-FileExtensionFromTrid $_ }
function Get-FileExtensionFromTrid($fileName) {`
  # Invoke trid with the file name and capture the output`
  $tridOutput = trid $fileName`
`
  # Check if the output contains any matches`
  if ($tridOutput -match "(\d+\.?\d*)%\s+\((\.\S+)\)\s+(.*)") {`
    # Get the highest percentage match and its corresponding extension`
    $highestMatch = ($tridOutput | Select-String "(\d+\.?\d*)%\s+\((\.\S+)\)\s+(.*)" -AllMatches).Matches | Select-Object -First 1`
    $extension = ($highestMatch.Groups[2].Value -split '/')[0]`
`
    # Return the extension`
    return $extension`
  }`
  else {`
    # Return an empty string if no matches are found`
    return ""`
  }`
}
Get-ChildItem -File | % {  Get-FileExtensionFromTrid $_ }
function Set-FileExtensionIfNotMatch($fileName) {`
  # Get the current file extension`
  $currentExtension = [System.IO.Path]::GetExtension($fileName)`
`
  # Get the expected file extension from trid`
  $expectedExtension = Get-FileExtensionFromTrid($fileName)`
`
  # Check if the current and expected extensions are different`
  if ($currentExtension -ne $expectedExtension) {`
    # Rename the file with the expected extension`
    Rename-Item -Path $fileName -NewName "$($fileName -replace "\.[^.]+$", $expectedExtension)"`
    # Write a message to the output`
    Write-Output "Renamed file '$fileName' to have extension '$expectedExtension'"`
  }`
}
foreach ($file in $files) {`
  # Set the file extension if it does not match the one from trid`
  Set-FileExtensionIfNotMatch($file.Name)`
}
function Set-FileExtensionIfNotMatch($fileName) {`
  # Get the current file extension`
  $currentExtension = [System.IO.Path]::GetExtension($fileName)`
`
  # Get the expected file extension from trid`
  $expectedExtension = Get-FileExtensionFromTrid($fileName)`
`
  # Check if the current and expected extensions are different`
  if ($currentExtension -ne $expectedExtension) {`
    # Rename the file with the expected extension`
    Rename-Item -Path $fileName -NewName ("$fileName.$expectedExtension")`
    # Write a message to the output`
    Write-Output "Renamed file '$fileName' to have extension '$expectedExtension'"`
  }`
}
foreach ($file in $files) {`
  # Set the file extension if it does not match the one from trid`
  Set-FileExtensionIfNotMatch($file.Name)`
}
foreach ($file in (get-childitems)) {`
  # Set the file extension if it does not match the one from trid`
  Set-FileExtensionIfNotMatch($file.fullname)`
}
foreach ($file in (get-children)) {`
  # Set the file extension if it does not match the one from trid`
  Set-FileExtensionIfNotMatch($file.fullname)`
}
Get-ChildItem -File | % {  Set-FileExtensionIfNotMatch $_ }
function Set-FileExtensionIfNotMatch($fileName) {`
  # Get the current file extension`
  $currentExtension = [System.IO.Path]::GetExtension($fileName)`
`
  # Get the expected file extension from trid`
  $expectedExtension = Get-FileExtensionFromTrid($fileName)`
`
  # Check if the current and expected extensions are different`
  if ($currentExtension -ne $expectedExtension) {`
    # Rename the file with the expected extension`
    Rename-Item -Path $fileName -NewName ("$fileName$expectedExtension")`
    # Write a message to the output`
    Write-Output "Renamed file '$fileName' to have extension '$expectedExtension'"`
  }`
}
set-location 'D:\#recycle\Users\Default\AppData\Roaming\Opera Software\Opera GX Stable\_side_profiles\a_Lat\Service Worker\CacheStorage\13e96aa35b1ef826bb1055214f76943b76384b6b\0204875e-4be9-4551-b4ff-00732d951ff2'; Get-ChildItem -File | % {  Set-FileExtensionIfNotMatch $_ }
set-location 'D:\File System\Users\Default\AppData\Local\Opera Software\Opera GX Stable\_side_profiles\a_got\Cache\Cache_Data\f_000827'; Get-ChildItem -File | % {  Set-FileExtensionIfNotMatch $_ }
set-location 'D:\File System\Users\Default\AppData\Local\Opera Software\Opera GX Stable\_side_profiles\a_got\Cache\Cache_Data\'; Get-ChildItem -File | % {  Set-FileExtensionIfNotMatch $_ }
set-location 'D:\File System\Users\Default\AppData\Local\Opera Software\Opera GX Stable\_side_profiles\a_afr\Cache\Cache_Data'; Get-ChildItem -File | % {  Set-FileExtensionIfNotMatch $_ }
set-location (get-clipboard); Get-ChildItem -File | % {  Set-FileExtensionIfNotMatch $_ }
function Set-FileExtensionIfNotMatch($fileName) {`
  # Get the current file extension`
  $currentExtension = [System.IO.Path]::GetExtension($fileName)`
`
  # Get the expected file extension from trid`
  $expectedExtension = Get-FileExtensionFromTrid($fileName)`
`
  # Check if the current and expected extensions are different`
  if ($currentExtension -ne $expectedExtension) {`
    # Rename the file with the expected extension`
    Rename-Item -Path $fileName -NewName ("$fileName$expectedExtension")`
    # Write a message to the output`
    Write-Output "Renamed file '$fileName' to have extension '$expectedExtension'"`
  }`
}
function Get-FileExtensionFromTrid($fileName) {`
  # Invoke trid with the file name and capture the output`
  $tridOutput = trid $fileName`
`
  # Check if the output contains any matches`
  if ($tridOutput -match "(\d+\.?\d*)%\s+\((\.\S+)\)\s+(.*)") {`
    # Get the highest percentage match and its corresponding extension`
    $highestMatch = ($tridOutput | Select-String "(\d+\.?\d*)%\s+\((\.\S+)\)\s+(.*)" -AllMatches).Matches | Select-Object -First 1`
    $extension = ($highestMatch.Groups[2].Value -split '/')[0]`
`
    # Return the extension`
    return $extension`
  }`
  else {`
    # Return an empty string if no matches are found`
    return ""`
  }`
}
set-location (get-clipboard); Get-ChildItem -File | % {  Set-FileExtensionIfNotMatch $_ }
# Get the list of files in the current directory
$files = Get-ChildItem -File
# Get the total number of files
$total = $files.Count
# Initialize a counter for the current file
$current = 0
# Loop through each file in the list
function SetFileExtension()`
{`
set-location (get-clipboard); `
 # Get the list of files in the current directory`
$files = Get-ChildItem -File`
`
# Get the total number of files`
$total = $files.Count`
`
# Initialize a counter for the current file`
$current = 0`
`
$files | % {`
$file = $_`
  $current++`
`
  # Calculate the percentage of completion`
  $percent = ($current / $total) * 100`
`
  # Write a progress message with a progress bar`
  Write-Progress -Activity "Setting file extensions" -Status "Processing file $current of $total" -PercentComplete $percent -CurrentOperation "Checking file '$($file.Name)'"`
`
  # Set the file extension if it does not match the one from trid`
  Set-FileExtensionIfNotMatch($file.Name)`
}`
}
SetFileExtension
function Set-FileExtensionIfNotMatch($fileName) {`
  # Get the current file extension`
  $currentExtension = [System.IO.Path]::GetExtension($fileName)`
`
  # Get the expected file extension from trid`
  $expectedExtension = Get-FileExtensionFromTrid($fileName)`
`
  # Check if the current and expected extensions are different`
  if ($currentExtension -ne $expectedExtension) {`
    # Rename the file with the expected extension`
    Rename-Item -Path $fileName -NewName ("$fileName$expectedExtension")`
    # Write a message to the output`
    Write-Output "Renamed file '$fileName' to have extension '$expectedExtension'"`
  }`
}
function Get-FileExtensionFromTrid($fileName) {`
  # Invoke trid with the file name and capture the output`
  $tridOutput = trid $fileName`
`
  # Check if the output contains any matches`
  if ($tridOutput -match "(\d+\.?\d*)%\s+\((\.\S+)\)\s+(.*)") {`
    # Get the highest percentage match and its corresponding extension`
    $highestMatch = ($tridOutput | Select-String "(\d+\.?\d*)%\s+\((\.\S+)\)\s+(.*)" -AllMatches).Matches | Select-Object -First 1`
    $extension = ($highestMatch.Groups[2].Value -split '/')[0]`
`
    # Return the extension`
    return $extension`
  }`
  else {`
    # Return an empty string if no matches are found`
    return ""`
  }`
}
function SetFileExtension()`
{`
set-location (get-clipboard); `
 # Get the list of files in the current directory`
$files = Get-ChildItem -File`
`
# Get the total number of files`
$total = $files.Count`
`
# Initialize a counter for the current file`
$current = 0`
`
$files | % {`
$file = $_`
  $current++`
`
  # Calculate the percentage of completion`
  $percent = ($current / $total) * 100`
`
  # Write a progress message with a progress bar`
  Write-Progress -Activity "Setting file extensions" -Status "Processing file $current of $total" -PercentComplete $percent -CurrentOperation "Checking file '$($file.Name)'"`
`
  # Set the file extension if it does not match the one from trid`
  Set-FileExtensionIfNotMatch($file.Name)`
}`
}
SetFileExtension
function Set-FileExtensionIfNotMatch($fileName) {`
  # Get the current file extension`
  $currentExtension = [System.IO.Path]::GetExtension($fileName)`
`
  # Get the expected file extension from trid`
  $expectedExtension = Get-FileExtensionFromTrid($fileName)`
`
  # Check if the current and expected extensions are different`
  if ($currentExtension -ne $expectedExtension) {`
    # Rename the file with the expected extension`
    Rename-Item -Path $fileName -NewName ("$fileName$expectedExtension")`
    # Write a message to the output`
    Write-Output "Renamed file '$fileName' to have extension '$expectedExtension'"`
  }`
}
function Get-FileExtensionFromTrid($fileName) {`
  # Invoke trid with the file name and capture the output`
  $tridOutput = trid $fileName`
`
  # Check if the output contains any matches`
  if ($tridOutput -match "(\d+\.?\d*)%\s+\((\.\S+)\)\s+(.*)") {`
    # Get the highest percentage match and its corresponding extension`
    $highestMatch = ($tridOutput | Select-String "(\d+\.?\d*)%\s+\((\.\S+)\)\s+(.*)" -AllMatches).Matches | Select-Object -First 1`
    $extension = ($highestMatch.Groups[2].Value -split '/')[0]`
`
    # Return the extension`
    return $extension`
  }`
  else {`
    # Return an empty string if no matches are found`
    return ""`
  }`
}
function SetFileExtension()`
{`
set-location (get-clipboard); `
 # Get the list of files in the current directory`
$files = Get-ChildItem -File`
`
# Get the total number of files`
$total = $files.Count`
`
# Initialize a counter for the current file`
$current = 0`
`
$files | % {`
$file = $_`
  $current++`
`
  # Calculate the percentage of completion`
  $percent = ($current / $total) * 100`
`
  # Write a progress message with a progress bar`
  Write-Progress -Activity "Setting file extensions" -Status "Processing file $current of $total" -PercentComplete $percent -CurrentOperation "Checking file '$($file.Name)'"`
`
  # Set the file extension if it does not match the one from trid`
  Set-FileExtensionIfNotMatch($file.Name)`
}`
}
SetFileExtension
function SetFileExtension()`
{`
set-location (get-clipboard); `
 # Get the list of files in the current directory`
$files = Get-ChildItem -File`
`
# Get the total number of files`
$total = $files.Count`
`
# Initialize a counter for the current file`
$current = 0`
`
$files | % {`
$file = $_`
  $current++`
`
  # Calculate the percentage of completion`
  $percent = ($current / $total) * 100`
`
  # Write a progress message with a progress bar`
  Write-Progress -Activity "Setting file extensions in " -Status "Processing file $current of $total" -PercentComplete $percent -CurrentOperation "Checking file '$($file.Name)'"`
`
  # Set the file extension if it does not match the one from trid`
  Set-FileExtensionIfNotMatch($file.Name)`
}`
}
function SetFileExtension()`
{`
set-location (get-clipboard); `
$location = get-clipboard # Get the list of files in the current directory`
$files = Get-ChildItem -File`
`
# Get the total number of files`
$total = $files.Count`
`
# Initialize a counter for the current file`
$current = 0`
`
$files | % {`
$file = $_`
  $current++`
`
  # Calculate the percentage of completion`
  $percent = ($current / $total) * 100`
`
  # Write a progress message with a progress bar`
  Write-Progress -Activity "Setting file extensions in $location" -Status "Processing file $current of $total" -PercentComplete $percent -CurrentOperation "Checking file '$($file.Name)'"`
`
  # Set the file extension if it does not match the one from trid`
  Set-FileExtensionIfNotMatch($file.Name)`
}`
}
SetFileExtension
function SetFileExtension()`
{`
set-location (get-clipboard); `
$location = get-clipboard # Get the list of files in the current directory`
$files = Get-ChildItem -File`
$location = $location.Substring($location.length-50)`
# Get the total number of files`
$total = $files.Count`
`
# Initialize a counter for the current file`
$current = 0`
`
$files | % {`
$file = $_`
  $current++`
`
  # Calculate the percentage of completion`
  $percent = ($current / $total) * 100`
`
  # Write a progress message with a progress bar`
  Write-Progress -Activity "Setting file extensions in $location" -Status "Processing file $current of $total" -PercentComplete $percent -CurrentOperation "Checking file '$($file.Name)'"`
`
  # Set the file extension if it does not match the one from trid`
  Set-FileExtensionIfNotMatch($file.Name)`
}`
}
SetFileExtension
es 'cache_data'
& 'O:\EverythingPortable\EverythingPortable.exe' 'cache_data'
D:
Get-ChildItem -r -filter 'Cache_data'
Get-ChildItem -path $pwd* -r -filter 'Cache_data'
Get-ChildItem -path $pwd* -Recurse -filter 'Cache_data'
Get-ChildItem -path $pwd* -Recurse 
set-location D:\ ;  Get-ChildItem -path $pwd* -Recurse 
Get-ChildItem -path $pwd* -Recurse -filter 'Cache_data'
# Start a background job to display the nested progress bar
Start-Job -ScriptBlock {`
    Write-Progress -Activity "Nested Progress Bar" -Status "Starting..."`
`
    # Update the nested progress bar periodically`
    while ($true) {`
        Write-Progress -Activity "Nested Progress Bar" -PercentComplete ($random.Next(0, 100))`
`
        # Wait for 1 second`
        Start-Sleep -Seconds 1`
    }`
`
    # Complete the nested progress bar`
    Write-Progress -Activity "Nested Progress Bar" -PercentComplete 100 -Complete`
}
# Start the main progress bar
Write-Progress -Activity "Main Progress Bar" -Status "Starting..."
# Call the background job to display the nested progress bar
Invoke-Command -ScriptBlock {`
    Receive-Job -Name "Nested Progress Bar"`
}
# Update the main progress bar periodically
while ($true) {`
    Write-Progress -Activity "Main Progress Bar" -PercentComplete ($random.Next(0, 100))`
`
    # Wait for 1 second`
    Start-Sleep -Seconds 1`
}
# Complete the main progress bar
# Create an outer progress bar
Write-Progress -Activity "Outer Progress Bar" -Status "Starting..."
# Create an inner progress bar
Write-Progress -Activity "Inner Progress Bar" -Status "Starting..."
# Start the outer progress bar
Write-Progress -Activity "Outer Progress Bar" -PercentComplete 25
# Start the inner progress bar
Write-Progress -Activity "Inner Progress Bar" -PercentComplete 10
# Update the progress bars periodically
while ($true) {`
    # Update the outer progress bar`
    Write-Progress -Activity "Outer Progress Bar" -PercentComplete ($random.Next(0, 100))`
`
    # Update the inner progress bar`
    Write-Progress -Activity "Inner Progress Bar" -PercentComplete ($random.Next(0, 100))`
`
    # Wait for 1 second`
    Start-Sleep -Seconds 1`
}
# Complete the outer progress bar
Write-Progress -Activity "Outer Progress Bar" -PercentComplete 100 -Complete
# Complete the inner progress bar
Write-Progress -Activity "Inner Progress Bar" -PercentComplete 100 -Complete# Create an outer progress bar
Write-Progress -Activity "Outer Progress Bar" -Status "Starting..."
# Create an inner progress bar
Write-Progress -Activity "Inner Progress Bar" -Status "Starting..."
# Start the outer progress bar
Write-Progress -Activity "Outer Progress Bar" -PercentComplete 25
# Start the inner progress bar
Write-Progress -Activity "Inner Progress Bar" -PercentComplete 10
# Update the progress bars periodically
while ($true) {`
    # Update the outer progress bar`
    Write-Progress -Activity "Outer Progress Bar" -PercentComplete ($random.Next(0, 100))`
`
    # Update the inner progress bar`
    Write-Progress -Activity "Inner Progress Bar" -PercentComplete ($random.Next(0, 100))`
`
    # Wait for 1 second`
    Start-Sleep -Seconds 1`
}
# Complete the outer progress bar
Write-Progress -Activity "Outer Progress Bar" -PercentComplete 100 -Complete
# Complete the inner progress bar
# Create an outer progress bar
$outer_progress_bar = New-Object System.Management.Automation.ProgressRecord
$outer_progress_bar.Activity = "Outer Progress Bar"
$outer_progress_bar.Status = "Starting Outer Progress Bar..."
$outer_progress_bar.PercentComplete = 0
Write-Progress -Activity $outer_progress_bar.Activity -Status $outer_progress_bar.Status -PercentComplete $outer_progress_bar.PercentComplete
# Create an inner progress bar
$inner_progress_bar = New-Object System.Management.Automation.ProgressRecord
$inner_progress_bar.Activity = "Inner Progress Bar"
$inner_progress_bar.Status = "Starting Inner Progress Bar..."
$inner_progress_bar.PercentComplete = 0
# Update the outer progress bar periodically
while ($outer_progress_bar.PercentComplete -lt 100) {`
`
    # Update the inner progress bar`
    $inner_progress_bar.PercentComplete = $inner_progress_bar.PercentComplete + 10`
`
    # Update the outer progress bar`
    $outer_progress_bar.PercentComplete = $outer_progress_bar.PercentComplete + 2`
`
    # Write the progress bars to the console`
    Write-Progress -Activity $outer_progress_bar.Activity -Status $outer_progress_bar.Status -PercentComplete $outer_progress_bar.PercentComplete`
    Write-Progress -Activity $inner_progress_bar.Activity -Status $inner_progress_bar.Status -PercentComplete $inner_progress_bar.PercentComplete`
`
    # Wait for a short period of time`
    Start-Sleep -Seconds 1`
}
# Complete the outer progress bar
$outer_progress_bar.Complete = $true
Write-Progress -Activity $outer_progress_bar.Activity -Status $outer_progress_bar.Status -PercentComplete $outer_progress_bar.PercentComplete# Create an outer progress bar
$outer_progress_bar = New-Object System.Management.Automation.ProgressRecord
$outer_progress_bar.Activity = "Outer Progress Bar"
$outer_progress_bar.Status = "Starting Outer Progress Bar..."
$outer_progress_bar.PercentComplete = 0
Write-Progress -Activity $outer_progress_bar.Activity -Status $outer_progress_bar.Status -PercentComplete $outer_progress_bar.PercentComplete
# Create an inner progress bar
$inner_progress_bar = New-Object System.Management.Automation.ProgressRecord
$inner_progress_bar.Activity = "Inner Progress Bar"
$inner_progress_bar.Status = "Starting Inner Progress Bar..."
$inner_progress_bar.PercentComplete = 0
# Update the outer progress bar periodically
while ($outer_progress_bar.PercentComplete -lt 100) {`
`
    # Update the inner progress bar`
    $inner_progress_bar.PercentComplete = $inner_progress_bar.PercentComplete + 10`
`
    # Update the outer progress bar`
    $outer_progress_bar.PercentComplete = $outer_progress_bar.PercentComplete + 2`
`
    # Write the progress bars to the console`
    Write-Progress -Activity $outer_progress_bar.Activity -Status $outer_progress_bar.Status -PercentComplete $outer_progress_bar.PercentComplete`
    Write-Progress -Activity $inner_progress_bar.Activity -Status $inner_progress_bar.Status -PercentComplete $inner_progress_bar.PercentComplete`
`
    # Wait for a short period of time`
    Start-Sleep -Seconds 1`
}
# Complete the outer progress bar
$outer_progress_bar.Complete = $true
$OuterProgress = Write-Progress -Activity "Outer Progress Bar" -Status "Starting..." -PercentComplete 0
$InnerProgress = Write-Progress -Activity "Inner Progress Bar" -Status "Starting..." -PercentComplete 0 -Parent $OuterProgress
# Do some work here
Write-Progress -Activity "Outer Progress Bar" -PercentComplete 50
Write-Progress -Activity "Inner Progress Bar" -PercentComplete 75
# Do some more work here
Write-Progress -Activity "Outer Progress Bar" -PercentComplete 100 -Completed
Write-Progress -Activity "Inner Progress Bar" -PercentComplete 100 -Completed$OuterProgress = Write-Progress -Activity "Outer Progress Bar" -Status "Starting..." -PercentComplete 0
$InnerProgress = Write-Progress -Activity "Inner Progress Bar" -Status "Starting..." -PercentComplete 0 -Parent $OuterProgress
# Do some work here
Write-Progress -Activity "Outer Progress Bar" -PercentComplete 50
Write-Progress -Activity "Inner Progress Bar" -PercentComplete 75
# Do some more work here
Write-Progress -Activity "Outer Progress Bar" -PercentComplete 100 -Completed
ipconfig /all
ipconfig /renew
function SetFileExtension()`
{`
set-location (get-clipboard); `
$location = get-clipboard # Get the list of files in the current directory`
$files = Get-ChildItem -File`
$location = $location.Substring($location.length-50)`
# Get the total number of files`
$total = $files.Count`
`
# Initialize a counter for the current file`
$current = 0`
`
$files | % {`
$file = $_`
  $current++`
`
  # Calculate the percentage of completion`
  $percent = ($current / $total) * 100`
`
  # Write a progress message with a progress bar`
  Write-Progress -Activity "Setting file extensions in $location" -Status "Processing file $current of $total" -PercentComplete $percent -CurrentOperation "Checking file '$($file.Name)'"`
`
  # Set the file extension if it does not match the one from trid`
  Set-FileExtensionIfNotMatch($file.Name)`
}`
}
function Set-FileExtensionIfNotMatch($fileName) {`
  # Get the current file extension`
  $currentExtension = [System.IO.Path]::GetExtension($fileName)`
`
  # Get the expected file extension from trid`
  $expectedExtension = Get-FileExtensionFromTrid($fileName)`
`
  # Check if the current and expected extensions are different`
  if ($currentExtension -ne $expectedExtension) {`
    # Rename the file with the expected extension`
    Rename-Item -Path $fileName -NewName ("$fileName$expectedExtension")`
    # Write a message to the output`
    Write-Output "Renamed file '$fileName' to have extension '$expectedExtension'"`
  }`
}
function SetFileExtension()`
{`
set-location (get-clipboard); `
$location = get-clipboard # Get the list of files in the current directory`
$files = Get-ChildItem -File`
`
# Get the total number of files`
$total = $files.Count`
`
# Initialize a counter for the current file`
$current = 0`
`
$files | % {`
$file = $_`
  $current++`
`
  # Calculate the percentage of completion`
  $percent = ($current / $total) * 100`
`
  # Write a progress message with a progress bar`
  Write-Progress -Activity "Setting file extensions in $location" -Status "Processing file $current of $total" -PercentComplete $percent -CurrentOperation "Checking file '$($file.Name)'"`
`
  # Set the file extension if it does not match the one from trid`
  Set-FileExtensionIfNotMatch($file.Name)`
}`
}
Copy-Function setFileExtension
Copy-Function Set-FileExtensionIfNotMatch
function Get-FileExtensionFromTrid($fileName) {`
  # Invoke trid with the file name and capture the output`
  $tridOutput = trid $fileName`
`
  # Check if the output contains any matches`
  if ($tridOutput -match "(\d+\.?\d*)%\s+\((\.\S+)\)\s+(.*)") {`
    # Get the highest percentage match and its corresponding extension`
    $highestMatch = ($tridOutput | Select-String "(\d+\.?\d*)%\s+\((\.\S+)\)\s+(.*)" -AllMatches).Matches | Select-Object -First 1`
    $extension = ($highestMatch.Groups[2].Value -split '/')[0]`
`
    # Return the extension`
    return $extension`
  }`
  else {`
    # Return an empty string if no matches are found`
    return ""`
  }`
}
Copy-Function get-fileExtensionFromTrid
setFileExtension
& setFileExtension
setFileExtension
& setFileExtension
setFileExtension
& setFileExtension
setFileExtension
get-clipboard
$q = get-clipboard ; $q | % { " " }
$q = get-clipboard ; $q | % { trim($_) }
$q = get-clipboard ; $q | % { $_ -trim }
$q = get-clipboard ; $q | % { $_.trim() }
#$q = get-clipboard ; $q | % { $s = $_.trim() ; set-clipboard $s ; $ }
$q = get-clipboard ; $q | % { $s = $_.trim() ; set-clipboard $s ; SetFileExtension }
New-NetSMBShare -Name Share1 -Path C:\Shares\Share1 -FullAccess VM1
Get-Command -Module hyper-v | Out-GridView
New-NetSMBShare -Name Share1 -Path C:\Shares\Share1 -FullAccess VM1
Get-Command -Module hyper-v | Out-GridView
$PSVersionTable.PSVersion
Install-Module -Name SMBShare -Force
$profile
Install-Module -Name SMBShare -Force
nfsadmin export b
Install-Module -Name nfsadmin -Force
Install-WindowsFeature NFS-Server
cinst juicefs
choco install python38
choco install winfs
juicefs mount
explorer ($profile | Split-Path -parent)
Every-Menu
Install-Module -Name ps-menu
Every-Menu
$q = get-clipboard ; $q | % { $s = $_.trim() ; set-clipboard $s ; SetFileExtension }
scoop uninstall smartgit
scoop install smartgit
scoop uninstal smartgit
scoop uninstall smartgit
cinst smartgit
scoop install smartgit
JUICEFS
function Ensure-Path {`
    param (`
        [string]$Path`
    )`
    # Validate the parameter`
    if (-not $Path) {`
        Write-Error "Path parameter is required"`
        return`
    }`
    # Resolve the path to an absolute path`
    $AbsolutePath = Resolve-Path -Path $Path -ErrorAction SilentlyContinue`
    if (-not $AbsolutePath) {`
        # The path is invalid, throw an error`
        throw "The path '$Path' is not a valid path"`
    }`
    # Check if the path exists`
    if (Test-Path -Path $AbsolutePath) {`
        # The path exists, do nothing`
        return`
    }`
    else {`
        # The path does not exist, try to create it`
        try {`
            New-Item -Path $AbsolutePath -ItemType Directory -Force -ErrorAction Stop`
        }`
        catch {`
            # An error occurred while creating the path, throw an error`
            throw "Failed to create the path '$AbsolutePath': $($_.Exception.Message)"`
        }`
    }`
}
ensure-path 'B:\JuceFsDb'
ensure-path 'B:/JuceFsDb'
ensure-path 'B:\JuceFsDb\'
B: ; ensure-path 'B:\JuceFsDb\'
B: ; ensure-path '\JuceFsDb\'
B: ; ensure-path 'JuceFsDb\'
B: ; ensure-path 'JuceFsDb'
ensure-path -Path 'B:\JuceFsDb\'
$path = 'B:\JucieFsDb' ; Resolve-Path -Path $Path -ErrorAction SilentlyContinue
$path = 'B:\JucieFsDb' ; Resolve-Path -Path $Path
function Ensure-Path {`
    param (`
        [string]$Path`
    )`
    # Validate the parameter`
    if (-not $Path) {`
        Write-Error "Path parameter is required"`
        return`
    }`
    # Check if the path is valid`
    if (-not [System.IO.Path]::IsPathRooted($Path)) {`
        # The path is relative, resolve it to an absolute path`
        $Path = Join-Path -Path (Get-Location) -ChildPath $Path`
    }`
    # Check if the path contains invalid characters`
    if ([System.IO.Path]::GetInvalidPathChars() -join '' -match [regex]::Escape($Path)) {`
        # The path contains invalid characters, throw an error`
        throw "The path '$Path' contains invalid characters."`
    }`
    # Check if the path exists`
    if (Test-Path -Path $Path) {`
        # The path exists, return it`
        return $Path`
    }`
    else {`
        # The path does not exist, try to create it`
        try {`
            $item = New-Item -Path $Path -ItemType Directory -Force -ErrorAction Stop`
            # Return the full path of the created directory`
            return $item.FullName`
        }`
        catch {`
            # An error occurred while creating the path, throw an error`
            throw "Failed to create the path '$Path': $($_.Exception.Message)"`
        }`
    }`
}
ensure-path -Path 'B:\JuceFsDb\'
JUICEFS
B:
juicefs format sqlite3://myjfs.db myjfs
juicefs mount sqlite3://myjfs.db myjfs
juicefs mount sqlite3://myjfs.db 'B:\JuceFsDb'
juicefs status
juicefs status sqlite3://myjfs.db
juicefs mount sqlite3://myjfs.db 'J:'
juicefs mount sqlite3://myjfs.db J:
J:
ls
cd J:\.trash
Copy-Function ensure-path
function Ensure-Path {`
    param (`
        [string]$Path`
    )`
    # Validate the parameter`
    if (-not $Path) {`
        Write-Error "Path parameter is required"`
        return`
    }`
    # Check if the path is valid`
    if (-not [System.IO.Path]::IsPathRooted($Path)) {`
        # The path is relative, resolve it to an absolute path`
        $Path = Join-Path -Path (Get-Location) -ChildPath $Path`
    }`
    # Check if the path contains invalid characters`
    if ([System.IO.Path]::GetInvalidPathChars() -join '' -match [regex]::Escape($Path)) {`
        # The path contains invalid characters, throw an error`
        throw "The path '$Path' contains invalid characters."`
    }`
    # Check if the path exists`
    if (Test-Path -Path $Path) {`
        # The path exists, return it`
        return $Path`
    }`
    else {`
        # The path does not exist, try to create it`
        try {`
            $item = New-Item -Path $Path -ItemType Directory -Force -ErrorAction Stop`
            # Return the full path of the created directory`
            return $item.FullName`
        }`
        catch {`
            # An error occurred while creating the path, throw an error`
            throw "Failed to create the path '$Path': $($_.Exception.Message)"`
        }`
    }`
}
Copy-Function ensure-path
$q = get-clipboard ; $q | % { $s = $_.trim() ; set-clipboard $s ; SetFileExtension }
cd 'B:\GitFolders'
set-location 'B:\GitFolders'
git push -all 'B:\PF\Archive'
git push --all 'B:\PF\Archive'
git config -l --show-origin
git config -l --show-origin | ? { $_ -like 'credidential' }
@(git config -l --show-origin 2&>1) | ? { $_ -like 'credidential' }
function Invoke-Git {`
    param(`
        [Parameter(Mandatory=$true)]`
        [string]$Command # The git command to run`
    )`
    # Run the command and capture the output`
    $output = Invoke-Expression -Command "git $Command 2>&1" -ErrorAction Stop `
    # return the output to the host`
    $output`
    # Check the exit code and throw an exception if not zero`
   if ($LASTEXITCODE -ne 0) {`
        trow "Git command failed: git $Command"`
    }`
}
Copy-Function invoke-git
invoke-git 'config -l --show-origin'
@(invoke-git 'config -l --show-origin') | ? { $_ -like 'credidential' }
@(invoke-git 'config -l --show-origin') | ? { $_ -like 'credi' }
@(invoke-git 'config -l --show-origin') | ? { $_ -match 'credi' }
@(invoke-git 'config -l --show-origin') | Measure-Object
@(invoke-git 'config -l --show-origin') | ? { $_ -match 'push' }
@(invoke-git 'config -l --show-origin') | ? { $_ -match 'cred' }
git config --global credential.helper wincred
scoop reinstall vortex
D:
cd OperaLauncher
set OperaLauncher
set-location OperaLauncher
& opera.ps1
ls
.\opera.ps1
.\opera.ps1 -a a_toon
.\opera.ps1 -a a_zo
D: ; .\opera.ps1 -a a_zo
D: ; .OperaLauncher\opera.ps1 -a a_zo
D: ; .\OperaLauncher\opera.ps1 -a a_zo
D: ; .\OperaLauncher\opera.ps1 -a a_wif
get-clipboard
$regex = "https://open.spotify.com/playlist/"+"(.*)"+"?si=.*"; $u = get-clipboard ; $u -replace $regex "spotify:user:spotify:playlist:/1" 
$regex = regex::escape("https://open.spotify.com/playlist/") + "(.*)" + regex::escape("?si=") + ".*"; $u = get-clipboard ; $u -replace $regex "spotify:user:spotify:playlist:/1" 
$replace = "spotify:user:spotify:playlist:/1" ; $regex = regex::escape("https://open.spotify.com/playlist/") + "(.*)" + regex::escape("?si=") + ".*"; $u = get-clipboard ; $u -replace $regex $replace
$original = get-clipboard ; $transformed = $original.replace(“.*/playlist/”, “spotify:user:spotify:playlist:”).replace(“?si=.*”, “”) ; $transformed
$original = get-clipboard ; $transformed = $original.replace(“/playlist/”, “spotify:user:spotify:playlist:”).replace(“?si=.*”, “”) ; $transformed
$original = get-clipboard ; $transformed = $original.replace(“https://open.spotify.com/playlist/”, “spotify:user:spotify:playlist:”).replace(“?si=.*”, “”) ; $transformed
$original = get-clipboard ; $transformed = $original.replace(“https://open.spotify.com/playlist/”, “spotify:user:spotify:playlist:”).replace(“?si=”, “=”) ; ($transformed -split '=')[0]
function Spotify-UrlToPlaylist { $original = get-clipboard ; $transformed = $original.replace(“https://open.spotify.com/playlist/”, “spotify:user:spotify:playlist:”).replace(“?si=”, “=”) ; ($transformed -split '=')[0] | set-clipboard ; "done" }
Spotify-UrlToPlaylist
copy-function Spotify-UrlToPlaylist
notepad $profile
D: ; .\OperaLauncher\opera.ps1 -a a_stash
Spotify-UrlToPlaylist
D: ; .\OperaLauncher\opera.ps1 -a a_stash
& setFileExtension
D: ; .\OperaLauncher\opera.ps1 -a a_stash
& setFileExtension
D: ; .\OperaLauncher\opera.ps1 -a a_stash
& setFileExtension
D: ; .\OperaLauncher\opera.ps1 -a a_stash
Get-Clipboard | % { $_ -replace ',' ';*.' } | set-clipboard
$regex = ',' ; $set = ';*.' ; Get-Clipboard | % { $_ -replace $regex $set } | set-clipboard
$regex = ',' ; $set = ';*.' ; Get-Clipboard | % { $_ -replace $regex, $set } | set-clipboard
$regex = ',' ; $set = ';*.' ; Get-Clipboard | % { $_ -split $regex } | % { $_.trim() | % { "*.$_" } } 
($regex = ',' ; $set = ';*.' ; Get-Clipboard | % { $_ -split $regex } | % { $_.trim() | % { "*.$_" } } ) -join ';'
$regex = ',' ; $set = ';*.' ; (Get-Clipboard | % { $_ -split $regex } | % { $_.trim() | % { "*.$_" } } ) -join ';'
$regex = ',' ; $set = ';*.' ; (Get-Clipboard | % { $_ -split $regex } | % { $_.trim() | % { "*.$_" } } ) -join ';' | set-clipboard
scoop install irfanview-plugins
$regex = ';*.' ; $set = ';*.' ; (Get-Clipboard | % { $_ -split $regex } | % { $_.trim() | % { "$_" } } ) -join ';' | set-clipboard
$regex = ',' ; $set = ';*.' ; (Get-Clipboard | % { $_ -split $regex } | % { $_.trim() | % { "$_" } } ) -join ';' | set-clipboard
D: ; .\OperaLauncher\opera.ps1 -a a_stash
explorer D:\
& setFileExtension
D: ; .\OperaLauncher\opera.ps1 -a a_stash
git filter-repo --analyze -f
git filter-repo
git checkout -b backupBranch
git filter-repo --path-rename Git-Module:. --refs master
git filter-repo --path-rename 'Git-Module':. --refs master
git filter-repo --subdirectory-filter Git-Module --refs backupBranch
git filter-repo --invert-paths --path Git-Module 
scoop install guipropview
sudo scoop install guipropview
cd 'B:\PF\Archive\ps1\git\repair'
set-location 'B:\PF\Archive\ps1\git\repair'
$applicationsToRemove = @("*Xbox*","*Maps*","*Money*","*News*","*OneNote*","*Photos*","*SkyDrive*","*Store*","*VoiceRecorder*")`
Get-AppxPackage | Where-Object {$_.Name -like $applicationsToRemove }
$applicationsToRemove = @("*Xbox*","*Maps*","*Money*","*News*","*OneNote*","*Photos*","*SkyDrive*","*Store*","*VoiceRecorder*")
Get-AppxPackage | Where-Object {$_.Name -like $applicationsToRemove }
 $applicationsToRemove
Get-AppxPackage
$exampleList = @("Xbox One", "Windows Maps", "Microsoft Money", "Microsoft News", "OneNote 2016", "Microsoft Photos", "SkyDrive", "Microsoft Store", "Voice Recorder")
$atr = @("*Xbox*","*Maps*","*Money*","*News*","*OneNote*","*Photos*","*SkyDrive*","*Store*","*VoiceRecorder*")
$filteredList = $exampleList | Where-Object {$_.Name -like $atr }
Write-Output $filteredList
$atr = @("*Xbox*","*Maps*","*Money*","*News*","*OneNote*","*Photos*","*SkyDrive*","*Store*","*VoiceRecorder*")
$exampleList | Where-Object {$_.Name -like -any $atr}$atr = @("*Xbox*","*Maps*","*Money*","*News*","*OneNote*","*Photos*","*SkyDrive*","*Store*","*VoiceRecorder*")
$exampleList | Where-Object {$_.Name -any $atr}
scoop bucket add 'https://github.com/perXautomatik/scoopbucket-1' perXautomatik
scoop bucket add perXautomatik 'https://github.com/perXautomatik/scoopbucket-1' 
scoop install ahk-studio
D: ; .\OperaLauncher\opera.ps1 -a a_toon
F: ; .\OperaLauncher\opera.ps1 -a a_toon
git config --global --add safe.directory C:/ProgramData/scoop/buckets/perXautomatik
scoop install VISUALCRON
scoop install autologon
scoop install ahk2manager
scoop install pdf-xchange-viewer
F: ; .\OperaLauncher\opera.ps1 -a a_ana
scoop install alphinewsl
scoop install alphine-wsl
scoop install extras/alpinewsl
scoop install sidebar-diagnostics
scoop install sublime-merge
F: ; .\OperaLauncher\opera.ps1 -a a_fr
F: ; .\OperaLauncher\opera.ps1 -a a_afr
git filter-repo --analyze
git filter-repo --analyze --force
F: ; .\OperaLauncher\opera.ps1 -a a_afr
& setFileExtension
scoop install extras/keepassxc
& setFileExtension
$process = Get-Process -Name chrome | Where-Object { $_.ProcessName -like "*chrome.exe" }
$profileFolder = $process.MainWindowHandle | Get-ProcessWindow -WorkingDirectory
$chromeProcessId = (Get-Process -Filter "Name -like 'chrome*'" -ErrorAction SilentlyContinue).Id
F: ; .\OperaLauncher\opera.ps1 -a 31303338385F31393039343835363038
F: ; .\OperaLauncher\opera.ps1 -a a_afr
F: 
ks
ls
F: ; cd F:\ ; .\OperaLauncher\opera.ps1 -a a_afr
F: ; cd F:\ ; .\OperaLauncher\opera.ps1 -a 31303338385F31393039343835363038
F: ; cd F:\ ; .\OperaLauncher\opera.ps1 -a 31303338385F31393039343835363038 | % { $_ + "_" }
F: ; cd F:\ ; .\OperaLauncher\opera.ps1 -a 31303338385F31393039343835363038 ; & setFileExtension
$q = a_jap ; F: ; cd F:\ ; .\OperaLauncher\opera.ps1 -a $q ; & setFileExtension
$q = "a_jap" ; F: ; cd F:\ ; .\OperaLauncher\opera.ps1 -a $q ; & setFileExtension
$q = "Database" ; F: ; cd F:\ ; .\OperaLauncher\opera.ps1 -a $q ; & setFileExtension
ls 'C:\Users\CrRoot\AppData\Roaming\Microsoft\Windows\Libraries\Database.library-ms'
Get-ChildItem 'C:\Users\CrRoot\AppData\Roaming\Microsoft\Windows\Libraries\Database.library-ms'
$q = "a_tha" ; F: ; cd F:\ ; .\OperaLauncher\opera.ps1 -a $q ; & setFileExtension
cd 'B:\PF\Archive\dotFiles'
set-location 'B:\PF\Archive\dotFiles'
ls
git filter-repo --analyze --force
$q = "a_jew" ; F: ; cd F:\ ; .\OperaLauncher\opera.ps1 -a $q ; & setFileExtension
$q = "a_bust" ; F: ; cd F:\ ; .\OperaLauncher\opera.ps1 -a $q ; & setFileExtension
$q = "a_cast" ; F: ; cd F:\ ; .\OperaLauncher\opera.ps1 -a $q ; & setFileExtension
$q = "a_got" ; F: ; cd F:\ ; .\OperaLauncher\opera.ps1 -a $q ; & setFileExtension
$q = "a_fr" ; F: ; cd F:\ ; .\OperaLauncher\opera.ps1 -a $q ; & setFileExtension
$q = "a_tee" ; F: ; cd F:\ ; .\OperaLauncher\opera.ps1 -a $q ; & setFileExtension
$q = "a_tha" ; F: ; cd F:\ ; .\OperaLauncher\opera.ps1 -a $q ; & setFileExtension
git filter-repo --analyze --force ; git filter-repo --path '.config' --dry-run
git checkout 'config'
git checkout -b 'configb'
 git filter-repo --refs 'configb' --subdirectory-filter '.config'
 git filter-repo --refs 'etcsa' --path '.config' --invert-paths
git checkout -b 'etcsa'
$historypath
$history
Get-History
git branch --show-current
   function git-fitler-folder`
   {`
      param(`
      $namex`
      )`
      $current = git branch --show-current;`
      $branchName = ($namex+'b');`
      `
      git checkout -b $branchName`
      `
      git filter-repo --refs $branchName --subdirectory-filter $namex`
      `
      git checkout $current`
      `
      git filter-repo --refs $current --path $namex --invert-paths      `
   }
git-filter-folder AppData
   function git-filter-folder`
   {`
      param(`
      $namex`
      )`
      $current = git branch --show-current;`
      $branchName = ($namex+'b');`
      `
      git checkout -b $branchName`
      `
      git filter-repo --refs $branchName --subdirectory-filter $namex`
      `
      git checkout $current`
      `
      git filter-repo --refs $current --path $namex --invert-paths      `
   }
git-filter-folder AppData
git-filter-folder Git
git-filter-folder nilesoft-shell
git-filter-folder PsReadline
git-filter-folder shell
 git filter-repo --refs 'shellb' --to-subdirectory-filter 'shell.shl' 
$q = "a_wif" ; D: ; cd D:\ ; .\OperaLauncher\opera.ps1 -a $q ; & setFileExtension
$q = "a_lx" ; D: ; cd D:\ ; .\OperaLauncher\opera.ps1 -a $q ; & setFileExtension
choco install choco-package-list-backup
choco install chocoupdater
chocoupdater
choco uninstall autohotke.install
choco uninstall autohotkey.install
choco uninstall autohotkey.portable
vswhere
choco uninstall soundwsitch
   function git-filter-folder`
   {`
      param(`
      $namex`
      )`
      $current = git branch --show-current;`
      $branchName = ($namex+'b');`
      `
      git checkout -b $branchName`
      `
      git filter-repo --refs $branchName --subdirectory-filter $namex`
      `
      git checkout $current`
      `
      git filter-repo --refs $current --path $namex --invert-paths      `
   }
copy-function git-filter-folder
npm install daff -g
daff
daff git csv
git config --global --get diff.daff-csv.command
$q = "a_wif" ; D: ; cd D:\ ; .\OperaLauncher\opera.ps1 -a $q ; & setFileExtension
$q = "a_fre" ; D: ; cd D:\ ; .\OperaLauncher\opera.ps1 -a $q ; & setFileExtension
